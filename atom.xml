<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>isKage`Blog</title>
  
  <subtitle>Welcome :)</subtitle>
  <link href="https://blog.iskage.online/atom.xml" rel="self"/>
  
  <link href="https://blog.iskage.online/"/>
  <updated>2025-05-31T10:09:51.376Z</updated>
  <id>https://blog.iskage.online/</id>
  
  <author>
    <name>isKage</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文本处理 (1) 模式匹配 KMP 算法与文本压缩 Huffman 编码</title>
    <link href="https://blog.iskage.online/posts/4758085b.html"/>
    <id>https://blog.iskage.online/posts/4758085b.html</id>
    <published>2025-05-31T00:16:00.000Z</published>
    <updated>2025-05-31T10:09:51.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本处理-1-模式匹配-KMP-算法与文本压缩-Huffman-编码"><a href="#文本处理-1-模式匹配-KMP-算法与文本压缩-Huffman-编码" class="headerlink" title="文本处理 (1) 模式匹配 KMP 算法与文本压缩 Huffman 编码"></a>文本处理 (1) 模式匹配 KMP 算法与文本压缩 Huffman 编码</h1><p>本章介绍常见的文本处理算法：模式匹配问题的 KMP 算法、文本压缩的 Huffman 编码树。</p><p>根据教材《数据结构与算法 Python 实现》整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><h2 id="1-模式匹配"><a href="#1-模式匹配" class="headerlink" title="1 模式匹配"></a>1 模式匹配</h2><p>设字符串 P 的长度为 m 。P 的一个子串（substring）<code>P[i:j+1]</code> 是 P 中从第 i 个到第 j 个字符构成的字符串</p><ul><li>P 的一个前缀（prefix）为：<code>P[0:i]</code></li><li>P 的一个后缀（suffix）为：<code>P[i:m-1]</code></li></ul><p><strong>文本的模式匹配（pattern matching）问题：</strong>给定一个文本（text）字符串 <code>T</code> 和一个模式（pattern）字符串 <code>P</code> ，在 T 中找到一个与 P 一致的子串。</p><h3 id="1-1-穷举"><a href="#1-1-穷举" class="headerlink" title="1.1 穷举"></a>1.1 穷举</h3><p>蛮力法/穷举法（brute-force）即列举所有可能的情况，并检查是否有符合要求的情况或寻找最优情况。模式匹配中，蛮力法即考虑所有 P 与 T 的子串可能匹配上的情况。</p><ul><li>具体操作：将 P 与 T 从头部对齐开始，每一步把 P 相对于 T 向后移动一位，直到找到一个匹配的位置或所有 P 与 T 的相对位置均被探索过。</li><li>蛮力法的时间复杂度为 <strong>O(nm)</strong> ，其中 n 为 T 的长度，m 为模式 P 的长度。</li><li>蛮力法的最坏情况例如：<code>T = &quot;aaaaaaaah&quot;</code> <code>P = &quot;aaah&quot;</code></li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748681572546.png" alt="穷举法示例"></p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_brute</span>(<span class="params">P, T</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    穷举法模式匹配</span></span><br><span class="line"><span class="string">    :param P: 寻找的模式</span></span><br><span class="line"><span class="string">    :param T: 被查找的对象</span></span><br><span class="line"><span class="string">    :return: T 的索引位置, 若失败返回 -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n, m = <span class="built_in">len</span>(T), <span class="built_in">len</span>(P)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - m + <span class="number">1</span>):</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; m <span class="keyword">and</span> T[i + k] == P[k]:</span><br><span class="line">            k += <span class="number">1</span>  <span class="comment"># 当前匹配成功, 继续匹配</span></span><br><span class="line">        <span class="keyword">if</span> k == m:</span><br><span class="line">            <span class="keyword">return</span> i  <span class="comment"># 完整匹配, 返回位置</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="1-2-KMP-算法"><a href="#1-2-KMP-算法" class="headerlink" title="1.2 KMP 算法"></a>1.2 KMP 算法</h3><p>KMP（<strong>K</strong>nuth-<strong>M</strong>orris-<strong>P</strong>ratt ）算法：预先计算模式部分之间的自重叠，从而当不匹配发生在一个位置时，我们在继续搜寻之前就能立刻知道移动模式的最大数目。</p><ul><li>先对模式字符串进行预处理，以寻找其前缀与其本身匹配的位置：定义<strong>失败函数（failure function）</strong><code>F(j)</code> 为最长的既为 <code>P[0:j+1]</code> 前缀又为 <code>P[1:j+1]</code> 后缀的子串长度。</li><li>KMP 算法在蛮力法上进行的改进为：匹配失败发生在 <code>P[j] != T[i]</code> 时，令 <code>j = F(j-1)</code> 继续尝试匹配。</li></ul><p>KMP 算法示例：现有文本字符串 <code>abaababaabababaca</code> 和模式串 <code>ababac</code> 。请求出模式串的失败函数，画出用 KMP 算法进行匹配的过程，并统计出比较的次数。</p><p>模式串 <code>ababac</code> 的失败函数为：<code>F(j)</code> 为最长的既为 <code>P[0: j]</code> 前缀又为 <code>P[1: j]</code> 后缀的子串长度</p><div class="table-container"><table><thead><tr><th style="text-align:left"><code>j</code></th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:left"><code>P[j]</code></td><td style="text-align:center"><code>a</code></td><td style="text-align:center"><code>b</code></td><td style="text-align:center"><code>a</code></td><td style="text-align:center"><code>b</code></td><td style="text-align:center"><code>a</code></td><td style="text-align:center"><code>c</code></td></tr><tr><td style="text-align:left"><code>F[j]</code></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">0</td></tr></tbody></table></div><p>KMP 算法总共比较了 $22$ 次（若匹配成功就退出）</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748682341243.png" alt="KMP 算法的比较过程"></p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_kmp_fail</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算模式的失败函数&quot;&quot;&quot;</span></span><br><span class="line">    m = <span class="built_in">len</span>(pattern)</span><br><span class="line">    fail = [<span class="number">0</span>] * m</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; m:</span><br><span class="line">        <span class="keyword">if</span> pattern[j] == pattern[k]:</span><br><span class="line">            fail[j] = k + <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            k = fail[k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_kmp</span>(<span class="params">pattern, text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从 text 中找到第一个完全匹配 pattern 的位置</span></span><br><span class="line"><span class="string">    :param pattern: 寻找的模式</span></span><br><span class="line"><span class="string">    :param text: 被查找的对象</span></span><br><span class="line"><span class="string">    :return: text 的索引位置, 若失败返回 -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(pattern), <span class="built_in">len</span>(text)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    fail = compute_kmp_fail(pattern)</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; n:</span><br><span class="line">        <span class="keyword">if</span> text[j] == pattern[k]:</span><br><span class="line">            <span class="keyword">if</span> k == m - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> j - m + <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            k = fail[k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>性能分析</strong></p><ul><li><p>失败函数：匹配成功 <code>i</code> 加一，匹配失败则 <code>i or j</code> 至少加一，最多 2m 次操作，复杂度为 <strong>O(m)</strong> ，m 为模式长度。</p></li><li><p>KMP 算法：匹配成功 <code>i</code> 加一，匹配失败则 <code>i or j</code> 至少加一，最多 2n 次操作，加之失败函数的复杂度，KMP 算法的复杂度为 <strong>O(n + m)</strong> ，m 为模式长度，n 为被匹配字符串长度。</p></li></ul><h2 id="2-文本压缩与贪心算法"><a href="#2-文本压缩与贪心算法" class="headerlink" title="2 文本压缩与贪心算法"></a>2 文本压缩与贪心算法</h2><p><strong>文本压缩（text compression）问题：</strong>将给定字符串 <strong>X</strong> 压缩为一个更小的二进制字符串 <strong>Y</strong> 。</p><p><strong>霍夫曼编码（Huffman encoding）</strong>是一种变长编码方式，可以得到字符串的最优二进制表示，其思路如下：</p><ul><li>对字符串中的每个字符 <code>c</code> ，计算其出现频率 <code>f(c)</code></li><li>用长度较短的码表示高频字符，所有码字均不为其他码字的前缀</li><li>使用一棵最优编码树决定编码方式</li></ul><h3 id="2-1-霍夫曼编码-Huffman"><a href="#2-1-霍夫曼编码-Huffman" class="headerlink" title="2.1 霍夫曼编码 Huffman"></a>2.1 霍夫曼编码 Huffman</h3><p><strong>前缀码（prefix code）：</strong>所有码字均不为其他码字的前缀的一种编码方式</p><ul><li>一棵编码树（encoding tree）表示一种前缀码</li><li>每个叶子节点存储一个被编码的字符</li><li>字符的码字由从根节点到该字符所在的叶子节点的路径确定（向左即编码为0，向右即编码为1）</li></ul><p><strong>霍夫曼编码</strong>步骤：</p><ul><li>将所有字符用一棵单节点的树表示，节点权重为字符出现的频率</li><li>在每一步，将两棵权重最小的树合并为一棵，计算其权重</li><li>重复以上步骤直到只有一棵树</li></ul><p>霍夫曼编码得到的编码树为<strong>霍夫曼树（Huffman tree）</strong>。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748682890546.png" alt="霍夫曼编码树示例"></p><h3 id="2-2-Huffman-代码实现和算法分析"><a href="#2-2-Huffman-代码实现和算法分析" class="headerlink" title="2.2 Huffman 代码实现和算法分析"></a>2.2 Huffman 代码实现和算法分析</h3><h4 id="2-2-1-代码实现"><a href="#2-2-1-代码实现" class="headerlink" title="2.2.1 代码实现"></a>2.2.1 代码实现</h4><p>霍夫曼编码可以使用堆实现的优先级队列 <a href="code13_2_huffman.py">code13_2_huffman.py</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> HeapPriorityQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;霍夫曼树节点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, freq, char=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        实例化一个霍夫曼树的节点</span></span><br><span class="line"><span class="string">        :param freq: 字符的频率</span></span><br><span class="line"><span class="string">        :param char: 字符, 当为内部节点时不存储字符</span></span><br><span class="line"><span class="string">        :param left: 左子节点</span></span><br><span class="line"><span class="string">        :param right: 右子节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.freq = freq  <span class="comment"># 字符的频率</span></span><br><span class="line">        <span class="variable language_">self</span>.char = char  <span class="comment"># 叶子节点存储字符</span></span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;定义比较方法, 用于自下而上建堆时比较频率&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.freq &lt; other.freq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanTree</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;霍夫曼编码树类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输入 text 进行霍夫曼树编码</span></span><br><span class="line"><span class="string">        :param text: 被压缩的文本</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.text = text</span><br><span class="line">        <span class="variable language_">self</span>.freq_map = <span class="variable language_">self</span>._build_freq_map(text)  <span class="comment"># 频率表</span></span><br><span class="line">        <span class="variable language_">self</span>.root = <span class="variable language_">self</span>._build_tree()  <span class="comment"># 建立编码树</span></span><br><span class="line">        <span class="variable language_">self</span>.code_map = <span class="variable language_">self</span>._generate_codes()  <span class="comment"># 获取编码结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_build_freq_map</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据文本建立每个字符的频率表</span></span><br><span class="line"><span class="string">        :param text: 被压缩的文本</span></span><br><span class="line"><span class="string">        :return: 每个字符的频率表 &#123;char: freq&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        freq_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> text:</span><br><span class="line">            freq_map[ch] = freq_map.get(ch, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> freq_map</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_build_tree</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;利用基于堆实现的优先级队列 HeapPriorityQueue 建立 Huffman 编码树&quot;&quot;&quot;</span></span><br><span class="line">        pq = HeapPriorityQueue()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 为每一个字符创建节点</span></span><br><span class="line">        <span class="keyword">for</span> ch, freq <span class="keyword">in</span> <span class="variable language_">self</span>.freq_map.items():</span><br><span class="line">            pq.add(freq, HuffmanNode(freq, ch))  <span class="comment"># key = freq</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 自底向上合并节点</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(pq) &gt; <span class="number">1</span>:</span><br><span class="line">            f1, n1 = pq.remove_min()</span><br><span class="line">            f2, n2 = pq.remove_min()</span><br><span class="line">            merged = HuffmanNode(f1 + f2, left=n1, right=n2)</span><br><span class="line">            pq.add(merged.freq, merged)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pq.remove_min()[<span class="number">1</span>]  <span class="comment"># 返回根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_generate_codes</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成编码结果 &#123;char: encoding code&#125;&quot;&quot;&quot;</span></span><br><span class="line">        code_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_generate</span>(<span class="params">node, code</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;根据左右子树不断更新编码&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> node.char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                code_map[node.char] = code</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            _generate(node.left, code + <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            _generate(node.right, code + <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        _generate(<span class="variable language_">self</span>.root, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 从根节点开始遍历</span></span><br><span class="line">        <span class="keyword">return</span> code_map</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;编码: text 编码后的结果&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="variable language_">self</span>.code_map[ch] <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="variable language_">self</span>.text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self, encoded_text</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;解码: encoded_text 解码后的结果&quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        node = <span class="variable language_">self</span>.root</span><br><span class="line">        <span class="keyword">for</span> bit <span class="keyword">in</span> encoded_text:</span><br><span class="line">            node = node.left <span class="keyword">if</span> bit == <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> node.right</span><br><span class="line">            <span class="keyword">if</span> node.char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                result.append(node.char)</span><br><span class="line">                node = <span class="variable language_">self</span>.root</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    text = <span class="string">&quot;this is an example of a huffman tree&quot;</span></span><br><span class="line"></span><br><span class="line">    huff_tree = HuffmanTree(text)</span><br><span class="line">    encoded = huff_tree.encode()</span><br><span class="line">    decoded = huff_tree.decode(encoded)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nCode Map:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(huff_tree.code_map)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nEncoded Code:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(encoded)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nDecoded Text:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(decoded)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Code Map:</span><br><span class="line">&#123;<span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;000&#x27;</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;00100&#x27;</span>, <span class="string">&#x27;p&#x27;</span>: <span class="string">&#x27;00101&#x27;</span>, <span class="string">&#x27;i&#x27;</span>: <span class="string">&#x27;0011&#x27;</span>, <span class="string">&#x27;n&#x27;</span>: <span class="string">&#x27;0100&#x27;</span>, <span class="string">&#x27;o&#x27;</span>: <span class="string">&#x27;01010&#x27;</span>, <span class="string">&#x27;u&#x27;</span>: <span class="string">&#x27;01011&#x27;</span>, <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;011&#x27;</span>, <span class="string">&#x27;t&#x27;</span>: <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;m&#x27;</span>: <span class="string">&#x27;1001&#x27;</span>, <span class="string">&#x27;h&#x27;</span>: <span class="string">&#x27;1010&#x27;</span>, <span class="string">&#x27;s&#x27;</span>: <span class="string">&#x27;1011&#x27;</span>, <span class="string">&#x27;r&#x27;</span>: <span class="string">&#x27;11000&#x27;</span>, <span class="string">&#x27;l&#x27;</span>: <span class="string">&#x27;11001&#x27;</span>, <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;1101&#x27;</span>, <span class="string">&#x27; &#x27;</span>: <span class="string">&#x27;111&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Encoded Code:</span><br><span class="line"><span class="number">100010100011101111100111011111011010011100000100011100100101110010001110101011011110111111010010111101110110010110100111100011000000000</span></span><br><span class="line"></span><br><span class="line">Decoded Text:</span><br><span class="line">this <span class="keyword">is</span> an example of a huffman tree</span><br></pre></td></tr></table></figure><h4 id="2-2-2-算法分析"><a href="#2-2-2-算法分析" class="headerlink" title="2.2.2 算法分析"></a>2.2.2 算法分析</h4><p>长度为 n 的文本，不同字符（包括各种特殊字符）的个数为 d ，构造最优编码/霍夫曼编码的时间复杂度为：</p><ul><li>统计字符出现频率：O(n)</li><li>优先级队列的插入与删除： O(d log d)</li></ul><p>总运行时间： <strong>O(n + d log d)</strong></p><h4 id="2-2-3-Huffman-编码最优性证明"><a href="#2-2-3-Huffman-编码最优性证明" class="headerlink" title="2.2.3 Huffman 编码最优性证明"></a>2.2.3 Huffman 编码最优性证明</h4><p><strong>Proof</strong> 原始论文 <a href="https://ieeexplore.ieee.org/abstract/document/4051119">A Method for the Construction of Minimum-Redundancy Codes (David A, Huffman, et al. 1952)</a> 。</p><p>对于字符集合 $C = { c_1,\ c_2,\ \cdots,\ c_n }$ 每个字符出现的频率为 $f(c_i)$ 。构造编码树 $T$ 是一个二叉树，叶子节点代表字符，路径代表 0 (Left) or 1 (Right) 。则字符 $c_i$ 的编码长度 $l(c_i)$ 为 $c_i$ 所在节点在 $T$ 中的深度。那么对这个字符集 $C$ 的编码树 $T$ 带来的期望编码总长为：</p><script type="math/tex; mode=display">L(T) = \sum\limits_{i=1}^n f(c_i) \cdot l(c_i)</script><p>现在要证明：Huffman 编码树 $T_H$ 就是最优的，它使得 $L(T_H)$ 最小。</p><p><strong>引理 1</strong> 在最优编码树 $T^*$ 中，频率最低的 2 个字符 $x$ 和 $y$ 一定位于最深的节点中，且他们拥有相同的父节点。</p><p><u>证明 引理 1</u> 若字符 $z$ 比 $x$ 更深，但 $x$ 频率更低 $f(x) \leq f(z)$ 。那么交换 $x$ 和 $z$ 的节点位置，总编码期望长度 $L(T)$ 不增（因为频率低的字符变得更深）。这与 $L(T^*)$ 最优矛盾。同理，存在 2 个频率最低的字符 $x,\ y$ 那么他们肯定在同一层，否则将频率低的换到更深，长度不增，矛盾。$\square$</p><p><strong>引理 2</strong> 将频率最低的两个字符 $x$ 和 $y$ 合并为一个新字符 $z$ ，新问题与原问题等价。</p><p><u>证明 引理 2</u> 对于新问题：字符集 $C’ = C - {x,\ y} + {z}$ 编码树为 $T’$ 。得到的最优解为 $T’^<em>$ 和最小编码长度 $L(T’^</em>)$ 。由引理 1 知，$x,\ y$ 位于同一节点下的兄弟节点，则有 $l(z) = l(x) + 1 = l(y) + 1$ ，而显然 $z$ 的频率是二者的和 $f(z) = f(x) + f(y)$ 。所以有：</p><script type="math/tex; mode=display">L(T) = L(T') + (l(z) - l(x)) \cdot f(z) = L(T') + f(x) + f(y)</script><p>所以，当新问题 $B(T’^<em>)$ 最优时，原问题 $B(T^</em>)$ 也最优。$\square$</p><p>下面通过归纳法证明：Huffman 编码树 $T_H$ 是最优的</p><ol><li>当 $|C| = n = 2$ 时，显然 $T_H$ 最优，只有 $0$ 和 $1$ 两种情况；</li><li>假设 $|C| = n$ 时，$T_H$ 是最优的；</li><li>对于 $|C| = n + 1$ 时，我们选择频率最低的 2 个字符 $x$ 和 $y$ ，合并为 $z$ 组成新问题，此时字符集 $C’$ 满足 $|C’| = n$ ，通过归纳假设，新问题是最优的。</li></ol><p>再由引理 2 知，新问题与原问题等价，故 Huffman 编码树 $T_H$ 是最优的。$\square$</p><h3 id="2-3-贪心算法"><a href="#2-3-贪心算法" class="headerlink" title="2.3 贪心算法"></a>2.3 贪心算法</h3><p><strong>贪心算法（greedy method）</strong>是一种通用算法设计范式，贪心算法在问题有贪心选择（greedy-choice）性质时表现最佳。</p><ul><li>贪心选择性质：全局最优解可以通过解决一系列局部最优问题来解决</li></ul><p>贪心算法常按以下步骤设计：</p><ul><li>将最优化问题转化为这样的形式：对其作出一次选择后，只剩下一个子问题需要求解</li><li>证明作出贪心选择后，原问题总是存在最优解，即贪心选择是安全的</li><li>证明作出贪心选择后，剩余子问题的最优解与贪心选择组合即可得到原问题的最优解</li></ul><p><strong>贪心算法例：</strong></p><ul><li>Prim 算法</li><li>Kruskal 算法</li><li>Dijkstra 算法</li><li>Huffman 编码</li></ul>]]></content>
    
    
    <summary type="html">本章介绍常见的文本处理算法：模式匹配问题的 KMP 算法、文本压缩的 Huffman 编码树。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>图与图算法（2）：最短路径、传递闭包和最小生成树</title>
    <link href="https://blog.iskage.online/posts/160be13a.html"/>
    <id>https://blog.iskage.online/posts/160be13a.html</id>
    <published>2025-05-24T00:16:00.000Z</published>
    <updated>2025-05-24T10:10:02.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图与图算法（2）：最短路径、传递闭包和最小生成树"><a href="#图与图算法（2）：最短路径、传递闭包和最小生成树" class="headerlink" title="图与图算法（2）：最短路径、传递闭包和最小生成树"></a>图与图算法（2）：最短路径、传递闭包和最小生成树</h1><p>上一章 <a href="https://zhuanlan.zhihu.com/p/1903566835674244067">图与图算法（1）：图与图的遍历算法</a> 介绍了图和图的遍历（DFS 和 BFS）。本章介绍图算法：最短路径（Dijkstra 算法）、传递闭包（Floyd-Warshall 算法）和最小生成树（Prim-Jarnik 算法和 Kruskal 算法）。</p><p>根据教材《数据结构与算法 Python 实现》整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><h2 id="1-最短路径问题-Dijkstra-算法"><a href="#1-最短路径问题-Dijkstra-算法" class="headerlink" title="1 最短路径问题 Dijkstra 算法"></a>1 最短路径问题 Dijkstra 算法</h2><h3 id="1-1-加权图与最短路径"><a href="#1-1-加权图与最短路径" class="headerlink" title="1.1 加权图与最短路径"></a>1.1 加权图与最短路径</h3><p><strong>加权图（weighted graph）</strong>中，每条边均有一个与之关联的数值，即权重。</p><p><strong>最短路径（shortest path）</strong>：给定两个顶点 u 和 v，寻找两个顶点间的最短路径。路径的长度定义为构成路径的所有边的权重之和。</p><ul><li>最短路径的一条子路径也是最短路径</li><li>从一个顶点出发到其他所有顶点的最短路径构成一个树</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746629327788.png" alt="从某个点（点 PVD）出发的最短路径构成的树"></p><h3 id="1-2-Dijkstra-算法"><a href="#1-2-Dijkstra-算法" class="headerlink" title="1.2 Dijkstra 算法"></a>1.2 Dijkstra 算法</h3><p><strong>Dijkstra 算法：</strong>计算从一个源顶点 s 出发到其他所有顶点的最短路径，因此又被称为一种单源最短路径算法。</p><p><strong>Dijkstra 算法的假设：</strong></p><ul><li>图为连通图</li><li>图的所有边权重非负</li></ul><p><strong>算法思路：</strong></p><ul><li>我们生成一个由顶点构成的“云”，此云中一开始只有源顶点 s，最后包含所有顶点</li><li>对于每个顶点 v，我们定义并记录其标签值 <code>d(v)</code> ，此标签值表示从 s 经过“云”中的顶点最终到达顶点 v 的最短路径值</li><li>算法的每一步执行如下操作：找到标签值 <code>d(u)</code> 最小的顶点 u，并将其加入“云”中；更新与 u 相邻且不在“云”中的顶点的标签值，这一步又称为边的松弛操作（relaxation）</li></ul><p><strong>边的松弛操作：</strong></p><p>考虑满足如下条件的一条边 <code>e = (u, z)</code> ：u 是刚刚被加入到“云”中的一个顶点； z 不在“云”中。对边 e 的松弛操作如下：</p><script type="math/tex; mode=display">d(z) \leftarrow \min\left\{\ d(z),\ d(u) + weight(e)\ \right\}</script><p>例如下面的例子：原来的 <code>d(z) = 75</code> 大于 <code>d(u) + weight(e) = 50 + 10 = 60</code> 故更新点 z 的标签值 <code>d(z) = 60</code> 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746629902591.png" alt="边的松弛操作"></p><p><strong>伪代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Algorithm ShortestPath(G, s):</span><br><span class="line">    [Input]: A weighted graph G <span class="keyword">with</span> nonnegative edge weights, <span class="keyword">and</span> a distinguished vertex s of G</span><br><span class="line">    [Output]: The length of a shortest path <span class="keyword">from</span> s to v <span class="keyword">for</span> each vertex v of G</span><br><span class="line">    [Algorithm]:</span><br><span class="line">    <span class="comment"># 初始化, 点 s 标签为 0, 其他点均为正无穷</span></span><br><span class="line">    Initialize D[s] = <span class="number">0</span> <span class="keyword">and</span> D[v] = +inf <span class="keyword">for</span> each vertex v != s.</span><br><span class="line"></span><br><span class="line">    Q = PriorityQueue()  <span class="comment"># 优先级队列: key = D[v] value = v 且先包含所有点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> Q.isEmpty() do</span><br><span class="line">    <span class="comment"># Q 是“非云” Q.remove(u) 相当于点 u 入云</span></span><br><span class="line">        u = value returned by Q.remove_min()  <span class="comment"># 挑出最小的 D[u]</span></span><br><span class="line">        <span class="keyword">for</span> each vertex v adjacent to u such that v <span class="keyword">is</span> <span class="keyword">in</span> Q do  <span class="comment"># 所有与 u 相邻的 v</span></span><br><span class="line">            <span class="keyword">if</span> D[u] + w(u, v) &lt; D[v] then</span><br><span class="line">            D[v] = D[u] + w(u, v)</span><br><span class="line">            Change to D[v] the key of vertex v <span class="keyword">in</span> Q  <span class="comment"># 边松弛操作, 改变 D[v]</span></span><br><span class="line">    <span class="keyword">return</span> the label of each vertex v</span><br></pre></td></tr></table></figure><p><strong>完整的 Dijkstra 算法案例：</strong></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746630488031.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746630568055.png" alt=""></p><h3 id="1-3-Dijkstra-算法-Python-实现"><a href="#1-3-Dijkstra-算法-Python-实现" class="headerlink" title="1.3 Dijkstra 算法 Python 实现"></a>1.3 Dijkstra 算法 Python 实现</h3><p>需要使用上一章构建的图的类 <code>Graph</code> 代码见 <a href="https://github.com/isKage/dsa-notes/blob/main/lec12_graph/utils/graph.py">graph.py</a> ；同时需要辅助结构 <code>AdaptableHeapPriorityQueue</code> 类，它是一个实现了定位器的优先级队列（基于堆实现），即可以在 O(1) 的时间内快速查找到节点的位置。代码见 <a href="https://github.com/isKage/dsa-notes/blob/main/lec12_graph/utils/adaptable_heap_priority_queue.py">adaptable_heap_priority_queue.py</a> 。</p><p>特别地，<code>d = &#123;&#125;</code> 用于存储标签/最短路，<code>d[v]</code> ；<code>cloud = &#123;&#125;</code> 用于最终结果 <code>&#123;v: d[v]&#125;</code> 在云内的标签 (即最终最短路)；<code>pqlocator = &#123;&#125;</code>  用于存储点 v 在优先级队列中的位置 <code>&#123;v: loc of v in pq&#125;</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> Graph, AdaptableHeapPriorityQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shortest_path_lengths</span>(<span class="params">g: Graph, src: Graph.Vertex</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最短路径问题: Dijkstra 算法</span></span><br><span class="line"><span class="string">    :param g: 图 Graph 类</span></span><br><span class="line"><span class="string">    :param src: 源点 Graph.Vertex 类</span></span><br><span class="line"><span class="string">    :return: 源点 src 到所有可达点 v 的最短距离 dict: &#123;v: d[v]&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    d = &#123;&#125;  <span class="comment"># 记录所有点的标签 d[v]</span></span><br><span class="line">    cloud = &#123;&#125;  <span class="comment"># 存储最终结果 &#123;v: d[v]&#125; 在云内的标签 (即最终最短路)</span></span><br><span class="line">    pq = AdaptableHeapPriorityQueue()  <span class="comment"># 优先级队列, 能够 O(1) 找到特定点, 值 (点 v)为 locator 字典的键</span></span><br><span class="line">    pqlocator = &#123;&#125;  <span class="comment"># 存储点 v 在优先级队列中的位置 &#123;v: loc of v in pq&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化所有点 v 的标签 d[v]</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g.vertices():</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> src:</span><br><span class="line">            d[v] = <span class="number">0</span>  <span class="comment"># 源点为 0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[v] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 暂时记为正无穷大</span></span><br><span class="line">        pqlocator[v] = pq.add(d[v], v)  <span class="comment"># (最短路 d[v], 点 v) 放入优先级队列, 同时记录位置在 pqlocator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> pq.is_empty():</span><br><span class="line">        key, u = pq.remove_min()  <span class="comment"># 取出云外最小路 min d[v] out of cloud</span></span><br><span class="line">        cloud[u] = key  <span class="comment"># 放入云内 cloud[u] = key 因为存的时候 key = d[u]</span></span><br><span class="line">        <span class="keyword">del</span> pqlocator[u]  <span class="comment"># pqlocator 删去点 u 在优先级队列里的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u):  <span class="comment"># 所有通向点 u 的边 e</span></span><br><span class="line">            v = e.opposite(u)  <span class="comment"># 对面的点 v</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> cloud:  <span class="comment"># 若 v 不在云里</span></span><br><span class="line">                wgt = e.element()  <span class="comment"># 边权重</span></span><br><span class="line">                <span class="keyword">if</span> d[u] + wgt &lt; d[v]:  <span class="comment"># 比较</span></span><br><span class="line">                    d[v] = d[u] + wgt  <span class="comment"># 更新为最小值</span></span><br><span class="line">                    pq.update(pqlocator[v], d[v], v)  <span class="comment"># 同时更新优先级队列里的 (d[v], v)</span></span><br><span class="line">    <span class="keyword">return</span> cloud</span><br></pre></td></tr></table></figure><p>测试：以上图为例，可求得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Graph(directed=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    A = g.insert_vertex(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    B = g.insert_vertex(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    C = g.insert_vertex(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    D = g.insert_vertex(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    E = g.insert_vertex(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    F = g.insert_vertex(<span class="string">&quot;F&quot;</span>)</span><br><span class="line"></span><br><span class="line">    AB = g.insert_edge(A, B, <span class="number">8</span>)</span><br><span class="line">    AC = g.insert_edge(A, C, <span class="number">2</span>)</span><br><span class="line">    AD = g.insert_edge(A, D, <span class="number">4</span>)</span><br><span class="line">    BC = g.insert_edge(B, C, <span class="number">7</span>)</span><br><span class="line">    CD = g.insert_edge(C, D, <span class="number">1</span>)</span><br><span class="line">    BE = g.insert_edge(B, E, <span class="number">2</span>)</span><br><span class="line">    CE = g.insert_edge(C, E, <span class="number">3</span>)</span><br><span class="line">    CF = g.insert_edge(C, F, <span class="number">9</span>)</span><br><span class="line">    DF = g.insert_edge(D, F, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    toA_shortest_path = shortest_path_lengths(g=g, src=A)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> toA_shortest_path:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;From Vertex <span class="subst">&#123;k.element()&#125;</span>: <span class="subst">&#123;toA_shortest_path[k]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From Vertex A: <span class="number">0</span></span><br><span class="line">From Vertex C: <span class="number">2</span></span><br><span class="line">From Vertex D: <span class="number">3</span></span><br><span class="line">From Vertex E: <span class="number">5</span></span><br><span class="line">From Vertex B: <span class="number">7</span></span><br><span class="line">From Vertex F: <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="1-4-Dijkstra-算法性能分析和正确性"><a href="#1-4-Dijkstra-算法性能分析和正确性" class="headerlink" title="1.4 Dijkstra 算法性能分析和正确性"></a>1.4 Dijkstra 算法性能分析和正确性</h3><h4 id="1-4-1-性能分析"><a href="#1-4-1-性能分析" class="headerlink" title="1.4.1 性能分析"></a>1.4.1 性能分析</h4><p>图操作：</p><ul><li>访问了所有顶点</li><li>并在将顶点放入“云”这一步访问了所有的边</li></ul><p>标签操作：</p><ul><li>查询/修改一个顶点 z 的标签 O(deg(z)) 次</li><li>我们可以在 O(1) 的时间内完成这一工作</li></ul><p>优先级队列操作：</p><ul><li>每个顶点被插入、移出刚好一次：如使用堆实现，则需要 O(log n) 的时间，所有顶点则需要 $O(n \log n)$ ；如使用无序列表实现，则需要 O(n) 的时间，所有顶点则需要 $O(n^2)$ 。</li><li>优先级队列中一个顶点 z 的键最多被修改 deg(z) 次；如使用堆实现，则需要 O(log n) 的时间；如使用无序列表实现，则需要 O(1) 的时间。因为 $\sum_z \deg (z) = O(m)$ ，故使用堆则总共需要 $O(m \log n)$ ，使用无序列表则总共需要 $O(m)$ 。</li></ul><p>当图使用邻接表或邻接映射实现时，Dijkstra 算法的运行时间为：</p><ul><li>优先级队列堆实现：$O((n+m)\log n)$ 。</li><li>优先级队列无序列表：$O(n^2+m)$ ，图是简单图则可以简化为 $O(n^2)$ 。</li></ul><p>不难发现，当处理稀疏图时，即 m 较小时，使用堆实现更为方便。</p><h4 id="1-4-2-正确性"><a href="#1-4-2-正确性" class="headerlink" title="1.4.2 正确性"></a>1.4.2 正确性</h4><p>Dijkstra算法是一个典型的<strong>贪心算法（greedy algorithm）</strong>，每次都将通过“云”到达的最近的顶点加入“云”。这一算法的正确性依赖于<strong>边权重的非负性</strong>。我们可以使用反证法证明 Dijkstra 算法的正确性：</p><p><strong>证明：</strong>假设 Dijkstra 算法并未找到所有的最短路径，设 z 是第一个出错的顶点</p><p>设此时从 s 到 z 的最短路径上的第一个不在“云”中的顶点为 y，且其前一个顶点为 x</p><p>由于此时的 D[y] 已经在 x 被加入“云”时访问被修改过了，因此 D[y] 即为 s 到 y 最短路径的长度 d(s, y) 。但此时 y 未被考虑加入“云”，因此有：</p><script type="math/tex; mode=display">D[z] \leq D[y] = d(s, y) \leq d(s, y) + d(y, z) = d(s, z)</script><p>这与 z 的假设（z 未找到最短路）矛盾！</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746759393409.png" alt="反证法图示"></p><h4 id="1-4-3-负权重的反例"><a href="#1-4-3-负权重的反例" class="headerlink" title="1.4.3 负权重的反例"></a>1.4.3 负权重的反例</h4><p>如出现负权重边，则当负权重边在较晚时刻被加入到“云”中时，云中与之相连的顶点及其可达的其他顶点的最短路径均可能发生变化。</p><p>例：右图中 A 为源顶点，C 的最短路径为 1 ，但将 F 加入“云”时已经有“云”中的 d(C) = 5 ，但从 A - D - F - C 可以得到更短路 d(C) = 9 - 8 = 1 ，矛盾。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746759588311.png" alt="负权重"></p><h2 id="2-传递闭包问题-Floyd-Warshall-算法"><a href="#2-传递闭包问题-Floyd-Warshall-算法" class="headerlink" title="2 传递闭包问题 Floyd-Warshall 算法"></a>2 传递闭包问题 Floyd-Warshall 算法</h2><p>Dijkstra 算法要求边的权重非负，且只能求从单个源顶点出发的所有最短路径。是否有求所有顶点对之间最短路径，且不要求边的权重非负的算法？</p><p><strong>Floyd-Warshall 算法：</strong></p><ul><li>可用于计算传递闭包</li><li>可用于计算所有顶点对间的最短路径</li><li>没有边权重非负的要求（但要求不能有一个权重和为负的环，否则可以一直在这个环上循环，直至负无穷）</li></ul><h3 id="2-1-传递闭包"><a href="#2-1-传递闭包" class="headerlink" title="2.1 传递闭包"></a>2.1 传递闭包</h3><p>给定一个有向图 $\overrightarrow{G}$ ，其<strong>传递闭包（transitive closure）</strong> $\overrightarrow{G}^*$ 是满足下列条件的有向图：</p><ul><li>二者顶点数相同</li><li>在 $\overrightarrow{G}$ 中从点 u 到 v 的路，与 $\overrightarrow{G}^*$ 的边 (u, v) 即从 u 出射，入射到 v 的边等价（包括原始图的 (u, v) 边）</li></ul><p>传递闭包为有向图提供了关于顶点间可达性的信息。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746760539259.png" alt="传递闭包"></p><h3 id="2-2-计算传递闭包"><a href="#2-2-计算传递闭包" class="headerlink" title="2.2 计算传递闭包"></a>2.2 计算传递闭包</h3><p>最简单的想法：在每个顶点处执行 DFS ，然后对 DFS 路径上的每一个点都直接连边（若没有直接连边）。总共 n 个点，DFS 的时间复杂度为 O(n + m) 所以这个方法的时间复杂度为 <strong>O(n(n + m))</strong> 。</p><p>另一种基于动态规划的想法：<strong>Floyd-Warshall 算法</strong></p><h3 id="2-3-Floyd-Warshall-算法"><a href="#2-3-Floyd-Warshall-算法" class="headerlink" title="2.3 Floyd-Warshall 算法"></a>2.3 Floyd-Warshall 算法</h3><p>Floyd-Warshall 算法的基本思路：</p><ul><li>将所有顶点从 1 到 n 进行编号</li><li>在第 k 步，考虑仅经过顶点 1, 2 …, k 的所有路径</li></ul><p>算法的第 k 步示意图：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746760761512.png" alt="Floyd-Warshall 算法第 k 步"></p><p>具体思路：</p><ul><li>将顶点编号为 $v_1,\ v_2,\ \cdots,\ v_n$ ，按顺序计算 $G_0,\ G_1,\ \cdots,\ G_n$ ：</li><li>初始化 $G_0 \leftarrow G$ </li><li>在第 k 步，使用 $G_{k-1}$ 计算 $G_k$ ：如果 $G$ 从点 $v_i$ 到点 $v_j$ 有只经过 ${v_1, v_2,\ \cdots,\ v_k }$ 的路径，则在 $G_k$ 中添加一条有向边 $(v_i,\ v_j)$ </li><li>最终有 $G^* \leftarrow G_n$ </li></ul><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Algorithm FloydWarshall(G)</span><br><span class="line">    [Input]: digraph G</span><br><span class="line">    [Output]: transitive closure G* of G</span><br><span class="line">[Algorithm]:</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> v = G.vertices()  <span class="comment"># 所有顶点</span></span><br><span class="line">    <span class="comment"># 标记所有点</span></span><br><span class="line">        denote v <span class="keyword">as</span> vi</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   G&#123;<span class="number">0</span>&#125; = G  <span class="comment"># 初始 G&#123;0&#125;</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to n do</span><br><span class="line">        G&#123;k&#125; = G&#123;k−<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span> to n (i != k) do  <span class="comment"># vi</span></span><br><span class="line">            <span class="keyword">for</span> j = <span class="number">1</span> to n (j != i, k) do  <span class="comment"># vi</span></span><br><span class="line">            <span class="comment"># G&#123;k-1&#125; 中 vi vk 相邻, vk vj 相邻</span></span><br><span class="line">                <span class="keyword">if</span> G&#123;k−<span class="number">1</span>&#125;.areAdjacent(vi, vk) <span class="keyword">and</span> G&#123;k−<span class="number">1</span>&#125;.areAdjacent(vk, vj)</span><br><span class="line">                <span class="comment"># 但 G&#123;k&#125; 中 vi vj 不相邻</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> G&#123;k&#125;.areAdjacent(vi, vj) </span><br><span class="line">                    <span class="comment"># 则在 G&#123;k&#125; 中连边 vi vj</span></span><br><span class="line">                        G&#123;k&#125;.insertDirectedEdge(vi, vj, k)</span><br><span class="line">    <span class="keyword">return</span> G&#123;n&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746761710050.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746761741081.png" alt=""></p><h3 id="2-4-Floyd-Warshall-算法-Python-实现"><a href="#2-4-Floyd-Warshall-算法-Python-实现" class="headerlink" title="2.4 Floyd-Warshall 算法 Python 实现"></a>2.4 Floyd-Warshall 算法 Python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">floyd_warshall</span>(<span class="params">g: Graph</span>) -&gt; Graph:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回图 g 的闭包</span></span><br><span class="line"><span class="string">    :param g: 图 Graph 类</span></span><br><span class="line"><span class="string">    :return: 图 g 的闭包 Graph 类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    closure = deepcopy(g)  <span class="comment"># 深度拷贝图 g</span></span><br><span class="line">    verts = <span class="built_in">list</span>(closure.vertices())  <span class="comment"># 图 g 的所有顶点</span></span><br><span class="line">    n = <span class="built_in">len</span>(verts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 中间顶点 k</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 起始顶点 i</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若 i k 相邻 (i, k) is not None</span></span><br><span class="line">            <span class="keyword">if</span> i != k <span class="keyword">and</span> closure.get_edge(verts[i], verts[k]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 终点顶点 j</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 若 k j 相邻 (k, j) is not None</span></span><br><span class="line">                    <span class="keyword">if</span> i != j != k <span class="keyword">and</span> closure.get_edge(verts[k], verts[j]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 此时 (i, k) (k, j) 均连通, 若 i j 不连通则连边 (i, j)</span></span><br><span class="line">                        <span class="keyword">if</span> closure.get_edge(verts[i], verts[j]) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                            closure.insert_edge(verts[i], verts[j])</span><br><span class="line">    <span class="keyword">return</span> closure</span><br></pre></td></tr></table></figure><p>测试：图 G 有 A B C 三点，有边 (A -&gt; B) (B -&gt; C) 则闭包增加边 (A -&gt; C)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Graph(directed=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    A = g.insert_vertex(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    B = g.insert_vertex(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    C = g.insert_vertex(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    AB = g.insert_edge(A, B)  <span class="comment"># A 到 B</span></span><br><span class="line">    BC = g.insert_edge(B, C)  <span class="comment"># B 到 C</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Before Floyd Warshall: Edge has <span class="subst">&#123;g.edge_count()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 闭包结果应该为: A-&gt;B B-&gt;C 得到新的边 A-&gt;C</span></span><br><span class="line">    closure = floyd_warshall(g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;After Floyd Warshall: Edge has <span class="subst">&#123;closure.edge_count()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before Floyd Warshall: Edge has <span class="number">2</span></span><br><span class="line">After Floyd Warshall: Edge has <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2-5-Floyd-Warshall-算法的性能"><a href="#2-5-Floyd-Warshall-算法的性能" class="headerlink" title="2.5 Floyd-Warshall 算法的性能"></a>2.5 Floyd-Warshall 算法的性能</h3><p><strong>结论：</strong>假设可在 O(1) 时间内完成判断顶点间是否有边的操作（如使用邻接矩阵），则算法时间复杂度为 $O(n^3)$ 。</p><p><strong>Floyd-Warshall 算法 vs 每个点深度优先 DFS 算法</strong></p><p>Floyd-Warshall 算法的时间复杂度为 $O(n^3)$ ，而逐个点使用 DFS 算法实现传递闭包的时间复杂度为 $O(n(n+m))$ 。</p><ul><li>Floyd-Warshall 算法在图是稠密的或使用邻接矩阵表示图时与重复调用 DFS 的渐进性能相同</li><li>Floyd-Warshall 算法更容易实现，且实践中运行非常快，尤其当图使用邻接矩阵实现时</li><li>图是稀疏的且使用图的邻接表或邻接映射实现时，DFS 有更好的性能</li><li>Floyd-Warshall 算法通常使用图的邻接矩阵实现，在这一实现下其效率最高</li></ul><h3 id="2-6-最短路-Floyd-Warshall-算法"><a href="#2-6-最短路-Floyd-Warshall-算法" class="headerlink" title="2.6 最短路 Floyd-Warshall 算法"></a>2.6 最短路 Floyd-Warshall 算法</h3><p>Floyd-Warshall 算法还可用于求图中<strong>所有顶点间的最短路径（all-pairs shortest path）</strong>，并且对边权重的非负性没有任何要求：</p><ul><li>对第 k 步的操作进行修改即可：</li></ul><script type="math/tex; mode=display">d_k(v_i,\ v_j) = \min \{ d_{k-1}(v_i,\ v_j),\ d_{k-1}(v_i,\ v_k) + d_{k-1}(v_k,\ v_j) \}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">floyd_warshall_shortest_path</span>(<span class="params">g: Graph</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 Floyd-Warshall 算法计算图中所有顶点对的最短路径距离</span></span><br><span class="line"><span class="string">    :param g: 图 Graph 类</span></span><br><span class="line"><span class="string">    :return: 返回一个字典 &#123;u: &#123;v: distance&#125;&#125; </span></span><br><span class="line"><span class="string">    其中 distance 是 u 到 v 的最短距离</span></span><br><span class="line"><span class="string">    如果 u 和 v 之间不可达 distance = math.inf </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    verts = <span class="built_in">list</span>(g.vertices())  <span class="comment"># 获取所有顶点</span></span><br><span class="line">    n = <span class="built_in">len</span>(verts)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化距离字典, 格式为 dist[u][v] = distance</span></span><br><span class="line">    dist = &#123;u: &#123;v: math.inf <span class="keyword">for</span> v <span class="keyword">in</span> verts&#125; <span class="keyword">for</span> u <span class="keyword">in</span> verts&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置对角线为 0</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> verts:</span><br><span class="line">        dist[u][u] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化直接相连的边</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> verts:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> verts:</span><br><span class="line">            edge = g.get_edge(u, v)</span><br><span class="line">            <span class="keyword">if</span> edge <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                dist[u][v] = edge.element()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Floyd-Warshall 算法</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> verts:  <span class="comment"># 中间点 k</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> verts:  <span class="comment"># 起点 u</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> verts:  <span class="comment"># 终点 v</span></span><br><span class="line">                <span class="comment"># 如果经过 k 的路径更短，则更新</span></span><br><span class="line">                <span class="keyword">if</span> dist[u][k] + dist[k][v] &lt; dist[u][v]:</span><br><span class="line">                    dist[u][v] = dist[u][k] + dist[k][v]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_shortest_paths</span>(<span class="params">g: Graph, shortest_path_dict: <span class="built_in">dict</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印结果的函数&quot;&quot;&quot;</span></span><br><span class="line">    verts = <span class="built_in">list</span>(g.vertices())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是无向图，按 start &lt; end 输出，避免重复</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> g.is_directed():</span><br><span class="line">        verts_sorted = <span class="built_in">sorted</span>(verts, key=<span class="keyword">lambda</span> x: x.element())  <span class="comment"># 按顶点名称排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(verts_sorted)):</span><br><span class="line">            start = verts_sorted[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(verts_sorted)):</span><br><span class="line">                end = verts_sorted[j]</span><br><span class="line">                distance = shortest_path_dict[start][end]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;start.element()&#125;</span> -&gt; <span class="subst">&#123;end.element()&#125;</span>: &quot;</span></span><br><span class="line">                      <span class="string">f&quot;<span class="subst">&#123;distance <span class="keyword">if</span> distance != math.inf <span class="keyword">else</span> <span class="string">&#x27;No Path&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是有向图，输出所有可能的 start -&gt; end</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> verts:</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> verts:</span><br><span class="line">                <span class="keyword">if</span> start != end:  <span class="comment"># 避免输出自己到自己的情况</span></span><br><span class="line">                    distance = shortest_path_dict[start][end]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;start.element()&#125;</span> → <span class="subst">&#123;end.element()&#125;</span>: &quot;</span></span><br><span class="line">                          <span class="string">f&quot;<span class="subst">&#123;distance <span class="keyword">if</span> distance != math.inf <span class="keyword">else</span> <span class="string">&#x27;No Path&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Shortest Path&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    g = Graph(directed=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    A = g.insert_vertex(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    B = g.insert_vertex(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    C = g.insert_vertex(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    D = g.insert_vertex(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    E = g.insert_vertex(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    F = g.insert_vertex(<span class="string">&quot;F&quot;</span>)</span><br><span class="line"></span><br><span class="line">    AB = g.insert_edge(A, B, <span class="number">8</span>)</span><br><span class="line">    AC = g.insert_edge(A, C, <span class="number">2</span>)</span><br><span class="line">    AD = g.insert_edge(A, D, <span class="number">4</span>)</span><br><span class="line">    BC = g.insert_edge(B, C, <span class="number">7</span>)</span><br><span class="line">    CD = g.insert_edge(C, D, <span class="number">1</span>)</span><br><span class="line">    BE = g.insert_edge(B, E, <span class="number">2</span>)</span><br><span class="line">    CE = g.insert_edge(C, E, <span class="number">3</span>)</span><br><span class="line">    CF = g.insert_edge(C, F, <span class="number">9</span>)</span><br><span class="line">    DF = g.insert_edge(D, F, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    shortest_path_dict = floyd_warshall_shortest_path(g=g)</span><br><span class="line">    print_shortest_paths(g, shortest_path_dict)  <span class="comment"># 输出结果</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=============== Shortest Path ===============</span><br><span class="line">A → B: <span class="number">8</span></span><br><span class="line">A → C: <span class="number">2</span></span><br><span class="line">A → D: <span class="number">3</span></span><br><span class="line">A → E: <span class="number">5</span></span><br><span class="line">A → F: <span class="number">8</span></span><br><span class="line">B → A: No Path</span><br><span class="line">B → C: <span class="number">7</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="3-最小生成树-Prim-Jarnik-amp-Kruskal"><a href="#3-最小生成树-Prim-Jarnik-amp-Kruskal" class="headerlink" title="3 最小生成树 Prim-Jarnik &amp; Kruskal"></a>3 最小生成树 Prim-Jarnik &amp; Kruskal</h2><h3 id="3-1-最小生成树"><a href="#3-1-最小生成树" class="headerlink" title="3.1 最小生成树"></a>3.1 最小生成树</h3><p>生成子图（spanning graph）：图 G 的生成子图包含其所有顶点。生成树（spanning tree）：为树的生成子图</p><p><strong>最小生成树（minimum spanning tree/MST）</strong>：加权图的总权重最小的生成树</p><p><strong>最小生成树的性质：</strong></p><ul><li><strong>环性质（cycle property ）：</strong>令 T 为加权图 G 的一棵最小生成树，令 e 为图 G 中不属于 T 的边，且令 e 与 T 形成的环为 C 。则有：对环上的每一条边 f 均有 $weight(f) \leq weight(e)$ 。</li></ul><p>因为如果可以找到一条边使得 $weight(f) &gt; weight(e)$ 则用边 e 取代 f 即可得到一棵总权重更小的生成树。</p><ul><li><strong>分割性质（partition property）：</strong>考虑将 G 的所有顶点分为两个集合 U 和 V 的一个分割。令 e 为连接这两部分顶点集合的权重最小的边。则有：存在一棵包含边 e 的 G 的最小生成树。</li></ul><p>考虑 G 的一棵最小生成树 T ，如果 T 不包含 e，考虑由 e 和 T 构成的环 C，及 T 中连接 U 和 V 的边 f 。由最小生成树的环性质可得：$weight(f) \leq weight(e)$ ，$weight(f) = weight(e)$ 。用 e 替代 f 即可得到另一棵最小生成树。</p><p>有两种解决最小生成树问题的经典算法，均为贪心算法：</p><ul><li>Prim-Jarnik 算法</li><li>Kruskal 算法</li></ul><h3 id="3-2-Prim-Jarnik-算法"><a href="#3-2-Prim-Jarnik-算法" class="headerlink" title="3.2 Prim-Jarnik 算法"></a>3.2 Prim-Jarnik 算法</h3><p>Prim 算法从一个“根”顶点 s 出发，以构建“云”的方式逐步形成一棵最小生成树，其思想与 Dijkstra 算法类似。</p><ul><li><p>对每个顶点 v，其标签 d(v) 存储该顶点与“云”间相连的边的最小权重。</p></li><li><p>将“云”外标签值 d(u) 最小的顶点 u 加入“云”</p></li><li>更新与 u 相邻的顶点的标签值</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748076899672.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748076956667.png" alt=""></p><h4 id="3-2-1-算法实现"><a href="#3-2-1-算法实现" class="headerlink" title="3.2.1 算法实现"></a>3.2.1 算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MST_PrimJarnik</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;最小生成树 返回边列表&quot;&quot;&quot;</span></span><br><span class="line">    d = &#123;&#125;  <span class="comment"># d[v] is bound on distance to tree</span></span><br><span class="line">    tree = []  <span class="comment"># 最小生成树的边序列</span></span><br><span class="line">    pq = AdaptableHeapPriorityQueue()  <span class="comment"># d[v] maps to value (v, e=(u,v))</span></span><br><span class="line">    pqlocator = &#123;&#125;  <span class="comment"># &#123;Vertex: pq&#x27;s locator&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化标签 d[v]</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g.vertices():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">0</span>:  <span class="comment"># d 空, 没有节点</span></span><br><span class="line">            d[v] = <span class="number">0</span>  <span class="comment"># 则设置一个起点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[v] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># positive infinity</span></span><br><span class="line">        pqlocator[v] = pq.add(d[v], (v, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> pq.is_empty():</span><br><span class="line">        key, value = pq.remove_min()</span><br><span class="line">        u, edge = value  <span class="comment"># unpack tuple from pq</span></span><br><span class="line">        <span class="keyword">del</span> pqlocator[u]  <span class="comment"># u is no longer in pq</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> edge <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tree.append(edge)  <span class="comment"># add edge to tree</span></span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> g.incident_edges(u):</span><br><span class="line">            v = link.opposite(u)  <span class="comment"># 寻找邻点</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> pqlocator:  <span class="comment"># thus v not yet in tree</span></span><br><span class="line">                <span class="comment"># see if edge (u,v) better connects v to the growing tree</span></span><br><span class="line">                wgt = link.element()</span><br><span class="line">                <span class="keyword">if</span> wgt &lt; d[v]:  <span class="comment"># better edge to v?</span></span><br><span class="line">                    d[v] = wgt  <span class="comment"># update the distance</span></span><br><span class="line">                    pq.update(pqlocator[v], d[v], (v, link))  <span class="comment"># update the pq</span></span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h4 id="3-2-2-性能分析"><a href="#3-2-2-性能分析" class="headerlink" title="3.2.2 性能分析"></a>3.2.2 性能分析</h4><p>图操作：我们访问了所有顶点，并在将顶点放入“云”这一步访问了所有的边</p><p>标签操作：我们查询/修改一个顶点 z 的标签 O(deg(z)) 次，我们可以在 O(1) 的时间内完成这一工作</p><p>优先级队列操作：</p><ul><li>每个顶点被插入、移出刚好一次；如使用堆实现，则需要 O(log n) 的时间，如使用无序列表实现，则需要 O(n) 的时间。</li><li>优先级队列中一个顶点 z 的键最多被修改 deg(z) 次；如使用堆实现，则需要 O(log n) 的时间，如使用无序列表实现，则需要 O(1) 的时间</li></ul><p>当图使用邻接表或邻接映射实现时，Prim-Jarnik 算法的运行时间为：</p><ul><li>优先级队列堆实现：<strong>O((n + m) log n)</strong> ，由于图是连通的，可简化为 <strong>O(m log n)</strong></li><li>优先级队列无序列表实现：<strong>O(n^2)</strong></li></ul><h3 id="3-3-Kruskal-算法"><a href="#3-3-Kruskal-算法" class="headerlink" title="3.3 Kruskal 算法"></a>3.3 Kruskal 算法</h3><p>与 Prim 算法不同，Kruskal 算法将顶点分为很多个集合后进行顶点集群的合并</p><ul><li>一开始，所有顶点都在一个只有自己的集群中</li><li>算法执行过程中，对每个集群均记录其最小生成树</li><li>算法执行的每一步为将“离得最近”的两个集群合并，并得到合并集群的最小生成树</li><li>与 Prim 算法类似，采用一个优先级队列存储集群之外的边，其键为权重值，值为边</li><li>最终，算法将得到一个集群及其上的最小生成树，即原图的最小生成树</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748078020250.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748078079252.png" alt=""></p><h4 id="3-3-1-Kruskal-算法的辅助数据结构"><a href="#3-3-1-Kruskal-算法的辅助数据结构" class="headerlink" title="3.3.1 Kruskal 算法的辅助数据结构"></a>3.3.1 Kruskal 算法的辅助数据结构</h4><p>与 Prim 算法类似，Kruskal 算法中使用一个优先级队列在每一步选择权重最小的边。Kruskal 算法还需要进行<strong>集群</strong>的管理，这需要一种新的可以存储并管理一系列不相交集合的数据结构 <code>Partition</code> 类，此数据结构需要提供如下功能：</p><ul><li><code>makeSet(u)</code> ：创建一个只有 u 的集合</li><li><code>find(u)</code> ：返回包含 u 的集合的位置</li><li><code>union(A, B)</code> ：将 A 和 B 合并</li></ul><p><strong>Partition</strong> 类的实现：</p><p>我们使用序列来实现 Partition 结构：</p><ul><li>集合的每个元素均存储指向集合位置的指针</li><li><code>make_group(u)</code> 需要 O(1) 的时间</li><li><code>find(u)</code> 需要 O(1) 的时间</li><li><code>union(A,B)</code> 操作中，我们将表示较小集合的序列的元素移动到较大的集合中，并更新这些元素的指针。 <code>union(A,B)</code> 需要 O(min{|A|, |B|}) 的时间</li><li>每当元素被从一个集合移动到另一个集合中时，集合的大小都至少会翻倍，因此每个元素最多被移动 log n 次</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748079072331.png" alt=""></p><p>也可以使用树结构来实现，见 <a href="utils/partition.py">partition.py</a>  。</p><h4 id="3-3-2-Partition-的代码实现"><a href="#3-3-2-Partition-的代码实现" class="headerlink" title="3.3.2 Partition 的代码实现"></a>3.3.2 Partition 的代码实现</h4><p>基于序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListPartition</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于序列实现的Partition结构（每个组用序列表示）&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Position</span>:</span><br><span class="line">        __slots__ = <span class="string">&#x27;_element&#x27;</span>, <span class="string">&#x27;_group&#x27;</span>, <span class="string">&#x27;_size&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, element, group</span>):</span><br><span class="line">            <span class="variable language_">self</span>._element = element</span><br><span class="line">            <span class="variable language_">self</span>._group = group  <span class="comment"># 所属组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">element</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._element</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;Position(<span class="subst">&#123;self._element&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._groups = []  <span class="comment"># 存储所有组的的群组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_group</span>(<span class="params">self, e</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建新组, 包含元素 e&quot;&quot;&quot;</span></span><br><span class="line">        new_group = [<span class="literal">None</span>]  <span class="comment"># 新组</span></span><br><span class="line">        p = <span class="variable language_">self</span>.Position(e, new_group)  <span class="comment"># 创建 Position 类</span></span><br><span class="line">        new_group[<span class="number">0</span>] = p  <span class="comment"># 加入组中</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._groups.append(new_group)  <span class="comment"># 新组加入到 ListPartition 群组中</span></span><br><span class="line">        <span class="keyword">return</span> new_group[<span class="number">0</span>]  <span class="comment"># return Position(e)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Position 类 p 所属的组&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> p._group</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;合并包含 p 和 q 的两个组&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 包含 p 和 q 的两个组</span></span><br><span class="line">        group_p = p._group</span><br><span class="line">        group_q = q._group</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> group_p <span class="keyword">is</span> <span class="keyword">not</span> group_q:  <span class="comment"># 如果不在同一组, 则合并</span></span><br><span class="line">            <span class="comment"># 找到更小的组</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(group_p) &lt; <span class="built_in">len</span>(group_q):</span><br><span class="line">                smaller, larger = group_p, group_q</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                smaller, larger = group_q, group_p</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更小组的 Position 指向合并后的大组</span></span><br><span class="line">            <span class="keyword">for</span> pos <span class="keyword">in</span> smaller:</span><br><span class="line">                pos._group = larger</span><br><span class="line">            <span class="comment"># 加入大组</span></span><br><span class="line">            larger.extend(smaller)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从群组 ——groups 中移除较小的组</span></span><br><span class="line">            <span class="variable language_">self</span>._groups.remove(smaller)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;ListPartition(<span class="subst">&#123;self._groups&#125;</span>)&quot;</span></span><br></pre></td></tr></table></figure><p>基于树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Partition</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Position</span>:</span><br><span class="line">        __slots__ = <span class="string">&#x27;_container&#x27;</span>, <span class="string">&#x27;_element&#x27;</span>, <span class="string">&#x27;_size&#x27;</span>, <span class="string">&#x27;_parent&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, container, e</span>):</span><br><span class="line">            <span class="variable language_">self</span>._container = container</span><br><span class="line">            <span class="variable language_">self</span>._element = e</span><br><span class="line">            <span class="variable language_">self</span>._size = <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>._parent = <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">element</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._element</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_group</span>(<span class="params">self, e</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.Position(<span class="variable language_">self</span>, e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">if</span> p._parent != p:</span><br><span class="line">            p._parent = <span class="variable language_">self</span>.find(p._parent)</span><br><span class="line">        <span class="keyword">return</span> p._parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        a = <span class="variable language_">self</span>.find(p)</span><br><span class="line">        b = <span class="variable language_">self</span>.find(q)</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> b:</span><br><span class="line">            <span class="keyword">if</span> a._size &gt; b._size:</span><br><span class="line">                b._parent = a</span><br><span class="line">                a._size += b._size</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a._parent = b</span><br><span class="line">                b._size += a._size</span><br></pre></td></tr></table></figure><h4 id="3-3-3-Kruskal-算法的实现"><a href="#3-3-3-Kruskal-算法的实现" class="headerlink" title="3.3.3 Kruskal 算法的实现"></a>3.3.3 Kruskal 算法的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MST_Kruskal</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;最小生成树 Kruskal 算法&quot;&quot;&quot;</span></span><br><span class="line">    tree = []  <span class="comment"># 最小生成树的边序列</span></span><br><span class="line">    pq = HeapPriorityQueue()  <span class="comment"># 优先级队列 key = edge&#x27;s weight</span></span><br><span class="line">    forest = Partition()  <span class="comment"># 集群管理</span></span><br><span class="line">    position = &#123;&#125;  <span class="comment"># &#123;Vertex: Partition&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g.vertices():</span><br><span class="line">        position[v] = forest.make_group(v)  <span class="comment"># 每个点建群</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> g.edges():</span><br><span class="line">        pq.add(e.element(), e)  <span class="comment"># 存储所有边 key = edge&#x27;s weight</span></span><br><span class="line"></span><br><span class="line">    size = g.vertex_count()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(tree) != size - <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> pq.is_empty():</span><br><span class="line">        weight, edge = pq.remove_min()  <span class="comment"># 最小权重边</span></span><br><span class="line">        u, v = edge.endpoints()</span><br><span class="line">        a = forest.find(position[u])</span><br><span class="line">        b = forest.find(position[v])</span><br><span class="line">        <span class="keyword">if</span> a != b:</span><br><span class="line">            tree.append(edge)  <span class="comment"># 边加入最小生成树</span></span><br><span class="line">            forest.union(a, b)  <span class="comment"># 合并群</span></span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h4 id="3-3-4-性能分析"><a href="#3-3-4-性能分析" class="headerlink" title="3.3.4 性能分析"></a>3.3.4 性能分析</h4><p>使用这样的 Partition 结构存储集群，则：</p><ul><li>集群的合并使用 union 方法</li><li>寻找集群的位置使用 find 方法</li></ul><p>Kruskal 算法的运行时间为 <strong>O((n + m) log n)</strong></p><ul><li>优先级队列操作运行时间：<strong>O(m log n)</strong></li><li>集群定位、合并操作运行时间：<strong>O(n log n)</strong></li></ul><h2 id="4-拓扑排序"><a href="#4-拓扑排序" class="headerlink" title="4 拓扑排序"></a>4 拓扑排序</h2><h3 id="4-1-拓扑排序与有向非循环图-DAG"><a href="#4-1-拓扑排序与有向非循环图-DAG" class="headerlink" title="4.1 拓扑排序与有向非循环图 DAG"></a>4.1 拓扑排序与有向非循环图 DAG</h3><p><strong>拓扑排序</strong>：使得有向图 G 的任何有向路径以增加的顺序遍历顶点（为顶点编号）。同一幅图可能有多个拓扑排序。</p><p>拓扑排序可以用来检查图是否为<strong>有向非循环图 DAG</strong> （即没有有向环），当拓扑排序没有包含所有点时，说明这个图存在有向循环/圈。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748080212879.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748080232195.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1748080244812.png" alt=""></p><h3 id="4-1-拓扑排序代码实现"><a href="#4-1-拓扑排序代码实现" class="headerlink" title="4.1 拓扑排序代码实现"></a>4.1 拓扑排序代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拓扑排序, 检查是否为 DAG 有向非循环图 (即没有有向环)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">topological_sort</span>(<span class="params">g: Graph</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回拓扑排序, 即不存在排序在后的点指向排序在前的点</span></span><br><span class="line"><span class="string">    若存在有向环, 则返回的序列不包含图中所有点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    topo = []  <span class="comment"># 按拓扑顺序存储 Vertex 类</span></span><br><span class="line">    ready = []  <span class="comment"># 存储满足条件的点, 即不再影响图的成环性 (栈 stack)</span></span><br><span class="line">    incount = &#123;&#125;  <span class="comment"># 存储每个点的入度, 实时更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 获取所有点, 记录 &#123;Vertex: in-degree&#125;</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> g.vertices():</span><br><span class="line">        incount[u] = g.degree(u, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> incount[u] == <span class="number">0</span>:  <span class="comment"># 入度为 0 可以作为起始点, 不受其他影响</span></span><br><span class="line">            ready.append(u)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 对每个点处理, 清空 ready</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(ready) &gt; <span class="number">0</span>:</span><br><span class="line">        u = ready.pop()</span><br><span class="line">        topo.append(u)</span><br><span class="line">        <span class="comment"># 获取 u 的邻接点</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u):</span><br><span class="line">            v = e.opposite(u)</span><br><span class="line">            incount[v] -= <span class="number">1</span>  <span class="comment"># 前一点已加入 topo 结果, 则 v 度减 1</span></span><br><span class="line">            <span class="keyword">if</span> incount[v] == <span class="number">0</span>:</span><br><span class="line">                ready.append(v)  <span class="comment"># 直到此时 v 也成为了&quot;起点&quot;</span></span><br><span class="line">    <span class="keyword">return</span> topo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exist_loop</span>(<span class="params">g: Graph</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;存在有向环&quot;&quot;&quot;</span></span><br><span class="line">    topo = topological_sort(g)  <span class="comment"># [Vertex 类, ]</span></span><br><span class="line">    all_nodes = g.vertices()  <span class="comment"># Vertex 类的迭代器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(topo) != <span class="built_in">len</span>(all_nodes)</span><br></pre></td></tr></table></figure><p>针对上面图示的例子，进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Graph(directed=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    V = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>]:</span><br><span class="line">        V[node] = g.insert_vertex(node)</span><br><span class="line"></span><br><span class="line">    AC = g.insert_edge(V[<span class="string">&quot;A&quot;</span>], V[<span class="string">&quot;B&quot;</span>])</span><br><span class="line">    AD = g.insert_edge(V[<span class="string">&quot;A&quot;</span>], V[<span class="string">&quot;D&quot;</span>])</span><br><span class="line"></span><br><span class="line">    BD = g.insert_edge(V[<span class="string">&quot;B&quot;</span>], V[<span class="string">&quot;D&quot;</span>])</span><br><span class="line">    BF = g.insert_edge(V[<span class="string">&quot;B&quot;</span>], V[<span class="string">&quot;F&quot;</span>])</span><br><span class="line"></span><br><span class="line">    CD = g.insert_edge(V[<span class="string">&quot;C&quot;</span>], V[<span class="string">&quot;D&quot;</span>])</span><br><span class="line">    CE = g.insert_edge(V[<span class="string">&quot;C&quot;</span>], V[<span class="string">&quot;E&quot;</span>])</span><br><span class="line">    CH = g.insert_edge(V[<span class="string">&quot;C&quot;</span>], V[<span class="string">&quot;H&quot;</span>])</span><br><span class="line"></span><br><span class="line">    DF = g.insert_edge(V[<span class="string">&quot;D&quot;</span>], V[<span class="string">&quot;F&quot;</span>])</span><br><span class="line"></span><br><span class="line">    EG = g.insert_edge(V[<span class="string">&quot;E&quot;</span>], V[<span class="string">&quot;G&quot;</span>])</span><br><span class="line"></span><br><span class="line">    FG = g.insert_edge(V[<span class="string">&quot;F&quot;</span>], V[<span class="string">&quot;G&quot;</span>])</span><br><span class="line">    FH = g.insert_edge(V[<span class="string">&quot;F&quot;</span>], V[<span class="string">&quot;H&quot;</span>])</span><br><span class="line"></span><br><span class="line">    GH = g.insert_edge(V[<span class="string">&quot;G&quot;</span>], V[<span class="string">&quot;H&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># HF = g.insert_edge(V[&quot;H&quot;], V[&quot;F&quot;])  # 成环</span></span><br><span class="line"></span><br><span class="line">    X = g.insert_vertex(<span class="string">&quot;X&quot;</span>)</span><br><span class="line"></span><br><span class="line">    topo_sort = topological_sort(g)</span><br><span class="line">    loop_or_not = exist_loop(g)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(topo_sort)</span><br><span class="line">    <span class="built_in">print</span>(loop_or_not)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Vertex(element=X), Vertex(element=C), Vertex(element=E), Vertex(element=A), Vertex(element=B), Vertex(element=D), Vertex(element=F), Vertex(element=G), Vertex(element=H)]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>拓扑排序的时间复杂度为 <strong>O(n+m)</strong> 。</p>]]></content>
    
    
    <summary type="html">本章介绍图算法：最短路径（Dijkstra 算法）、传递闭包（Floyd-Warshall 算法）、最小生成树（Prim-Jarnik 算法和 Kruskal 算法）和拓扑排序。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>图与图算法（1）：图与图的遍历算法</title>
    <link href="https://blog.iskage.online/posts/a3ce696.html"/>
    <id>https://blog.iskage.online/posts/a3ce696.html</id>
    <published>2025-05-07T00:16:00.000Z</published>
    <updated>2025-05-24T10:10:02.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图与图算法（1）：图与图的遍历算法"><a href="#图与图算法（1）：图与图的遍历算法" class="headerlink" title="图与图算法（1）：图与图的遍历算法"></a>图与图算法（1）：图与图的遍历算法</h1><p>本章介绍图的基本概念、图的存储结构（边列表、邻接表、邻接矩阵）、图的抽象数据类型 ADT 与 Python 实现。图的遍历算法：深度优先搜索 DFS 、广度优先搜索 BFS 及它们的应用。</p><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><hr><h2 id="1-图"><a href="#1-图" class="headerlink" title="1 图"></a>1 图</h2><h3 id="1-1-图"><a href="#1-1-图" class="headerlink" title="1.1 图"></a>1.1 图</h3><p>图 <strong>G</strong> 可由一个二元组 <strong>(V, E)</strong> 表示，其中：</p><ul><li><strong>V</strong> 中的元素为图中的顶点（vertex），被称为顶点集</li><li><strong>E</strong> 中的元素为由一对 V 中的顶点表示的图中的边（edge），被称为边集</li></ul><p>例如下面的图， 顶点表示机场，存储机场的代码，边表示机场间的航线，存储航线里程。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746595341486.png" alt="图的例子"></p><h3 id="1-2-图的相关概念"><a href="#1-2-图的相关概念" class="headerlink" title="1.2 图的相关概念"></a>1.2 图的相关概念</h3><p><strong>有向 &amp; 无向</strong></p><p>有向边：有序的顶点对 (u, v) 表示从 u 到 v 的边</p><p>无向边：无序的顶点对 (u, v)</p><p>有向图（directed graph/digraph）：所有边均为有向边</p><p>无向图（undirected graph）：所有边均为无向边</p><p><strong>点 &amp; 边 &amp; 相邻</strong></p><p>端点（end vertices/endpoints）：被一条边连接的两个顶点</p><p>边入射（incident）到顶点：一条边连接一个顶点时</p><p>相邻顶点（adjacent vertices）：两个顶点间有边相连</p><p><strong>度 &amp; 特殊的边</strong></p><p>顶点 v 的度（degree）：deg(v) 为入射到顶点的边数</p><p>平行边（parallel edges）/ 多重边（multiple edges）：即连接两个顶点的不同边</p><p>自环（self-loop）：即连接两个同样顶点的边</p><p>简单图（simple graph）：没有平行边和自环的图</p><p><strong>起点终点 &amp; 出度入度</strong></p><p>如果一个有向边从顶点 u 指向顶点 v ，则：</p><ul><li>u 为其起点（origin）， v 为其终点（destination）</li><li>这条边是从顶点 u 出射的边（outgoing edge），且是入射到顶点 v 的边（incoming edge）</li></ul><p>在有向图中：</p><ul><li>顶点 v 的出度（out-degree）是从其出射的边数，记为 outdeg(v)</li><li>顶点 v 的入度（in-degree）是入射到其的边数，记为 indeg(v)</li></ul><p><strong>路径</strong></p><p>路径（path）：路径为顶点与边交替的序列，从一个顶点开始，到另一顶点结束，每条边连接前后两个顶点</p><p>简单路径（simple path）：所有顶点和边均不相同的路径</p><p><strong>环</strong></p><p>环/回路（cycle）：环为开始、结束于同一顶点的路径</p><p>简单环（simple cycle）：简单环为除开始点和结束点之外的顶点、边均不相同的环</p><p><strong>完全图</strong></p><p>无向完全图（undirected complete graph）：图中每个顶点和其余任一顶点都恰有一条边相连</p><p>有向完全图（directed complete graph）：图中每个顶点都恰有一条有向边连向其余任一顶点</p><p>拥有边数很少（小于 n log n）的图为稀疏图（sparse graph），否则为稠密图（dense graph）</p><p><strong>子图 &amp; 生成子图</strong></p><p>图 G = (V, E) 的子图（subgraph）即其顶点集和边集各为 V 和 E 的子集的图</p><p>图 G 的生成子图（spanning subgraph）为含有图 G 所有顶点的子图</p><p>如果从一个顶点 u 有一条路径通向另一个顶点 v，则称 v 是从 u 可达的（reachable）</p><p><strong>可达 &amp; 连通</strong></p><p>如果从一个顶点 u 有一条路径通向另一个顶点 v，则称 <em>v</em> 是从 u 可达的（reachable）</p><p>如图中任两个顶点间有路径，则图为连通的（connected）</p><p>图 G 的最大连通子图称为其连通分支或连通分量（connected component）</p><p>有向图中任意两点间互相可达，则图为强连通的（strongly connected）</p><p><strong>树 &amp; 森林 &amp; 生成树</strong></p><p>树（tree）T 是一个图，且：</p><ul><li>T 是连通的</li><li>T 中没有环</li></ul><p>森林（forest）是一个没有环的图：</p><ul><li>森林的连通分支为树</li></ul><p>图 G 的生成树（spanning tree）是图 G 的生成子图，且其为树</p><ul><li>生成树不是唯一的，除非图本身为树 </li></ul><h3 id="1-3-图的性质"><a href="#1-3-图的性质" class="headerlink" title="1.3 图的性质"></a>1.3 图的性质</h3><p><strong>命题：如果 G 是有 m 条边和顶点集 V 的图，那么</strong></p><script type="math/tex; mode=display">\sum\limits_{v\ \in\ V} \deg(v) = 2m</script><p>证明：一旦通过其端点 u 和通过其端点 v 一次，在上述求和计算中边 (u, v) 就计算了两次。因此，边对顶点度数的总贡献数是边数目的两倍。</p><p><strong>命题：如果 G 是有 m 条边和顶点集 V 的有向图，那么</strong></p><script type="math/tex; mode=display">\sum\limits_{v\ \in\ V} \deg^+(v) = \sum\limits_{v\ \in\ V} \deg^-(v) = m</script><p>即图的所有点的出度的和等于入度的和。</p><p>证明：在有向图中，边 (u, v) 对它的起点 u 的出度贡献了一个单元，对终点 v 的入度贡献了一个单元。因此，边对顶点出度的总贡献和边的数目相等，入度也是一样的。</p><p><strong>命题：给定 G 为具有 n 个顶点和 m 条边的简单图。如果 G 是无向的，那么 $m \leq n(n-1)/2$ ，如果 G 是有向的，那么 $m \leq n(n-1)$ 。</strong></p><p>证明：假设 G 是无向的。因为没有两条边可以有相同的端点并且没有自循环，在这种情况下 G 的顶点的最大度是 n-1 。因此，通过 $\sum<em>{v\ \in\ V} \deg(v) = 2m$，有 $2m \leq n(n-1)$ 。现在假设G是有向的。因为没有两条边具有相同的起点和终点，并且没有自循环，在这种情况下 G 的顶点的最大入度是 n-1 。因此，通过 $\sum</em>{v\ \in\ V} \deg^-(v) = m \leq n(n-1)$ 。</p><p><strong>命题：树、森林和连通图的简单属性。</strong>给定 G 是有 n 个顶点和 m 条边的无向图：</p><ul><li>如果 G 是连通的，那么 $m \geq n-1$ 。</li><li>如果 G 是一棵树，那么 $m = n-1$ 。</li><li>如果 G 是森林，那么 $m \leq n-1$ 。</li></ul><h3 id="1-4-图的抽象数据类型"><a href="#1-4-图的抽象数据类型" class="headerlink" title="1.4 图的抽象数据类型"></a>1.4 图的抽象数据类型</h3><h4 id="1-4-1-点和边的-ADT"><a href="#1-4-1-点和边的-ADT" class="headerlink" title="1.4.1 点和边的 ADT"></a>1.4.1 点和边的 ADT</h4><p>顶点 ADT 需要支持一个方法 <code>element()</code> 以返回存储在顶点的元素</p><p>边 ADT 存储一个与边相关的元素，并支持一个方法 <code>element()</code> 以返回该元素。另外，边 ADT 还应支持以下两个方法：</p><ul><li><code>endpoints()</code> ：返回一个元组 (u, v)，其中 u 为顶点，v 为终点（无向图的方向任意）</li><li><code>opposite(v)</code> ：假设顶点 v 为边的一个端点，返回另一个端点</li></ul><h4 id="1-4-2-图的-ADT"><a href="#1-4-2-图的-ADT" class="headerlink" title="1.4.2 图的 ADT"></a>1.4.2 图的 ADT</h4><p>图 ADT 应支持以下方法：</p><ul><li><code>vertex_count()</code> ：返回图中顶点的数目</li><li><code>vertices()</code> ：返回图中所有顶点的迭代器</li><li><code>edge_count()</code>：返回图中边的数目</li><li><code>edges()</code>：返回图中所有边的迭代器</li><li><code>get_edge(u, v)</code>：返回从顶点 u 到顶点 v 的边，如不存在则返回 None</li><li><code>degree(v, out = True)</code>：对于无向图，返回入射顶点 v 的边数；对于有向图，根据 out 的值返回出射或入射的边数</li><li><code>incident_edges(v, out = True)</code> ：返回入射顶点 v 的边的迭代器。对于有向图，根据 out 的值返回出射或入射的边的迭代器</li><li><code>insert_vertex(x = None)</code>：创建并返回一个存储元素 x 的新顶点</li><li><code>insert_edge(u, v, x = None)</code> ：创建并返回一个从顶点 u 到顶点 v 的存储元素 x 的新边</li><li><code>remove_vertex(v)</code> ：删除顶点 v 和其所有入射边</li><li><code>remove_edge(e)</code> ：删除边 e</li></ul><h3 id="1-5-图的存储结构"><a href="#1-5-图的存储结构" class="headerlink" title="1.5 图的存储结构"></a>1.5 图的存储结构</h3><p>图的存储结构有很多种，如：</p><ul><li>边列表</li><li>邻接表（邻接映射）</li><li>邻接矩阵</li></ul><h4 id="1-5-1-边列表"><a href="#1-5-1-边列表" class="headerlink" title="1.5.1 边列表"></a>1.5.1 边列表</h4><p><strong>边列表（edge list）</strong>分别用两个列表存放顶点和边，这两个列表可使用双向链表存储</p><ul><li><p>顶点对象：存储顶点元素的引用；存储其在顶点序列中位置的引用</p></li><li><p>边对象：存储边元素的引用；存储起点、终点的引用；存储其在边序列中位置的引用</p></li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746607405226.png" alt="边列表的图存储"></p><h4 id="1-5-2-邻接表"><a href="#1-5-2-邻接表" class="headerlink" title="1.5.2 邻接表"></a>1.5.2 邻接表</h4><p><strong>邻接表（adjacency list）</strong>使用列表存放顶点，并在每一顶点处存放其入射的边</p><ul><li>顶点处存储的入射序列</li><li>顶点 v 处存储一个二级结构 I(v) 的引用，该结构存储其入射的所有边的引用</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746607864997.png" alt="邻接表的图存储"></p><h4 id="1-5-3-邻接矩阵"><a href="#1-5-3-邻接矩阵" class="headerlink" title="1.5.3 邻接矩阵"></a>1.5.3 邻接矩阵</h4><p><strong>邻接矩阵（adjacency matrix）</strong>采用一个矩阵来存储边：</p><ul><li>如图有 n 个顶点，则建立一个 n x n 的矩阵，矩阵每一行/列代表一个顶点</li><li>矩阵中任一位置存储对应的两个顶点间的边的引用，如两个顶点间无边则存储 None</li><li>忽略边信息时，可以用 1 表示存在边， 0 表示不存在边</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746607974500.png" alt="邻接矩阵的图存储"></p><h4 id="1-5-4-图的存储结构的性能"><a href="#1-5-4-图的存储结构的性能" class="headerlink" title="1.5.4 图的存储结构的性能"></a>1.5.4 图的存储结构的性能</h4><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746608043733.png" alt="不同图的存储结构的空间复杂度比较"></p><h3 id="1-6-Python-实现"><a href="#1-6-Python-实现" class="headerlink" title="1.6 Python 实现"></a>1.6 Python 实现</h3><p>我们使用邻接列表的一种改进方式，即<strong>邻接映射（adjacency map）</strong></p><ul><li>与邻接表不同的是，我们使用字典来存储二级结构 <code>I(v)</code> ：字典中存储的键为该边的另一端点，值为边。这样的改进使得 <code>get_edge()</code> 方法的时间复杂度降为 O(1) 。</li><li>一级列表 <code>V</code> 使用一个顶级字典 <code>D</code> 来实现，其将每个顶点 <code>v</code> 映射到其入射边的二级结构 <code>I(v)</code> 。通过遍历字典 <code>D</code> 的所有键即可访问所有顶点。</li><li>顶点不需要存储指向其在 <code>D</code> 中的引用，因为它可以在 O(1) 的时间内被找到。</li><li>原邻接表的运行时间变为期望运行时间</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746608304065.png" alt="邻接映射的图示"></p><p><strong>Python 实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用邻接矩阵实现图结构&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------------------- nested Vertex class -------------------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vertex</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;顶点集合&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_element&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Use Graph&#x27;s insert_vertex(x). 创建点&quot;&quot;&quot;</span></span><br><span class="line">            <span class="variable language_">self</span>._element = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">element</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;返回顶点存储的值&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._element</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):  <span class="comment"># hash 函数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="built_in">id</span>(<span class="variable language_">self</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------------------- nested Edge class -------------------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;边集合&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_origin&#x27;</span>, <span class="string">&#x27;_destination&#x27;</span>, <span class="string">&#x27;_element&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, u, v, x</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Use Graph&#x27;s insert_edge(u,v,x). 创建边&quot;&quot;&quot;</span></span><br><span class="line">            <span class="variable language_">self</span>._origin = u</span><br><span class="line">            <span class="variable language_">self</span>._destination = v</span><br><span class="line">            <span class="variable language_">self</span>._element = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">endpoints</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;返回 (u, v): u 为出射点, v 为入射点&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">self</span>._origin, <span class="variable language_">self</span>._destination)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">opposite</span>(<span class="params">self, v</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;返回在当前边上 v 的邻接点&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._destination <span class="keyword">if</span> v <span class="keyword">is</span> <span class="variable language_">self</span>._origin <span class="keyword">else</span> <span class="variable language_">self</span>._origin</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">element</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;返回边上的数据, 例如权重&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._element</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):  <span class="comment"># hash 函数</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;对边哈希, 方便后面二级结构 I(v) 以字典形式存储&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="variable language_">self</span>._origin, <span class="variable language_">self</span>._destination))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------------------- Graph methods -------------------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, directed=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化一个图, 默认为无向图</span></span><br><span class="line"><span class="string">        :param directed: True 则为有向图</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._outgoing = &#123;&#125;  <span class="comment"># 出射点集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 有向图时入射点集合为新, 否则指向出射点集</span></span><br><span class="line">        <span class="variable language_">self</span>._incoming = &#123;&#125; <span class="keyword">if</span> directed <span class="keyword">else</span> <span class="variable language_">self</span>._outgoing</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_directed</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断是否有方向&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._incoming <span class="keyword">is</span> <span class="keyword">not</span> <span class="variable language_">self</span>._outgoing</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_vertex</span>(<span class="params">self, x=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;插入点, 返回点 Vertex 类&quot;&quot;&quot;</span></span><br><span class="line">        v = <span class="variable language_">self</span>.Vertex(x)  <span class="comment"># 创建新点, 值为 x</span></span><br><span class="line">        <span class="variable language_">self</span>._outgoing[v] = &#123;&#125;  <span class="comment"># 放入点集, 此时无边, 故为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_directed():</span><br><span class="line">            <span class="variable language_">self</span>._incoming[v] = &#123;&#125;  <span class="comment"># 如果有方向, 则入射点集也要加入</span></span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_edge</span>(<span class="params">self, u, v, x=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;插入边, 注意, 需要 u v 均为点 Vertex 类&quot;&quot;&quot;</span></span><br><span class="line">        e = <span class="variable language_">self</span>.Edge(u, v, x)  <span class="comment"># 从 u 到 v, 值为 x</span></span><br><span class="line">        <span class="variable language_">self</span>._outgoing[u][v] = e  <span class="comment"># 将边放入二级结构 I(u)</span></span><br><span class="line">        <span class="variable language_">self</span>._incoming[v][u] = e  <span class="comment"># 将边放入二级结构 I(v)</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">vertex_count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;总点数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._outgoing)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">vertices</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回点的迭代器&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._outgoing.keys()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">edge_count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;总边数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 总度数</span></span><br><span class="line">        total = <span class="built_in">sum</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>._outgoing[v]) <span class="keyword">for</span> v <span class="keyword">in</span> <span class="variable language_">self</span>._outgoing)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 无向图, 度求和要除以 2 . 有向图则不用</span></span><br><span class="line">        <span class="keyword">return</span> total <span class="keyword">if</span> <span class="variable language_">self</span>.is_directed() <span class="keyword">else</span> total // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">edges</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回图的所有边的集合 (已去重)&quot;&quot;&quot;</span></span><br><span class="line">        result = <span class="built_in">set</span>()  <span class="comment"># 存储边集合, 防止重复</span></span><br><span class="line">        <span class="keyword">for</span> secondary_map <span class="keyword">in</span> <span class="variable language_">self</span>._outgoing.values():</span><br><span class="line">            result.update(secondary_map.values())  <span class="comment"># 加入新边</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_edge</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回点 u 到点 v 的边, 不相邻则为 None&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 直接使用字典的 get() 方法, 没有则为 None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._outgoing[u].get(v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">degree</span>(<span class="params">self, v, outgoing=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回顶点 v 的度, 默认为出度</span></span><br><span class="line"><span class="string">        :param v: 顶点 Vertex 类</span></span><br><span class="line"><span class="string">        :param outgoing: False 则返回入度</span></span><br><span class="line"><span class="string">        :return: 顶点 v 的度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        adj = <span class="variable language_">self</span>._outgoing <span class="keyword">if</span> outgoing <span class="keyword">else</span> <span class="variable language_">self</span>._incoming</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(adj[v])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incident_edges</span>(<span class="params">self, v, outgoing=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        以迭代器的形式返回顶点 v 的边, 默认为出射边</span></span><br><span class="line"><span class="string">        :param v: 顶点 Vertex 类</span></span><br><span class="line"><span class="string">        :param outgoing: False 则返回入射边</span></span><br><span class="line"><span class="string">        :return: 从顶点 v 出射的边 (入射 v 的边)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        adj = <span class="variable language_">self</span>._outgoing <span class="keyword">if</span> outgoing <span class="keyword">else</span> <span class="variable language_">self</span>._incoming</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> adj[v].values():</span><br><span class="line">            <span class="keyword">yield</span> edge</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Graph(directed=<span class="literal">False</span>)</span><br><span class="line">    v1 = g.insert_vertex(<span class="number">1</span>)</span><br><span class="line">    v2 = g.insert_vertex(<span class="number">2</span>)</span><br><span class="line">    v3 = g.insert_vertex(<span class="number">3</span>)</span><br><span class="line">    v4 = g.insert_vertex(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    g.insert_edge(v1, v2, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    g.insert_edge(v2, v3, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    g.insert_edge(v3, v4, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    g.insert_edge(v4, v1, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">    g.insert_edge(v1, v3, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">    g.insert_edge(v2, v4, <span class="string">&quot;f&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Graph is directed or not: <span class="subst">&#123;g.is_directed()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;All Vertices&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g.vertices():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Vertex: <span class="subst">&#123;v.element()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;All Edges&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> g.edges():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Edge: <span class="subst">&#123;e.element()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Graph <span class="keyword">is</span> directed <span class="keyword">or</span> <span class="keyword">not</span>: <span class="literal">False</span></span><br><span class="line">=============== All Vertices ===============</span><br><span class="line">Vertex: <span class="number">1</span></span><br><span class="line">Vertex: <span class="number">2</span></span><br><span class="line">Vertex: <span class="number">3</span></span><br><span class="line">Vertex: <span class="number">4</span></span><br><span class="line">=============== All Edges ===============</span><br><span class="line">Edge: f</span><br><span class="line">Edge: b</span><br><span class="line">Edge: d</span><br><span class="line">Edge: c</span><br><span class="line">Edge: a</span><br><span class="line">Edge: e</span><br></pre></td></tr></table></figure><h2 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2 图的遍历"></a>2 图的遍历</h2><p>图的遍历可以解决很多关于图的可达性的问题：</p><ul><li>找到任意两个顶点间的路径（或验证两个顶点间无路径）</li><li>找到从图的一个特定顶点出发可以到达的所有顶点及相应的路径</li><li>测试图是否是连通的</li><li>找到图的所有连通分支</li><li>判断图是否为强连通的</li></ul><p>我们常常使用如下两种算法进行图的遍历：</p><ul><li><strong>深度优先搜索</strong></li><li><strong>广度优先搜索</strong></li></ul><h3 id="2-1-深度优先搜索-DFS"><a href="#2-1-深度优先搜索-DFS" class="headerlink" title="2.1 深度优先搜索 DFS"></a>2.1 深度优先搜索 DFS</h3><p><strong>深度优先搜索（DFS）</strong>是一种常用的图遍历算法，可实现以下功能：</p><ul><li>访问图 G 的所有顶点和边</li><li>判断图 G 是否是连通的</li><li>找到图 G 的所有连通分支</li><li>对图 G 的所有连通分支，计算其生成树</li></ul><p>DFS 还可被用来解决其他问题，如：</p><ul><li>找到两个顶点间的一条路径</li><li>找到图中的环</li></ul><h4 id="2-1-1-深度优先搜索算法"><a href="#2-1-1-深度优先搜索算法" class="headerlink" title="2.1.1 深度优先搜索算法"></a>2.1.1 深度优先搜索算法</h4><p>图的 DFS 算法使用一种记录并查询顶点和边的“标签”的方式来判断顶点和边是否被访问过，下面以无向图为例给出 DFS 算法。此算法将所有边分为 <code>discovery</code> 和 <code>back</code> 两类。</p><p>【伪代码】从图 G 的某一个顶点 v 开始深度优先搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Algorithm DFS(G, v)</span><br><span class="line">    [Input]: graph G <span class="keyword">and</span> a start vertex v of G</span><br><span class="line">    [Output]: labeling of the edges of G <span class="keyword">in</span> the connected component of v <span class="keyword">as</span> discovery edges <span class="keyword">and</span> back edges</span><br><span class="line">    [Algorithm]:</span><br><span class="line">    setLabel(v, VISITED)  <span class="comment"># v 已被访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> e = G.incidentEdges(v)  <span class="comment"># v 的所有邻边 e</span></span><br><span class="line">        <span class="keyword">if</span> getLabel(e) = UNEXPLORED  <span class="comment"># 若边 e 未被访问</span></span><br><span class="line">        w = opposite(v,e)  <span class="comment"># 找到边 e 的非 v 的顶点 w</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> getLabel(w) = UNEXPLORED  <span class="comment"># 若点 w 未被访问</span></span><br><span class="line">            setLabel(e, DISCOVERY)  <span class="comment"># 标记边 e 为 discovery</span></span><br><span class="line">            DFS(G, w)  <span class="comment"># 从点 w 继续递归探索</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            setLabel(e, BACK)  <span class="comment"># 否则, 点 w 被访问过, 则标记边 e 为 back</span></span><br></pre></td></tr></table></figure><p>【伪代码】图 G 每一个点都进行 DFS：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Algorithm DFS(G)</span><br><span class="line">    [Input]: graph G</span><br><span class="line">    [Output]: labeling of the edges of G <span class="keyword">as</span> discovery edges <span class="keyword">and</span> back edges</span><br><span class="line">    [Algorithm]:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> u = G.vertices()  </span><br><span class="line">    setLabel(u, UNEXPLORED)  <span class="comment"># 图 G 的所有点初始化为未访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> e = G.edges()  <span class="comment"># 图 G 的所有边初始化为未访问</span></span><br><span class="line">    setLabel(e, UNEXPLORED)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> v = G.vertices()  <span class="comment"># 使用上面定义的 DFS(G, v) 对每个点 DFS</span></span><br><span class="line">    <span class="keyword">if</span> getLabel(v) = UNEXPLORED</span><br><span class="line">    DFS(G, v)</span><br></pre></td></tr></table></figure><p>DFS 深度优先搜索的例子：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746612421410.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746612483755.png" alt=""></p><h4 id="2-1-2-Python-实现"><a href="#2-1-2-Python-实现" class="headerlink" title="2.1.2 Python 实现"></a>2.1.2 Python 实现</h4><p>【无向图】实现 <code>DFS(G, v)</code> 即任一顶点出发的 DFS 算法，图 <code>Graph</code> 类代码见上面图的 Python 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">g: Graph, u: Graph.Vertex, discovered: <span class="built_in">dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    图 g 中任意顶点 u 的深度优先搜索</span></span><br><span class="line"><span class="string">    :param g: 图 Graph 类</span></span><br><span class="line"><span class="string">    :param u: 顶点 Graph.Vertex 类</span></span><br><span class="line"><span class="string">    :param discovered: 字典, 存储探索结果</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u):  <span class="comment"># 经过顶点 u 的所有边 e</span></span><br><span class="line">        v = e.opposite(u)  <span class="comment"># 获取 e 非 u 的顶点 v</span></span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> discovered:  <span class="comment"># 顶点 v 未被访问</span></span><br><span class="line">            discovered[v] = e  <span class="comment"># 标记边 e 为 discovery; 同时标记点 v 访问过</span></span><br><span class="line">            DFS(g, v, discovered)  <span class="comment"># 从 v 继续递归探索</span></span><br></pre></td></tr></table></figure><p>测试：先创建一个图，这个图大致为如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Graph(directed=<span class="literal">False</span>)</span><br><span class="line">    v1 = g.insert_vertex(<span class="number">1</span>)</span><br><span class="line">    v2 = g.insert_vertex(<span class="number">2</span>)</span><br><span class="line">    v3 = g.insert_vertex(<span class="number">3</span>)</span><br><span class="line">    v4 = g.insert_vertex(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    e12 = g.insert_edge(v1, v2, <span class="string">&quot;(1, 2)&quot;</span>)</span><br><span class="line">    e23 = g.insert_edge(v2, v3, <span class="string">&quot;(2, 3)&quot;</span>)</span><br><span class="line">    e34 = g.insert_edge(v3, v4, <span class="string">&quot;(3, 4)&quot;</span>)</span><br><span class="line">    e14 = g.insert_edge(v4, v1, <span class="string">&quot;(1, 4)&quot;</span>)</span><br><span class="line">    e24 = g.insert_edge(v2, v4, <span class="string">&quot;(2, 4)&quot;</span>)</span><br><span class="line">    e13 = g.insert_edge(v1, v3, <span class="string">&quot;(1, 3)&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1 ----- 2</span></span><br><span class="line"><span class="string">    | \   / |  </span></span><br><span class="line"><span class="string">    |   X   |</span></span><br><span class="line"><span class="string">    | /   \ |</span></span><br><span class="line"><span class="string">    4 ----- 3</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>使用如下的 <code>discovered = &#123;v1: None&#125;</code> 即可从 <code>v1</code> 开始搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discovered = &#123;v1: <span class="literal">None</span>&#125;</span><br><span class="line">   DFS(g, v1, discovered)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> v, e <span class="keyword">in</span> discovered.items():</span><br><span class="line">       <span class="keyword">if</span> e <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">f&quot;Vertex <span class="subst">&#123;v.element()&#125;</span> : Edge <span class="subst">&#123;e.element()&#125;</span>&quot;</span>)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">f&quot;Vertex <span class="subst">&#123;v.element()&#125;</span> : Initial&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：从 <code>1</code> 开始，经过 <code>(1, 2)</code> 到达 <code>2</code> ，经过 <code>(2, 3)</code> 到达 <code>3</code> ，经过 <code>(3, 4)</code> 达到 <code>4</code> 。</p><blockquote><p>【注意】这里的结果只是一种可能，不过只要得到这一种可能，就已经遍历了全图的每个顶点和边。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vertex <span class="number">1</span> : Initial</span><br><span class="line">Vertex <span class="number">2</span> : Edge (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Vertex <span class="number">3</span> : Edge (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Vertex <span class="number">4</span> : Edge (<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-DFS-的性质和性能"><a href="#2-1-3-DFS-的性质和性能" class="headerlink" title="2.1.3 DFS 的性质和性能"></a>2.1.3 DFS 的性质和性能</h4><p><strong>性质：</strong></p><ul><li><p><code>DFS(G, v)</code> 访问了顶点 v 所在的连通分支的所有顶点和边</p></li><li><p>由 <code>DFS(G, v)</code> 标记的所有边均为 discovery 边，且这些边形成了顶点 v 所在的连通分支的一个生成树</p></li></ul><p><strong>性能：</strong></p><ul><li>记录或查询顶点和边的标签需要 O(1) 的时间</li><li>每个顶点被标记一次，即第一次被访问时被标记为“已访问”</li><li>每条边被标记一次并检查两次：第一次被访问时标记为“已访问”；在两个端点被访问时，该边均被检查一次</li><li>每个顶点调用一次 <code>incident_edges()</code> 方法（以迭代器的形式返回顶点 v 的边）</li></ul><p>对于顶点数为 n ，边数为 m 的图，存储方式为邻接表或邻接映射时，DFS 的运行时间为 <strong>O(n + m)</strong> 。</p><h4 id="2-1-4-寻找任意-2-点间的路径"><a href="#2-1-4-寻找任意-2-点间的路径" class="headerlink" title="2.1.4 寻找任意 2 点间的路径"></a>2.1.4 寻找任意 2 点间的路径</h4><p>我们可以将 DFS 算法特化并应用于寻找两个顶点 v 和 z 间的路径：</p><ul><li>使用一个栈记录起点到当前顶点的路径</li><li>找到目标顶点 z 后，将栈中内容输出即为两顶点间的路径</li></ul><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Algorithm pathDFS(G, v, z)</span><br><span class="line">[Algorithm]:</span><br><span class="line">    setLabel(v, VISITED)  <span class="comment"># 起始点 v 标记为已经访问</span></span><br><span class="line">    S.push(v)  <span class="comment"># 压入栈底</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> v = z  <span class="comment"># 找到, 则将栈元素全部返回</span></span><br><span class="line">    <span class="keyword">return</span> S.elements()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> e = G.incidentEdges(v)  <span class="comment"># 点 v 的所有边 e</span></span><br><span class="line">        <span class="keyword">if</span> getLabel(e) = UNEXPLORED  <span class="comment"># 若边 e 未访问</span></span><br><span class="line">            w = opposite(v,e)  <span class="comment"># 找到边 e 另一个端点 w</span></span><br><span class="line">            <span class="keyword">if</span> getLabel(w) = UNEXPLORED  <span class="comment"># 若点 w 未访问</span></span><br><span class="line">                setLabel(e, DISCOVERY)  <span class="comment"># 标记 e 为 discovery</span></span><br><span class="line">                S.push(e)  <span class="comment"># 并压入栈, 作为路径的一部分</span></span><br><span class="line">                pathDFS(G, w, z)  <span class="comment"># 从 w 点继续递归探索</span></span><br><span class="line">                </span><br><span class="line">                S.pop(e)  <span class="comment"># 从边 e 探索未找到, 则出栈</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            setLabel(e, BACK)  <span class="comment"># 若点 w 被访问, 标记 e 为 back</span></span><br><span class="line">    S.pop(v)  <span class="comment"># 所有点 v 的邻点都失败，则将点 v 出栈</span></span><br></pre></td></tr></table></figure><p>Python 实现：传入的 <code>discovered</code> 参数需要先使用 <code>DFS(g, u, discovered)</code> 得到结果（即标记好了的 <code>discovered</code>），然后才能反向找出任意 2 点的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">construct_path</span>(<span class="params">u: Graph.Vertex, v: Graph.Vertex, discovered: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回从点 u 到 v 的路径</span></span><br><span class="line"><span class="string">    :param u: 起始顶点 Graph.Vertex 类</span></span><br><span class="line"><span class="string">    :param v: 终止顶点 Graph.Vertex 类</span></span><br><span class="line"><span class="string">    :param discovered: 字典, 存储路径 (依赖于从 点 u 开始的 DFS 遍历结果的 discovered)</span></span><br><span class="line"><span class="string">    :return: 路径 Python.list 类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    path = []  <span class="comment"># 存储路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">in</span> discovered:  <span class="comment"># 开始从终点 v 向前探索, 回到 u</span></span><br><span class="line">        path.append(v.element())</span><br><span class="line">        walk = v</span><br><span class="line">        <span class="keyword">while</span> walk <span class="keyword">is</span> <span class="keyword">not</span> u:</span><br><span class="line">            e = discovered[walk]  <span class="comment"># 获取到点 walk 的边 e = (?, walk)</span></span><br><span class="line">            parent = e.opposite(walk)  <span class="comment"># 获取路径上 walk 的上一个点 ?</span></span><br><span class="line">            path.append(parent.element())  <span class="comment"># 加入路径</span></span><br><span class="line">            walk = parent  <span class="comment"># 继续向前</span></span><br><span class="line"></span><br><span class="line">        path.reverse()  <span class="comment"># 最终路径逆转就是 u -&gt; v</span></span><br><span class="line">    <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure><p>测试：例如找出点 <code>v2</code> 到 <code>v4</code> 的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">discovered = &#123;v1: <span class="literal">None</span>&#125;</span><br><span class="line">DFS(g, v1, discovered)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用之前的 DFS(g, v1, discovered) 的 discovered 结果</span></span><br><span class="line">path = construct_path(v2, v4, discovered)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;From v2 to v4: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">From v2 to v4: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="2-1-5-寻找简单环"><a href="#2-1-5-寻找简单环" class="headerlink" title="2.1.5 寻找简单环"></a>2.1.5 寻找简单环</h4><p>我们还可以将 DFS 算法特化并应用于寻找一个图中的简单环</p><ul><li>使用一个栈记录起点到当前顶点的路径</li><li>找到一个 back 边后，输出栈中内容的一部分即为简单环</li></ul><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Algorithm cycleDFS(G, v, z)</span><br><span class="line">[Algorithm]:</span><br><span class="line">    setLabel(v, VISITED)  <span class="comment"># 起始点 v 标记为已经访问</span></span><br><span class="line">    S.push(v)  <span class="comment"># 压入栈底</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> e = G.incidentEdges(v)  <span class="comment"># 点 v 的所有边 e</span></span><br><span class="line">        <span class="keyword">if</span> getLabel(e) = UNEXPLORED  <span class="comment"># 若边 e 未访问</span></span><br><span class="line">            w = opposite(v,e)  <span class="comment"># 找到边 e 另一个端点 w</span></span><br><span class="line">            S.push(e)  <span class="comment"># 边 e 压入栈</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> getLabel(w) = UNEXPLORED  <span class="comment"># 若点 w 未访问</span></span><br><span class="line">                setLabel(e, DISCOVERY)  <span class="comment"># 标记 e 为 discovery</span></span><br><span class="line">                pathDFS(G, w, z)  <span class="comment"># 从 w 点找到到达 z 的路径 (实现见上面代码)</span></span><br><span class="line"></span><br><span class="line">                S.pop(e)  <span class="comment"># 从边 e 探索未找到, 则出栈</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = new empty stack  <span class="comment"># 新栈: 存储环的路径</span></span><br><span class="line">                repeat  <span class="comment"># 不断从栈 S 中获取点和边</span></span><br><span class="line">                    o = S.pop()</span><br><span class="line">                    T.push(o)</span><br><span class="line">                until o = w  <span class="comment"># 回到了点 w 形成了环</span></span><br><span class="line">                <span class="keyword">return</span> T.elements()  <span class="comment"># 于是返回环所有元素</span></span><br><span class="line">    S.pop(v)  <span class="comment"># 没有环, 则将 v 出栈</span></span><br></pre></td></tr></table></figure><h3 id="2-2-广度优先搜索-BFS"><a href="#2-2-广度优先搜索-BFS" class="headerlink" title="2.2 广度优先搜索 BFS"></a>2.2 广度优先搜索 BFS</h3><p><strong>广度优先搜索（BFS）</strong>是另一种常用的图遍历算法，也可以可实现以下功能：</p><ul><li>访问图 G 的所有顶点和边</li><li>判断图 G 是否是连通的</li><li>找到图 G 的所有连通分支</li><li>对图 <em>G</em> 的所有连通分支，计算其生成树</li></ul><p>BFS 还可以用来解决其他问题，如：</p><ul><li>找到两个顶点间经过边数最少的路径</li><li>找到图中的环</li></ul><h4 id="2-2-1-广度优先搜索算法"><a href="#2-2-1-广度优先搜索算法" class="headerlink" title="2.2.1 广度优先搜索算法"></a>2.2.1 广度优先搜索算法</h4><p>与 DFS 类似， BFS 算法使用一种记录并查询顶点和边的“标签”的方式来判断顶点和边是否被访问过。下面以无向图为例给出 BFS 算法，此算法将所有边分为 <code>discovery</code> 和 <code>cross</code> 两类。</p><p>【伪代码】从图 G 的某一个顶点 v 开始广度优先搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Algorithm BFS(G, s)</span><br><span class="line">[Algorithm]:</span><br><span class="line">    L&#123;<span class="number">0</span>&#125; = new empty sequence</span><br><span class="line">    L&#123;<span class="number">0</span>&#125;.addLast(s)  <span class="comment"># 第一层</span></span><br><span class="line">    setLabel(s, VISITED)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> L&#123;i&#125;.isEmpty()</span><br><span class="line">        L&#123;i+<span class="number">1</span>&#125; = new empty sequence</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">all</span> v = L&#123;i&#125;.elements()   <span class="comment"># 遍历 L&#123;i&#125; 的点 v</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">all</span> e = G.incidentEdges(v)  <span class="comment"># 取点 v 的所有邻边 e</span></span><br><span class="line">                <span class="keyword">if</span> getLabel(e) = UNEXPLORED  <span class="comment"># 若 e 未标记</span></span><br><span class="line">                w = opposite(v, e)  <span class="comment"># 取边 e 的另一个端点 w</span></span><br><span class="line">                    <span class="keyword">if</span> getLabel(w) = UNEXPLORED  <span class="comment"># 若点 w 未访问</span></span><br><span class="line">                    setLabel(e, DISCOVERY)  <span class="comment"># 标记边 e 为 discovery</span></span><br><span class="line">                    setLabel(w, VISITED)  <span class="comment"># 标记点 w 已访问</span></span><br><span class="line">                    L&#123;i+<span class="number">1</span>&#125;.addLast(w)  <span class="comment"># 并将 w 放入该层 L&#123;i+1&#125;</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    setLabel(e, CROSS)  <span class="comment"># 若点 w 已访问, 则标记边 e 为 cross</span></span><br><span class="line">    i = i +<span class="number">1</span>  <span class="comment"># 探索下一层</span></span><br></pre></td></tr></table></figure><p>【伪代码】图 G 每一个点都进行 BFS：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Algorithm BFS(G)</span><br><span class="line">    [Input]: graph G</span><br><span class="line">    [Output]: labeling of the edges of G </span><br><span class="line">[Algorithm]:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> u = G.vertices()  <span class="comment"># 标记所有点未访问</span></span><br><span class="line">    setLabel(u, UNEXPLORED)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> e = G.edges()  <span class="comment"># 标记所有边未访问</span></span><br><span class="line">    setLabel(e, UNEXPLORED)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">all</span> v = G.vertices()  <span class="comment"># 取所有点 v</span></span><br><span class="line">        <span class="keyword">if</span> getLabel(v) = UNEXPLORED  <span class="comment"># 若 v 未访问</span></span><br><span class="line">            BFS(G, v)  <span class="comment"># 进行 BFS</span></span><br></pre></td></tr></table></figure><p>BFS 广度优先搜索的例子：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746623826094.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746623847282.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746623870768.png" alt=""></p><h4 id="2-2-2-Python-实现"><a href="#2-2-2-Python-实现" class="headerlink" title="2.2.2 Python 实现"></a>2.2.2 Python 实现</h4><p>【无向图】实现 <code>BFS(G, v)</code> 即任一顶点出发的 BFS 算法，图 <code>Graph</code> 类代码见上面图的 Python 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> Graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">g: Graph, s: Graph.Vertex, discovered: <span class="built_in">dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    图 g 中任意顶点 s 的广度优先搜索</span></span><br><span class="line"><span class="string">    :param g: 图 Graph 类</span></span><br><span class="line"><span class="string">    :param s: 顶点 Graph.Vertex 类</span></span><br><span class="line"><span class="string">    :param discovered: 字典, 存储探索结果</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    level = [s]  <span class="comment"># 第一层, 只有初始顶点 s</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(level) &gt; <span class="number">0</span>:</span><br><span class="line">        next_level = []  <span class="comment"># 下一层的顶点集</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> level:  <span class="comment"># 遍历本层所有点</span></span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> g.incident_edges(u):  <span class="comment"># 对 u 遍历所有边 e</span></span><br><span class="line">                v = e.opposite(u)  <span class="comment"># 找到边 e 的另一个端点 v</span></span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> discovered:  <span class="comment"># 若 v 未标记</span></span><br><span class="line">                    discovered[v] = e  <span class="comment"># 则标记边 e</span></span><br><span class="line">                    next_level.append(v)  <span class="comment"># 且存储点 v</span></span><br><span class="line"></span><br><span class="line">        level = next_level  <span class="comment"># 更新当前层</span></span><br></pre></td></tr></table></figure><p>测试：构造图，如上面 BFS 广度优先搜索的例子的图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Graph(directed=<span class="literal">False</span>)</span><br><span class="line">    A = g.insert_vertex(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    B = g.insert_vertex(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    C = g.insert_vertex(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    D = g.insert_vertex(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    E = g.insert_vertex(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    F = g.insert_vertex(<span class="string">&quot;F&quot;</span>)</span><br><span class="line"></span><br><span class="line">    AB = g.insert_edge(A, B, <span class="string">&quot;(A, B)&quot;</span>)</span><br><span class="line">    AC = g.insert_edge(A, C, <span class="string">&quot;(A, C)&quot;</span>)</span><br><span class="line">    AD = g.insert_edge(A, D, <span class="string">&quot;(A, D)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    BC = g.insert_edge(B, C, <span class="string">&quot;(B, C)&quot;</span>)</span><br><span class="line">    CD = g.insert_edge(C, D, <span class="string">&quot;(C, D)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    BE = g.insert_edge(B, E, <span class="string">&quot;(B, E)&quot;</span>)</span><br><span class="line">    CE = g.insert_edge(C, E, <span class="string">&quot;(C, E)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    CF = g.insert_edge(C, F, <span class="string">&quot;(C, F)&quot;</span>)</span><br><span class="line">    DF = g.insert_edge(D, F, <span class="string">&quot;(D, F)&quot;</span>)</span><br></pre></td></tr></table></figure><p>初始化 <code>discovered = &#123;A: None&#125;</code> ，用于存储结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discovered = &#123;A: <span class="literal">None</span>&#125;</span><br><span class="line">   BFS(g, A, discovered)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> v, e <span class="keyword">in</span> discovered.items():</span><br><span class="line">       <span class="keyword">if</span> e <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">f&quot;Vertex <span class="subst">&#123;v.element()&#125;</span> : Edge <span class="subst">&#123;e.element()&#125;</span>&quot;</span>)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">f&quot;Vertex <span class="subst">&#123;v.element()&#125;</span> : Initial&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：恰好对应着之前例子里的 <code>discovery</code> 边</p><p>第 0 到 1 层 <code>(A, B)</code>, <code>(A, C)</code>, <code>(A, D)</code></p><p>第 1 到 2 层 <code>(B, E)</code>, <code>(C, F)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vertex A : Initial</span><br><span class="line">Vertex B : Edge (A, B)</span><br><span class="line">Vertex C : Edge (A, C)</span><br><span class="line">Vertex D : Edge (A, D)</span><br><span class="line">Vertex E : Edge (B, E)</span><br><span class="line">Vertex F : Edge (C, F)</span><br></pre></td></tr></table></figure><h4 id="2-2-3-BFS-的性质和性能"><a href="#2-2-3-BFS-的性质和性能" class="headerlink" title="2.2.3 BFS 的性质和性能"></a>2.2.3 BFS 的性质和性能</h4><p><strong>性质：</strong>我们使用 Gs 表示 s 所属的连通分支</p><ul><li><code>BFS(G, s)</code> 访问了 Gs 的所有顶点和边</li><li>由 <code>BFS(G, s)</code> 标记的所有边均为 discovery 边，且这些边形成了 Gs 的一个生成树</li><li>对于 Li 层中的每个顶点 v ：从 s 到 v 的路径经过 i 条边；从 s 到 v 的每一条路径经过的边数不小于 i</li></ul><p><strong>性能：</strong></p><ul><li>记录或查询顶点和边的标签需要 O(1) 的时间</li><li>每个顶点被标记一次，即第一次被访问时被标记为“已访问”</li><li>每条边被标记一次并检查两次：第一次被访问时标记为“已访问”；在两个端点被访问时，该边均被检查一次</li><li>每个顶点被插入到某一序列/层 Li 一次</li><li>每个顶点调用一次 <code>incident_edges()</code> 方法（以迭代器的形式返回顶点 v 的边）</li></ul><p>对于顶点数为 n ，边数为 m 的图，存储方式为邻接表或邻接映射时，DFS的运行时间为 <strong>O(n + m)</strong> 。</p><h3 id="2-3-DFS-vs-BFS"><a href="#2-3-DFS-vs-BFS" class="headerlink" title="2.3 DFS vs BFS"></a>2.3 DFS vs BFS</h3><p>深度优先搜索 DFS 和广度优先搜索 BFS 都可用于“生成树、连通分支、顶点间路径、环”的生成。“强连通分量”的生成一般使用 DFS 。寻找“边数最少的路径”一般使用 BFS 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746625135261.png" alt="DFS 和 BFS 更擅长的应用"></p><p><strong>back 边与 cross 边</strong></p><ul><li><p>Back 边 (v, w) ：w 是深度搜索树中 v 的祖先</p></li><li><p>Cross 边 (v, w) ：w 与 v 在同一层上，或 w 在 v 的下一层</p></li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746625370669.png" alt=""></p>]]></content>
    
    
    <summary type="html">本章介绍图的基本概念、图的存储结构（边列表、邻接表、邻接矩阵）、图的抽象数据类型 ADT 与 Python 实现。图的遍历算法：深度优先搜索 DFS 、广度优先搜索 BFS 及它们的应用。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>排序算法与选择</title>
    <link href="https://blog.iskage.online/posts/ea35d84e.html"/>
    <id>https://blog.iskage.online/posts/ea35d84e.html</id>
    <published>2025-05-05T00:16:00.000Z</published>
    <updated>2025-05-05T10:07:15.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法与选择"><a href="#排序算法与选择" class="headerlink" title="排序算法与选择"></a>排序算法与选择</h1><p>本章详细介绍排序算法，包括：归并排序、快速排序、排序下界、桶排序、字典序排序的知识。</p><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><hr><p>排序（sorting）算法是一类重要算法，已被众多学者充分研究过，且在实践中有重大价值：</p><ul><li><p>许多解决不同问题的算法均依赖于排序算法的实现</p></li><li><p>数据分析与处理中经常会用到排序算法</p></li></ul><p>Python对排序提供 list 类的 sort 及对任意元素集合的 sorted 函数。这些函数使用高度优化后的高级排序算法。学习排序算法后可以对这些函数的效率有直观的认知。</p><p>之前已经介绍过了插入排序、选择排序、冒泡排序和高级排序方法——堆排序。</p><blockquote><p>【补充】冒泡排序：</p><p>假设序列为 $a_1, a_2, …, a_n$ </p><p>第一次扫描：从序列尾向序列头进行，比较相邻两个元素的大小，如出现逆序 $a_j &gt; a_j+1$ 则交换两个元素（第一次扫描结束后，最小的元素被排在第一位）；第二次扫描：依然从序列尾向序列头进行，出现逆序则交换相邻元素，一直进行到第二个元素为止</p><p>如此下去，最终即可排序整个序列。最坏的情况下（完全逆序）需要交换 $\sum_{i=1}^{n-1} n-i \sim O(n^2)$ 。</p></blockquote><h2 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1 归并排序"></a>1 归并排序</h2><h3 id="1-1-分治法"><a href="#1-1-分治法" class="headerlink" title="1.1 分治法"></a>1.1 分治法</h3><p>接下来描述的两个算法（归并排序和快速排序）均由分治法思想产生。<strong>分治法（Divide-and-Conquer）</strong>是一种通用的算法设计范式：</p><ul><li>分解（Divide）：如输入数据 S 规模较小则直接解决；否则，将其分成两个或多个互斥子集 S1, S2, …</li><li><p>解决子问题（Conquer）：递归解决与子集相关的子问题</p></li><li><p>合并（Combine）：将子问题 S1, S2, … 的解合并为 S 的解</p></li></ul><h3 id="1-2-归并排序"><a href="#1-2-归并排序" class="headerlink" title="1.2 归并排序"></a>1.2 归并排序</h3><p><strong>归并排序（merge-sort）</strong>基于分治法思想。在有 n 个元素的序列 S 上执行归并排序的过程如下：</p><ul><li>分解（Divide）：当序列 S 长度大于 1 时，将其分为两个长度大致为 n/2 的子序列 S1 和 S2</li><li>解决子问题（Conquer）：递归地对 S1 和 S2 进行排序</li><li>合并（Combine）：将排好序的 S1 和 S2 合并为一个有序的序列</li></ul><p>归并排序伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Algorithm mergeSort(S)</span><br><span class="line">Input sequence S <span class="keyword">with</span> n elements </span><br><span class="line">Output sequence S <span class="built_in">sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> S.size() &gt; <span class="number">1</span></span><br><span class="line">(S1, S2) = partition(S, n/<span class="number">2</span>)  <span class="comment"># 拆分</span></span><br><span class="line">        mergeSort(S1)<span class="comment"># 递归排序</span></span><br><span class="line">        mergeSort(S2)</span><br><span class="line">S = merge(S1, S2)<span class="comment"># 合并</span></span><br></pre></td></tr></table></figure><p>在归并排序的最后一步（合并）中，需要将两个有序序列 A 和 B 合并为一个有序序列 S 这一合并操作的时间复杂度为 <strong>O(n)</strong> 。</p><p>合并操作的伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Algorithm merge(A, B)</span><br><span class="line">Input sequences A <span class="keyword">and</span> B <span class="keyword">with</span> n/<span class="number">2</span> elements each </span><br><span class="line">Output <span class="built_in">sorted</span> sequence of A + B</span><br><span class="line"></span><br><span class="line">    S = empty sequence</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> A.isEmpty() <span class="keyword">and</span> <span class="keyword">not</span> B.isEmpty()</span><br><span class="line"><span class="keyword">if</span> A.first().element() &lt; B.first().element()</span><br><span class="line">S.addLast(A.remove(A.first()))<span class="comment"># 从小到大插入</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">S.addLast(B.remove(B.first()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> A.isEmpty() <span class="comment"># 将剩余部分插入</span></span><br><span class="line">S.addLast(A.remove(A.first()))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> B.isEmpty()</span><br><span class="line">S.addLast(B.remove(B.first()))</span><br><span class="line"><span class="keyword">return</span> S</span><br></pre></td></tr></table></figure><h3 id="1-3-归并排序树"><a href="#1-3-归并排序树" class="headerlink" title="1.3 归并排序树"></a>1.3 归并排序树</h3><p>归并排序的执行过程可以用一棵二叉树很好地表示，我们称之为<strong>归并排序树（merge-sort tree）</strong></p><ul><li>归并排序树的每一个节点代表一次递归调用</li><li>根节点：首次调用归并排序的位置</li><li>叶子节点表示：对长为 0 或 1 对序列进行排序</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746362404181.png" alt="归并排序的例子"></p><h3 id="1-4-Python-实现"><a href="#1-4-Python-实现" class="headerlink" title="1.4 Python 实现"></a>1.4 Python 实现</h3><h4 id="1-4-1-基于数组的归并排序"><a href="#1-4-1-基于数组的归并排序" class="headerlink" title="1.4.1 基于数组的归并排序"></a>1.4.1 基于数组的归并排序</h4><p>下面的代码是基于数组的归并排序方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">S1: <span class="built_in">list</span>, S2: <span class="built_in">list</span>, S: <span class="built_in">list</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并数组/序列 S1 S2 返回新的数组/序列</span></span><br><span class="line"><span class="string">    :param S1: 顺序序列 S1</span></span><br><span class="line"><span class="string">    :param S2: 顺序序列 S2</span></span><br><span class="line"><span class="string">    :param S: 用于存储最终合并的结果，按照从小到大排序的序列</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i + j &lt; <span class="built_in">len</span>(S):</span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(S2) <span class="keyword">or</span> (i &lt; <span class="built_in">len</span>(S1) <span class="keyword">and</span> S1[i] &lt; S2[j]):</span><br><span class="line">            S[i + j] = S1[i]  <span class="comment"># copy i th element of S1 as next item of S</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S[i + j] = S2[j]  <span class="comment"># copy j th element of S2 as next item of S</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">S: <span class="built_in">list</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对序列 S 进行归并排序，直接修改原序列</span></span><br><span class="line"><span class="string">    :param S: 等待排序的序列</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(S)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># list is already sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># divide</span></span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    S1 = S[<span class="number">0</span>:mid]  <span class="comment"># copy of first half</span></span><br><span class="line">    S2 = S[mid:n]  <span class="comment"># copy of second half</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># conquer (with recursion)</span></span><br><span class="line">    merge_sort(S1)  <span class="comment"># sort copy of first half</span></span><br><span class="line">    merge_sort(S2)  <span class="comment"># sort copy of second half</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># merge results</span></span><br><span class="line">    merge(S1, S2, S)  <span class="comment"># merge sorted halves back into S</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    S = [<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Original List&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;After Sorted&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    merge_sort(S)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=============== Original <span class="type">List</span> ===============</span><br><span class="line">[<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line">=============== After Sorted ===============</span><br><span class="line">[<span class="number">17</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">96</span>]</span><br></pre></td></tr></table></figure><h4 id="1-4-2-基于链表的归并排序"><a href="#1-4-2-基于链表的归并排序" class="headerlink" title="1.4.2 基于链表的归并排序"></a>1.4.2 基于链表的归并排序</h4><p>可以借助之前实现的“基于链表的队列”存储数据，实现归并排序。 <code>LinkedQueue</code> 类的定义见 <a href="https://github.com/isKage/dsa-notes/blob/main/lec11_sort_select/utils/linked_queue.py">code: LinkedQueue</a> ，归并排序实现代码见下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> LinkedQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">S1: LinkedQueue, S2: LinkedQueue, S: LinkedQueue</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并链表 (利用链表队列) 返回顺序链表队列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> S1.is_empty() <span class="keyword">and</span> <span class="keyword">not</span> S2.is_empty():</span><br><span class="line">        <span class="keyword">if</span> S1.first() &lt; S2.first():</span><br><span class="line">            S.enqueue(S1.dequeue())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S.enqueue(S2.dequeue())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> S1.is_empty():</span><br><span class="line">        <span class="comment"># move remaining elements of S1 to S</span></span><br><span class="line">        S.enqueue(S1.dequeue())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> S2.is_empty():</span><br><span class="line">        <span class="comment"># move remaining elements of 52 to S</span></span><br><span class="line">        S.enqueue(S2.dequeue())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">S: LinkedQueue</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对链表使用归并排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(S)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># list is already sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># divide</span></span><br><span class="line">    S1 = LinkedQueue()</span><br><span class="line">    S2 = LinkedQueue()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(S1) &lt; n // <span class="number">2</span>:  <span class="comment"># move the first n//2 elements to S1</span></span><br><span class="line">        S1.enqueue(S.dequeue())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> S.is_empty():  <span class="comment"># move the rest to S2</span></span><br><span class="line">        S2.enqueue(S.dequeue())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># conquer (with recursion)</span></span><br><span class="line">    merge_sort(S1)  <span class="comment"># sort first half</span></span><br><span class="line">    merge_sort(S2)  <span class="comment"># sort second half</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># merge results</span></span><br><span class="line">    merge(S1, S2, S)  <span class="comment"># merge sorted halves back into S</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    S = LinkedQueue()</span><br><span class="line">    S.from_list([<span class="number">45</span>, <span class="number">24</span>, <span class="number">85</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">17</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Original List&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(S)  <span class="comment"># LinkedQueue 已经定义了 __str__ 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;After Sorted&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    merge_sort(S)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=============== Original <span class="type">List</span> ===============</span><br><span class="line">[<span class="number">45</span>, <span class="number">24</span>, <span class="number">85</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">17</span>]</span><br><span class="line">=============== After Sorted ===============</span><br><span class="line">[<span class="number">17</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">96</span>]</span><br></pre></td></tr></table></figure><h4 id="1-4-3-基于数组的非递归归并排序"><a href="#1-4-3-基于数组的非递归归并排序" class="headerlink" title="1.4.3 基于数组的非递归归并排序"></a>1.4.3 基于数组的非递归归并排序</h4><p>自底向上的非递归的归并排序：这是基于数组的归并排序，实践中一般比普通归并排序更快。</p><p>这种算法的主要思想是执行自底向上的归并排序，即对整个归并排序树自底向上逐层执行合并。给出元素的一个输入数组，我们将每个连续的元素对合并成有序的，以长度为 2 开始执行。然后再合并至长度为 4 、长度为 8 等，以此类推，直到整个数组已经排序完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">src, result, start, inc</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并序列 src[start : start + inc] 和 src[start + inc : start + 2 * inc] 到 result 里&quot;&quot;&quot;</span></span><br><span class="line">    end1 = start + inc  <span class="comment"># 序列 1 的在原序列的结束索引</span></span><br><span class="line">    end2 = <span class="built_in">min</span>(start + <span class="number">2</span> * inc, <span class="built_in">len</span>(src))  <span class="comment"># 序列 2 的在原序列的结束索引</span></span><br><span class="line"></span><br><span class="line">    x, y = start, start + inc  <span class="comment"># x, y 代表被合并的序列的当前索引</span></span><br><span class="line">    z = start  <span class="comment"># z 代表合并后的序列的当前索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从小到底复制到合并后的序列中</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; end1 <span class="keyword">and</span> y &lt; end2:</span><br><span class="line">        <span class="keyword">if</span> src[x] &lt; src[y]:</span><br><span class="line">            result[z] = src[x]</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[z] = src[y]</span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">        z += <span class="number">1</span>  <span class="comment"># 继续</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将剩余的值放入合并后的序列</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; end1:</span><br><span class="line">        result[z:end2] = src[x:end1]</span><br><span class="line">    <span class="keyword">elif</span> y &lt; end2:</span><br><span class="line">        result[z:end2] = src[y:end2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">S</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对序列 S 进行原地归并排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(S)</span><br><span class="line">    logn = math.ceil(math.log(n, <span class="number">2</span>))  <span class="comment"># log_2 n</span></span><br><span class="line">    src, dest = S, [<span class="literal">None</span>] * n  <span class="comment"># dest 用于存储结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2</span> ** k <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(logn)]:  <span class="comment"># 2, 4, 8, 16, ..., n</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, <span class="number">2</span> * i):</span><br><span class="line">            merge(src, dest, j, i)  <span class="comment"># 自底向上合并</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取结果</span></span><br><span class="line">        src, dest = dest, src</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> S <span class="keyword">is</span> <span class="keyword">not</span> src:</span><br><span class="line">        S[<span class="number">0</span>:n] = src[<span class="number">0</span>:n]  <span class="comment"># 传入最后排序后的结果</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    S = [<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Original List&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;After Sorted&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    merge_sort(S)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=============== Original <span class="type">List</span> ===============</span><br><span class="line">[<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line">=============== After Sorted ===============</span><br><span class="line">[<span class="number">17</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">96</span>]</span><br></pre></td></tr></table></figure><h3 id="1-5-算法分析"><a href="#1-5-算法分析" class="headerlink" title="1.5 算法分析"></a>1.5 算法分析</h3><p>归并排序树的高度 h = O(log n) 。在深度为 i 的一层所需的时间为 O(n) 。我们对长度为 $n / 2^i$ 的 $2^i$ 个序列进行合并，并进行 $2^i+1$ 次递归调用。因此，归并排序的运行时间为 <strong>O(n log n)</strong> 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746363258879.png" alt="归并排序的时间复杂度"></p><h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2 快速排序"></a>2 快速排序</h2><h3 id="2-1-快速排序"><a href="#2-1-快速排序" class="headerlink" title="2.1 快速排序"></a>2.1 快速排序</h3><p><strong>快速排序（quick-sort）</strong>是一种基于分治法的随机排序算法，在序列 S 上其执行过程如下：</p><ul><li>分解（Divide）：随机选取一个元素 x，此元素被称为基准值（pivot），将序列分割为三部分：L 存储小于 x 的元素； E 存储等于 x 的元素； G 存储大于 x 的元素</li><li>解决子问题（Conquer）：递归地对 L 和 G 排序</li><li>合并（Combine）：合并 L 、 E 和 G</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746414848909.png" alt="快速排序的原理图" style="zoom:50%;" /></p><h3 id="2-2-分割"><a href="#2-2-分割" class="headerlink" title="2.2 分割"></a>2.2 分割</h3><p>我们采用如下方式对一个序列 S 进行分割：</p><ul><li><p>我们将 S 中的每一个元素 y 移出序列</p></li><li><p>根据 y 与基准值 x 的比较结果，将其插入 L 、 E 或 G</p></li><li>每一次插入或删除操作是在序列的尾或头进行的，因此其运行时间复杂度为 O(1)</li><li>由此可得，快速排序中每次分割操作的时间复杂度为 <strong>O(n)</strong> </li></ul><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Algorithm partition(S, p)</span><br><span class="line">    Input sequence S, position p of pivot </span><br><span class="line">    Output subsequences L, E, G of the elements of S less than, equal to, <span class="keyword">or</span> greater than the pivot, resp.</span><br><span class="line"></span><br><span class="line">    L, E, G &lt;- empty sequences</span><br><span class="line">    x = S.remove(p)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> S.isEmpty()</span><br><span class="line">    y = S.remove(S.first())</span><br><span class="line">        <span class="keyword">if</span> y &lt; x</span><br><span class="line">        L.addLast(y)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> y = x</span><br><span class="line">        E.addLast(y)</span><br><span class="line">        <span class="keyword">else</span> &#123; y &gt; x &#125;</span><br><span class="line">        G.addLast(y)</span><br><span class="line">    <span class="keyword">return</span> L, E, G</span><br></pre></td></tr></table></figure><h3 id="2-3-快速排序树"><a href="#2-3-快速排序树" class="headerlink" title="2.3 快速排序树"></a>2.3 快速排序树</h3><p>与归并排序一样，快速排序的执行也可以用一棵二叉树表示，称为<strong>快速排序树（quick-sort tree）</strong>：</p><ul><li>每个节点表示一次快速排序的递归调用，并存储如下信息：执行排序前的无序序列及基准值；执行排序后的有序序列</li><li>根节点：首次调用快速排序</li><li>叶子节点：在长度为 0 或 1 的序列上的调用</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746415281846.png" alt="快速排序树例子"></p><h3 id="2-4-Python-实现"><a href="#2-4-Python-实现" class="headerlink" title="2.4 Python 实现"></a>2.4 Python 实现</h3><h4 id="2-4-1-快速排序（基于链表）"><a href="#2-4-1-快速排序（基于链表）" class="headerlink" title="2.4.1 快速排序（基于链表）"></a>2.4.1 快速排序（基于链表）</h4><p>同样，借用之前定义的 <code>LinkedQueue</code> 类（链表实现的队列）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> LinkedQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">S: LinkedQueue</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于链表的快速排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(S)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># list is already sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># divide</span></span><br><span class="line">    p = S.first()  <span class="comment"># 取第一个值为划分基准</span></span><br><span class="line">    L = LinkedQueue()</span><br><span class="line">    E = LinkedQueue()</span><br><span class="line">    G = LinkedQueue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># divide S into L, E, and G</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> S.is_empty():</span><br><span class="line">        <span class="keyword">if</span> S.first() &lt; p:</span><br><span class="line">            L.enqueue(S.dequeue())</span><br><span class="line">        <span class="keyword">elif</span> p &lt; S.first():</span><br><span class="line">            G.enqueue(S.dequeue())</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># S.first() must equal pivot 等于基准值</span></span><br><span class="line">            E.enqueue(S.dequeue())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># conquer (with recursion) 递归排序</span></span><br><span class="line">    quick_sort(L)  <span class="comment"># sort elements less than p</span></span><br><span class="line">    quick_sort(G)  <span class="comment"># sort elements greater than p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># concatenate results 合并</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> L.is_empty():</span><br><span class="line">        S.enqueue(L.dequeue())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> E.is_empty():</span><br><span class="line">        S.enqueue(E.dequeue())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> G.is_empty():</span><br><span class="line">        S.enqueue(G.dequeue())</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    S = LinkedQueue()</span><br><span class="line">    S.from_list([<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Original List&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;After Sorted&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    quick_sort(S)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=============== Original <span class="type">List</span> ===============</span><br><span class="line">[<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line">=============== After Sorted ===============</span><br><span class="line">[<span class="number">17</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">96</span>]</span><br></pre></td></tr></table></figure><h4 id="2-4-2-就地快速排序"><a href="#2-4-2-就地快速排序" class="headerlink" title="2.4.2 就地快速排序"></a>2.4.2 就地快速排序</h4><p>快速排序的就地实现：在<strong>分割</strong>这一步骤，我们通过元素的交换，对序列重新进行排布，使得：</p><ul><li><p>比基准值小的元素排在第 h 位之前</p></li><li><p>与基准值相等的元素排在第 h 位到第 k 位之间</p></li><li>比基准值大的元素排在第 k 位之后</li></ul><p>然后，在【第 h 位之前的序列】和【第 k 位之后的序列】递归调用原方法。</p><p><strong>就地分割：</strong>在就地分割这一步骤，我们使用两个索引，将序列 S 分割为 L 和 E ∪ G。不断重复如下步骤，直到 j 与 k 相交：</p><ul><li>从左向右移动 j ，直到找到一个大于等于 x 的元素</li><li>从右向左移动 k ，直到找到一个小于 x 的元素</li><li>将 j 处和 k 处的元素交换</li></ul><p>如下图所示，取基准为 (x = 50) ，j 从左向右移动， k 从右向左移动，直到相交：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746417853659.png" alt="就地快速排序例子" style="zoom:50%;" /></p><p><strong>代码实现：</strong>下面基于数组（Python list 类）实现就地快速排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inplace_quick_sort</span>(<span class="params">S: <span class="built_in">list</span>, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;就地快速排序: 序列 S 从 S[a] 到 S[b]&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> a &gt;= b:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    pivot = S[b]  <span class="comment"># 取 S[b] 为基准</span></span><br><span class="line">    left = a  <span class="comment"># 从左向右</span></span><br><span class="line">    right = b - <span class="number">1</span>  <span class="comment"># 从右向左</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 直到相交</span></span><br><span class="line">        <span class="comment"># scan until reaching value equal or larger than pivot (or right marker)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> S[left] &lt; pivot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># scan until reaching value equal or smaller than pivot (or left marker)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> pivot &lt; S[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right:  <span class="comment"># 逆序, 则交换</span></span><br><span class="line">            S[left], S[right] = S[right], S[left]  <span class="comment"># swap values</span></span><br><span class="line">            left, right = left + <span class="number">1</span>, right - <span class="number">1</span>  <span class="comment"># 继续移动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># put pivot into its final place (currently marked by left index)</span></span><br><span class="line">    S[left], S[b] = S[b], S[left]  <span class="comment"># 将基准值放到中间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># make recursive calls 递归调用</span></span><br><span class="line">    inplace_quick_sort(S, a, left - <span class="number">1</span>)</span><br><span class="line">    inplace_quick_sort(S, left + <span class="number">1</span>, b)</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    S = [<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Original List&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;After Sorted&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    inplace_quick_sort(S, <span class="number">0</span>, <span class="built_in">len</span>(S) - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=============== Original <span class="type">List</span> ===============</span><br><span class="line">[<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line">=============== After Sorted ===============</span><br><span class="line">[<span class="number">17</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">96</span>]</span><br></pre></td></tr></table></figure><h3 id="2-5-算法分析"><a href="#2-5-算法分析" class="headerlink" title="2.5 算法分析"></a>2.5 算法分析</h3><h4 id="2-5-1-最坏情况-O-n-2"><a href="#2-5-1-最坏情况-O-n-2" class="headerlink" title="2.5.1 最坏情况 O(n^2)"></a>2.5.1 最坏情况 O(n^2)</h4><p>与归并排序不同，最坏情况下，快速排序效率不甚理想。最坏情况下，快速排序每一次选取的基准值都恰好为序列中唯一的最大值或最小值，这将导致：</p><ul><li>L 和 G 中一个长度为 n - 1，而另一个长度为 0</li><li>快速排序树高度为 n - 1 （即称为链式结构）</li><li>运行时间与 n + (n - 1) + … + 2 + 1 成正比</li></ul><p>因此，最坏情况下，快速排序的运行时间为 <strong>$O(n^2)$</strong> 。</p><h4 id="2-5-2-随机快速排序"><a href="#2-5-2-随机快速排序" class="headerlink" title="2.5.2 随机快速排序"></a>2.5.2 随机快速排序</h4><p>我们分析快速排序时，通常假设基准值总是能将序列以一种合理的方式进行分割，即最坏情况很少出现：</p><ul><li>实际上，我们可以通过<strong>随机快速排序</strong>使得快速排序运行的时间接近最好情况</li><li>随机快速排序中，我们每一次进行排序时均<strong>随机选择一个元素作为基准值</strong></li><li>在此情况下，我们可以计算快速排序的<strong>期望运行时间</strong></li></ul><p><strong>命题：一个大小 n 的序列 S ，其随机化快速排序的期望运行时间为 $O(n \log n)$ 。</strong></p><p><strong>证明：</strong>我们假设 S 中的两个元素可以在 O(1) 的时间内比较。考虑一个单独的随机化快速排序的递归调用，然后用 n 表示该调用的输入序列大小。如果基准值的选择使得每个子序列 L 和 G 均有至少 n/4 、至多 3n/4 的长度，我们可以称之“好”的选择，否则，我们称之为“坏”的选择。</p><p>容易证明，一次调用为“好”的概率为 1/2 ，为了得到一个“好”的调用，我们不得不进行的连续调用次数的期望为 2 。对于深度为 i 的节点，在期望意义下，有：</p><ul><li>其 i/2 的祖先节点处产生了“好”的调用</li><li>当前节点处序列的长度至多为 $(3/4)^{i/2}n$ </li></ul><p>因此，我们可以得到：</p><ul><li>深度为 $2 \log _{4/3} n$ 的节点的序列长度期望为 1</li><li>快速排序树的高度期望为 $O(\log n)$</li></ul><p>又因为，在同一深度上进行操作的期望时间为 O(n) ，因此，快速排序的期望运行时间为 $O(n \log n)$ 。</p><h2 id="3-排序算法"><a href="#3-排序算法" class="headerlink" title="3 排序算法"></a>3 排序算法</h2><h3 id="3-1-基于比较的排序算法"><a href="#3-1-基于比较的排序算法" class="headerlink" title="3.1 基于比较的排序算法"></a>3.1 基于比较的排序算法</h3><p>通过比较各个值的大小，来进行排序的算法有：选择排序、插入排序、冒泡排序、堆排序、归并排序和快速排序。其中堆排序、归并排序、快速排序为高级排序方法，可以达到 O(n log n) 的时间复杂度。具体使用见具体实际情况，可见下表：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746419102610.png" alt="基于比较的排序算法"></p><h3 id="3-2-排序下界"><a href="#3-2-排序下界" class="headerlink" title="3.2 排序下界"></a>3.2 排序下界</h3><p>我们可以注意到，相对高效的算法的时间复杂度均为 O(n log n) ，例如堆排序、快速排序、归并排序。是否有更快的排序方法？排序时间是否有下界？</p><p><strong>结论：</strong>对基于比较的排序算法，<strong>O(n log n) 是最好的结果</strong> 。</p><p><strong>证明：</strong>由于我们讨论的是排序下界，因此只计算进行的比较操作的次数：</p><ul><li>算法的每次可能的运行均可对应于一棵决策树（decision tree）</li><li>在每个节点处，根据比较的结果，排序算法进行不同的操作</li></ul><p>决策树的高度决定了排序算法运行时间的下界：</p><ul><li>对每一种可能的序列的排列（permutation），必须有唯一的一个叶子节点与之对应：否则，一个排列为 $\cdots,\ x_i,\ \cdots,\ x_j,\ \cdots$ 的序列与一个排列为 $\cdots,\ x_j,\ \cdots,\ x_i,\ \cdots$ 的序列的排序方法是完全一致的，这将导致其中的一个排序结果是错误的</li><li>叶子节点的数目为 n 个元素的排列数目，即 n!，因此决策树高度至少为 log(n!)</li></ul><p>根据性质：</p><script type="math/tex; mode=display">\log (n!) \geq \log \left( \frac{n}{2} \right)^{\frac{n}{2}} = \frac{n}{2} \log \left(\frac{n}{2}\right)</script><p>因此，任何基于比较的排序算法的运行时间下界为 $\Omega (n \log n)$</p><h3 id="3-3-线性时间排序"><a href="#3-3-线性时间排序" class="headerlink" title="3.3 线性时间排序"></a>3.3 线性时间排序</h3><h4 id="3-3-1-桶排序"><a href="#3-3-1-桶排序" class="headerlink" title="3.3.1 桶排序"></a>3.3.1 桶排序</h4><p>在序列元素有特殊形式的情况下，可以采用<strong>桶排序（bucket-sort）</strong></p><ul><li>假设序列 S 中有 n 个键值对，且键为 [0, N - 1] 内的整数</li><li>阶段 1 ：将序列 S 中的元素插入数组 B 中，具体方式为将元素 (k, v) 放入“桶” B[k] 中</li><li>阶段 2 ：按序枚举 B[0]，B[1]，…，B[N - 1]，将桶内的元素依次放回序列 S 中</li></ul><p>阶段 1 需要 O(n) 的时间，阶段 2 需要 O(N) 的时间。所以，桶排序的运行时间为 <strong>O(n + N)</strong> 。</p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Algorithm bucketSort(S):</span><br><span class="line">    Input: <span class="type">Sequence</span> S of entries <span class="keyword">with</span> integer keys <span class="keyword">in</span> the <span class="built_in">range</span> [<span class="number">0</span>, N − <span class="number">1</span>]</span><br><span class="line">    Output: <span class="type">Sequence</span> S <span class="built_in">sorted</span> <span class="keyword">in</span> nondecreasing order of the keys let B be an array of N sequences, each of which <span class="keyword">is</span> initially empty </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 阶段 1 : 将 (k, v) 插入 B[k]</span></span><br><span class="line">    <span class="keyword">for</span> each entry e <span class="keyword">in</span> S do</span><br><span class="line">        k = the key of e</span><br><span class="line">        remove e <span class="keyword">from</span> S <span class="keyword">and</span> insert e at the end of bucket B[k]</span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 阶段 2 : 按顺序返回 B[i]</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to N − <span class="number">1</span> do</span><br><span class="line">        <span class="keyword">for</span> each entry e <span class="keyword">in</span> B[i] do</span><br><span class="line">        remove e <span class="keyword">from</span> B[i] <span class="keyword">and</span> insert e at the end of S</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746435740322.png" alt="桶排序例子"></p><p>桶排序对键的要求：</p><ul><li>键被用作插入辅助数组的索引，因此对键的类型有所限制</li><li>不需要使用额外的比较器（comparator）进行比较操作</li></ul><h4 id="3-3-2-稳定排序"><a href="#3-3-2-稳定排序" class="headerlink" title="3.3.2 稳定排序"></a>3.3.2 稳定排序</h4><p><strong>稳定排序（stable sorting）：</strong>如果两个键相同的元素在排序前的顺序与排序后的顺序一致，则称此排序方法为稳定的。例如上图例子中 (3, a) (3, b) 的顺序没有改变。</p><ul><li>归并排序、桶排序是稳定排序算法</li></ul><h4 id="3-3-3-字典序排序"><a href="#3-3-3-字典序排序" class="headerlink" title="3.3.3 字典序排序"></a>3.3.3 字典序排序</h4><p>一个 d 元组为一个由 d 个键构成的序列 $(k_1,\ k_2,\ \cdots,\ k_d)$ ，其中键 $k_i$ 被称为此 d 元组的第 i 个维度。例如，三维空间中一个点的笛卡尔坐标为一个三元组 (x, y, z)</p><p>两个 d 元组的字典序顺序被递归定义为：</p><script type="math/tex; mode=display">(x_1,\ x_2,\ \cdots,\ x_d) < (y_1,\ y_2,\ \cdots,\ y_d)</script><script type="math/tex; mode=display">\Leftrightarrow</script><script type="math/tex; mode=display">x_1 \leq y_1 \quad \wedge \quad (x_2,\ x_3,\ \cdots,\ x_d) < (y_2,\ y_3,\ \cdots,\ y_d)</script><p>即 d 元组的比较过程为先比较第 1 维元素，如相等则再比较第 2 维，以此类推。</p><p>我们可以设计一个进行字典序排序的方法：</p><ul><li>假设对第 i 维，我们使用比较器 Ci 对其进行排序</li><li>假设我们找到了使用任意比较器 C 进行稳定排序的方法 stableSort(S, C)</li><li>字典序排序通过在对 d 元组的所有维度上依次进行稳定排序 stableSort 而完成</li><li>字典序排序的运行时间为 <strong>$O(d \cdot T(n))$</strong> ，其中 T(n) 为稳定排序 stableSort 的运行时间</li></ul><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Algorithm lexicographicSort(S)</span><br><span class="line">    Input sequence S of d-tuples</span><br><span class="line">    Output sequence S <span class="built_in">sorted</span> <span class="keyword">in</span> lexicographic order</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从后向前使用稳定排序</span></span><br><span class="line">    <span class="keyword">for</span> i = d down to <span class="number">1</span></span><br><span class="line">    stableSort(S, Ci)</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746436985090.png" alt="字典序排序的例子" style="zoom:67%;" /></p><h4 id="3-3-4-基数排序"><a href="#3-3-4-基数排序" class="headerlink" title="3.3.4 基数排序"></a>3.3.4 基数排序</h4><p><strong>基数排序（radix-sort）</strong>是一种特殊的字典序排序方式，它使用<strong>桶排序</strong>作为在每一维度上进行稳定排序的方式（即字典序排序中选择桶排序作为稳定排序的具体实现）：</p><ul><li>基数排序适用于每一维度上均为 [0, N - 1] 范围内的整数的 d 元组</li><li>基数排序的运行时间为 <strong>$O(d\cdot (n + N))$</strong> </li></ul><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Algorithm radixSort(S, N)</span><br><span class="line">    Input sequence S of d-tuples such that </span><br><span class="line">    (<span class="number">0</span>, ..., <span class="number">0</span>) &lt; (x1, ..., xd) </span><br><span class="line">        <span class="keyword">and</span> </span><br><span class="line">        (x1, ..., xd) &lt; (N − <span class="number">1</span>, …, N − <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> each <span class="built_in">tuple</span> (x1, ..., xd) <span class="keyword">in</span> S</span><br><span class="line">    Output sequence S <span class="built_in">sorted</span> <span class="keyword">in</span> lexicographic order</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从后向前使用桶排序</span></span><br><span class="line">    <span class="keyword">for</span> i = d down to <span class="number">1</span></span><br><span class="line">    bucketSort(Si, N)</span><br></pre></td></tr></table></figure><h2 id="4-排序算法的比较"><a href="#4-排序算法的比较" class="headerlink" title="4 排序算法的比较"></a>4 排序算法的比较</h2><h3 id="4-1-排序算法的比较"><a href="#4-1-排序算法的比较" class="headerlink" title="4.1 排序算法的比较"></a>4.1 排序算法的比较</h3><p>下面我们比较一些常见的排序算法：</p><p><strong>插入排序：</strong>如果情况好的话，插入排序的运行时间是 $O(n + m)$ ，其中 m 是逆序的数量（即无序元素对数目）。因此，插入排序是一种进行小序列排序的优秀算法（比如，少于50个元素），因为插入排序是很简单的程序，而且小序列最多只有几个逆序。但是插入排序在最坏情况仍然会达到 $O(n^2)$ 。</p><p><strong>堆排序：</strong>堆排序在最坏的情况下运行时间是 $O(n \log n)$ ，对于基于比较的排序方法是最佳的选择。当输入的数据可以适应主存时，堆排序很容易就地执行，并且在小或中型的序列上是一个理所当然的选择。但是对于超大数据，堆排序无法一次性读入内存，且堆排序不具有稳定排序的特点。</p><p><strong>快速排序：</strong>快速排序在最坏情况下的时间复杂度 $O(n^2)$ ，期望时间复杂度为 $O(n \log n)$ 。并且实验研究表明，在许多测试中它优于堆排序和归并排序，且快速排序提供就地排序。但由于分块步骤中存在元素交换，所以快速排序自然不能提供稳定的排疗。几十年来，快速排序是一种通用的内存排序算法的默认选择。</p><p><strong>归并排序：</strong>归并排序最坏情况下的运行时间为 $O(n \log n)$ 。不提供就地操作很难，并且对于分配临时数组的额外开销无法实现最优化，而且在数组之间复制相比堆排序的就地实现和可以在计算机主存中完全适合的对序列的快速排序而言没有优势。不过，归并排序因其可以分块处理的特点，更适合对于超大规模数据。</p><p><strong>桶排序和基数排序（特殊的字典序排序）：</strong>最后，如果一个应用程序用小的整型键、字符串或者来自离散范围的 d 元组键对条目进行排序，那么桶排序和基数排序是很好的选择，因为它的运行时间为 $O(d \cdot (n + N))$ 。其中，[0, N-1] 是整型键的范围。因此，如果 $d \cdot (n + N)$ 明显小于 $n \log n$ 的函数，那么这个分类方法要比快速排序、堆排序、归并排序更快。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1746419102610.png" alt="一些算法的比较总结"></p><h3 id="4-2-练习"><a href="#4-2-练习" class="headerlink" title="4.2 练习"></a>4.2 练习</h3><p>试讨论以下场景中应该使用何种排序算法？</p><ul><li>客户年消费额完整排序（百万级）：快速排序</li><li>客户等级分层（如top 10%、bottom 10%）：堆排序、快速排序（基准值取 x% &lt; p &lt; (1-x)% ）</li><li>将按时间顺序存储的账单按金额排序，要求金额相同的账单之间依然服从原来的时间顺序：归并排序（大数据）或者桶排序（小规模）</li><li>动态维护前 K 个活跃用户名单：堆排序</li><li>超大数据（存在不同磁盘中）进行排序：归并排序</li><li>商品 id 在 0000 - 9999 之间，按 id 进行排序：桶排序</li></ul><h2 id="5-选择"><a href="#5-选择" class="headerlink" title="5 选择"></a>5 选择</h2><p><strong>选择问题：</strong>从未排序的 n 个可比较元素中选择第 k 个最小的元素。</p><p>我们可以通过对集合进行排序然后在已排序序列的索引为 k - 1 的地方插入索引来解决这个问题。根据之前的排序算法，基于比较的排序，最快也要 O(n log n) 。下面，我们可以使用最好的比较排序算法，使得选择出这个第 k 小的元素的时间复杂度为 O(n) 。</p><h3 id="5-1-随机快速选择"><a href="#5-1-随机快速选择" class="headerlink" title="5.1 随机快速选择"></a>5.1 随机快速选择</h3><p><strong>随机快速选择</strong>的想法来源于快速排序，随机选取一个基准值，然后我们将序列分为 L E G 三部分，每次检查是否有子序列 L（当选第 k 小时） 的长度达到 k ，从而进入递归。</p><p>Python 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_select</span>(<span class="params">S, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回 S 中第 k 小的数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(S) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> S[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    pivot = random.choice(S)  <span class="comment"># 随机选取基准</span></span><br><span class="line">    <span class="comment"># 分为 3 个子序列</span></span><br><span class="line">    L = [x <span class="keyword">for</span> x <span class="keyword">in</span> S <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    E = [x <span class="keyword">for</span> x <span class="keyword">in</span> S <span class="keyword">if</span> x == pivot]</span><br><span class="line">    G = [x <span class="keyword">for</span> x <span class="keyword">in</span> S <span class="keyword">if</span> pivot &lt; x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(L):</span><br><span class="line">        <span class="keyword">return</span> quick_select(L, k)  <span class="comment"># k th smallest lies in L</span></span><br><span class="line">    <span class="keyword">elif</span> k &lt;= <span class="built_in">len</span>(L) + <span class="built_in">len</span>(E):</span><br><span class="line">        <span class="keyword">return</span> pivot  <span class="comment"># k th smallest equal to pivot</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        j = k - <span class="built_in">len</span>(L) - <span class="built_in">len</span>(E)  <span class="comment"># new selection parameter</span></span><br><span class="line">        <span class="keyword">return</span> quick_select(G, j)  <span class="comment"># k th smallest is jth in G</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    S = [<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Original List&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">f&quot;The <span class="subst">&#123;k&#125;</span>th smallest is&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    k_th = quick_select(S, k)</span><br><span class="line">    <span class="built_in">print</span>(k_th)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=============== Original <span class="type">List</span> ===============</span><br><span class="line">[<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line">=============== The 1th smallest <span class="keyword">is</span> ===============</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><h3 id="5-2-算法分析"><a href="#5-2-算法分析" class="headerlink" title="5.2 算法分析"></a>5.2 算法分析</h3><p><strong>命题：假设 S 的两个元素可以在 O(1) 时间内进行比较，大小为 n 的序列 S 的随机快速选择的预期运行时间是 E(t(n)) = O(n) 。</strong></p>]]></content>
    
    
    <summary type="html">本章详细介绍排序算法，包括：归并排序、快速排序、排序下界、桶排序、字典序排序的知识。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>搜索树（2）：伸展树、红黑树</title>
    <link href="https://blog.iskage.online/posts/eace6808.html"/>
    <id>https://blog.iskage.online/posts/eace6808.html</id>
    <published>2025-04-24T00:16:00.000Z</published>
    <updated>2025-04-24T08:57:29.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搜索树（2）：伸展树、红黑树"><a href="#搜索树（2）：伸展树、红黑树" class="headerlink" title="搜索树（2）：伸展树、红黑树"></a>搜索树（2）：伸展树、红黑树</h1><p>上一章介绍了常见的搜索树 <a href="https://zhuanlan.zhihu.com/p/1896957409303454453">二叉搜索树、平衡搜索树、AVL 树</a> ，它们的主要思想就是尽可能地使树保持平衡属性，高度维持在对数级别从而加快搜索。本章介绍的红黑树继承了这一思想，并进一步完善了一些缺点。除此之外，伸展树给出了新的思路，即完全不考虑树的结构，而是通过把最新访问的节点伸展到根节点来加快搜索。</p><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><h2 id="1-伸展树"><a href="#1-伸展树" class="headerlink" title="1 伸展树"></a>1 伸展树</h2><p>首先介绍相对简单的<strong>伸展树（splay tree）</strong>——与其他平衡搜索树有显著的不同</p><ul><li>伸展树的高度没有严格的对数上界</li><li>伸展树的节点处无需存储额外的高度、平衡或其他辅助信息</li></ul><p><strong>核心：</strong>在伸展树上进行搜索、插入、删除操作后，均需在到达的最后一个节点处进行<strong>伸展（splaying）</strong>操作。直观上，伸展操作使得被频繁操作的节点更靠近树根。</p><h3 id="1-1-伸展"><a href="#1-1-伸展" class="headerlink" title="1.1 伸展"></a>1.1 伸展</h3><p>对某一节点 x 的伸展操作即<strong>通过一系列重构将其移动到根节点</strong>的操作：</p><p>根据节点 x 是否有祖父节点及其与父节点及祖父节点（如存在）间的位置关系，可以采用 <code>zig-zig</code> 、 <code>zig-zag</code> 或 <code>zig</code>  重构：</p><ul><li><p>有祖父节点时执行 <code>zig-zig</code> 或 <code>zig-zag</code> （旋转 2 次）</p></li><li><p>没有祖父节点时执行 <code>zig</code> （旋转 1 次）</p></li></ul><h4 id="1-1-1-zig-zig-型"><a href="#1-1-1-zig-zig-型" class="headerlink" title="1.1.1 zig-zig 型"></a>1.1.1 zig-zig 型</h4><p>zig-zig 型伸展操作：如下图所示，旋转 2 次从而将节点 x 旋转到根节点位置。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745397643877.png" alt="zig-zig 型伸展操作"></p><h4 id="1-1-2-zig-zag-型"><a href="#1-1-2-zig-zag-型" class="headerlink" title="1.1.2 zig-zag 型"></a>1.1.2 zig-zag 型</h4><p>zig-zag 型伸展操作：如下图所示，旋转 2 次从而将节点 x 旋转到根节点位置。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745397705908.png" alt="zig-zag 型伸展操作"></p><h4 id="1-1-3-zig-型"><a href="#1-1-3-zig-型" class="headerlink" title="1.1.3 zig 型"></a>1.1.3 zig 型</h4><p>zig 型伸展操作：如下图所示，旋转 1 次从而将节点 x 旋转到根节点位置。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745397728408.png" alt="zig 型伸展操作"></p><h3 id="1-2-伸展树的操作和伸展"><a href="#1-2-伸展树的操作和伸展" class="headerlink" title="1.2 伸展树的操作和伸展"></a>1.2 伸展树的操作和伸展</h3><h4 id="1-2-1-搜索-查看"><a href="#1-2-1-搜索-查看" class="headerlink" title="1.2.1 搜索/查看"></a>1.2.1 搜索/查看</h4><p>搜索键 k 时，如果发现键 k 在位置 p ，则伸展 p；否则，在搜索失败的位置伸展叶子节点。</p><p>下面的例子展示了一个节点的完整伸展过程：查找到了节点 14 ，伸展 14 一直旋转到根节点。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745397996477.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745398031958.png" alt=""></p><h4 id="1-2-2-插入"><a href="#1-2-2-插入" class="headerlink" title="1.2.2 插入"></a>1.2.2 插入</h4><p>插入键 k 时，在新插入的叶子节点 p 处进行伸展。</p><p>例如上面的节点 14 即可以是查找到了 14 伸展 14 ，也可以是插入 14 然后伸展 14 。下面的例子展示了一个从零搭建伸展树的插入过程。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745398267629.png" alt="从零搭建伸展树"></p><h4 id="1-2-3-删除"><a href="#1-2-3-删除" class="headerlink" title="1.2.3 删除"></a>1.2.3 删除</h4><p>删除键 k 时，在被删除节点的父节点 p 处进行伸展。需要注意的是，如果删除的是度为 2 的节点，则实际上是替换后再删除。则此时伸展的是实际被删除的节点的父节点。</p><p>例如下图所示，删除的是度为 2 的节点 8 ，但实际上是用其（中序遍历的）前一个节点替换后，删除前一个节点 w = 7 ，所以在 w = 7 的父节点 p = 6 处进行伸展。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745398384145.png" alt="删除根节点 8 的例子"></p><h3 id="1-3-Python-实现"><a href="#1-3-Python-实现" class="headerlink" title="1.3 Python 实现"></a>1.3 Python 实现</h3><p>继承上一章的 <code>TreeMap</code> 类（<a href="https://github.com/isKage/dsa-notes/blob/main/lec10_search_tree/utils/tree_map.py">TreeMap 的完整代码</a>）。因为伸展树无需存储多余信息，所以不用覆写节点类。最后，伸展树不再需要平衡操作，所有增、删、改、查操作后的平衡操作改为伸展操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .tree_map <span class="keyword">import</span> TreeMap</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> tree_map <span class="keyword">import</span> TreeMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SplayTreeMap</span>(<span class="title class_ inherited__">TreeMap</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;伸展树&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------ 不用覆写节点类 ------------</span></span><br><span class="line">    <span class="comment"># 因为伸展树无需存储多余信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------ 伸展树操作 ------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_splay</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在 p 点进行伸展，将 p 旋转到根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> p != <span class="variable language_">self</span>.root() <span class="keyword">and</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            parent = <span class="variable language_">self</span>.parent(p)</span><br><span class="line">            grand = <span class="variable language_">self</span>.parent(parent)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grand <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># zig 型，旋转 1 次</span></span><br><span class="line">                <span class="variable language_">self</span>._rotate(p)</span><br><span class="line">            <span class="keyword">elif</span> (parent == <span class="variable language_">self</span>.left(grand)) == (p == <span class="variable language_">self</span>.left(parent)):</span><br><span class="line">                <span class="comment"># zig-zig 型，在同一边，旋转 2 次</span></span><br><span class="line">                <span class="variable language_">self</span>._rotate(parent)</span><br><span class="line">                <span class="variable language_">self</span>._rotate(p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># zig-zag 型，在不同边，旋转 2 次</span></span><br><span class="line">                <span class="variable language_">self</span>._rotate(p)</span><br><span class="line">                <span class="variable language_">self</span>._rotate(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------ 覆写平衡操作的钩子函数 ------------</span></span><br><span class="line">    <span class="comment"># 伸展树不再需要平衡操作，所有增删改查操作后进行伸展即可</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_access</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="variable language_">self</span>._splay(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_delete</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="variable language_">self</span>._splay(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_insert</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="variable language_">self</span>._splay(p)</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;=============== Splay Tree Map ===============&quot;&quot;&quot;</span></span><br><span class="line">splay_tree = SplayTreeMap()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Splay Tree Map&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">splay_tree[<span class="number">1</span>] = <span class="string">&#x27;splay1&#x27;</span></span><br><span class="line">splay_tree[<span class="number">2</span>] = <span class="string">&#x27;splay2&#x27;</span></span><br><span class="line">splay_tree[<span class="number">3</span>] = <span class="string">&#x27;splay3&#x27;</span></span><br><span class="line">splay_tree[<span class="number">4</span>] = <span class="string">&#x27;splay4&#x27;</span></span><br><span class="line">splay_tree[<span class="number">5</span>] = <span class="string">&#x27;splay5&#x27;</span></span><br><span class="line">splay_tree[<span class="number">6</span>] = <span class="string">&#x27;splay6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;key = 4, value = <span class="subst">&#123;splay_tree[<span class="number">4</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;from 1 to 4&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> splay_tree.find_range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nmin = <span class="subst">&#123;splay_tree.find_min()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;del key = 1 and 2&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> splay_tree[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">del</span> splay_tree[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;min = <span class="subst">&#123;splay_tree.find_min()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== Splay Tree Map ===============</span></span><br><span class="line"><span class="comment"># key = 4, value = splay4</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># from 1 to 4</span></span><br><span class="line"><span class="comment"># (1, &#x27;splay1&#x27;)</span></span><br><span class="line"><span class="comment"># (2, &#x27;splay2&#x27;)</span></span><br><span class="line"><span class="comment"># (3, &#x27;splay3&#x27;)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># min = (1, &#x27;splay1&#x27;)</span></span><br><span class="line"><span class="comment"># del key = 1 and 2</span></span><br><span class="line"><span class="comment"># min = (3, &#x27;splay3&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="1-4-算法分析-性能"><a href="#1-4-算法分析-性能" class="headerlink" title="1.4 算法分析/性能"></a>1.4 算法分析/性能</h3><p>伸展操作的摊销运行时间为 <strong>O(log n)</strong> ，故搜索、插入、删除的摊销运行时间也为 <strong>O(log n)</strong> 。</p><p>优势：</p><ul><li><p>无需在节点处存储额外信息，且操作简单。</p></li><li><p>某些情况下运行时间远小于 <strong>O(log n)</strong> ，如当操作经常被操作的节点时。</p></li></ul><h2 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2 红黑树"></a>2 红黑树</h2><p>红黑树依旧继承了“平衡”的思想，但是避免了多次旋转重构的——<strong>红黑树只需要 O(1) 次结构变化就能保持平衡</strong>。</p><h3 id="2-1-红黑树"><a href="#2-1-红黑树" class="headerlink" title="2.1 红黑树"></a>2.1 红黑树</h3><p>从形式上讲，<strong>红黑树</strong>是一棵带有红色和黑色节点的二叉搜索树（不妨设：左小右大），可以理解为一个涂上了“红色”和“黑色”的二叉搜索树，其具有下面的属性：</p><ul><li>根属性：根节点是黑色的。</li><li>红色属性：红色节点（如果有的话）的子节点是黑色的。</li><li>深度属性：具有零个或一个子节点的所有节点都具有相同的黑色深度（被定义为黑色祖先节点的数量）—— 即叶子节点和度为 1 的节点具有同样多的黑色祖先节点数目。</li></ul><p>例如下面的例子（白色代表“红色”）：根节点 12 是黑色的，所有红色节点的子节点都是黑色的（例如节点 10）。叶子节点（4、8、6、14）的黑色祖先数目为 3 ，而叶子节点（11、17）的黑色祖先树也为 3 （定义自己是自己的祖先），度为 1 的节点（3、13）的黑色祖先数目也为 3 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745402114180.png" alt="红黑树的一个例子" style="zoom:50%;" /></p><p><strong>性质：</strong>对于 n 个节点的红黑树，其高度为 <strong>O(log n)</strong>。</p><h3 id="2-2-红黑树的操作"><a href="#2-2-红黑树的操作" class="headerlink" title="2.2 红黑树的操作"></a>2.2 红黑树的操作</h3><h4 id="2-2-1-搜索-查看"><a href="#2-2-1-搜索-查看" class="headerlink" title="2.2.1 搜索/查看"></a>2.2.1 搜索/查看</h4><p>红黑树同时也是二叉搜索树，采用相同的方式查找，因此复杂度为 <strong>O(h) = O(log n)</strong> 。</p><h4 id="2-2-2-插入"><a href="#2-2-2-插入" class="headerlink" title="2.2.2 插入"></a>2.2.2 插入</h4><p>考虑将 x 插入树 T 中：</p><ol><li><p>如果 T 只有 1 个节点，则 x 插入在根节点的下面，将根节点染为黑色，于是满足根属性；</p></li><li><p>如果 x 的父节点不是根节点，则将 x 染为红色，则深度属性满足（因为 x 红色不会计算自身黑色深度）：</p><ul><li>如果 x 的父节点是黑色，则红色属性不违背；</li><li>但当 x 的父节点是红色，由红色属性知产生矛盾！</li></ul></li></ol><p>对于最后一种特殊情况，我们进一步考虑：此时 x 为红色，x 的父节点 y 为红色，则 y 的父节点一定为黑色（否则 y、z 违背红色属性）。此时的情况称为 <strong>双红色</strong> 矛盾：</p><div class="table-container"><table><thead><tr><th style="text-align:center">z (grand)</th><th style="text-align:center">y (parent)</th><th style="text-align:center">x (child)</th></tr></thead><tbody><tr><td style="text-align:center">黑色</td><td style="text-align:center">红色</td><td style="text-align:center">红色</td></tr></tbody></table></div><p> <strong>双红色</strong>矛盾： <code>z -&gt; y -&gt; x</code> 的 x 和 y 都为红色，矛盾。</p><p><strong>情况 1：y 的兄弟姐妹节点 s 为黑色或空</strong></p><p>对节点 x 进行 trinode 重构操作 <code>restructure(x)</code> ：</p><ul><li>对节点 x ，其父节点 y 和祖先节点 z ，按照从左到右的顺序，暂时重新标记它们为 a 、b 和 c ，以使 a 、 b 和 c 被有序地遍历（a &lt; b &lt; c）。</li><li>将祖先节点 z 用标记节点 b 取代，使 a 和 c 成为 b 的子节点，并保持次序关系不变。</li></ul><p>在进行 <code>restructure(x)</code> 的操作后，我们将 b 着色为黑色，将 a 和 c 着色红色。即将三个键从小到大排序为 a &lt; b &lt; c 按照 b 为根，a 在左， c 在右的方式重新构建树，并把 b 染为黑，a、c 染为红。</p><p>如下图所示：a) 图展示了 4 中可能情况，经过重构后变为 b) 图的情况。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745403817572.png" alt=""></p><p><strong>情况 2：y 的兄弟姐妹节点 s 为红色</strong></p><p>重新着色：将 y 和 s 着色为黑色，将其父节点 z 着色为红色（除非z是根节点，在这种情况下，<br>它仍然是黑色的）。</p><p>如此，除非 z 是根节点，通过该树的有影响的部分的任何路径部分恰好是一个黑色节点，无论着色前和着色后。因此，树的黑色深度不被重新着色影响。在 z 是根节点情况下，它增加 1 。</p><p>如此双红色矛盾或消失，或转移到 x 的祖父节点 z 上，不断重复进行情况 1 和情况 2 ，总能收敛解决矛盾。</p><p>如下图所示：将 z 染红，子节点 y 和 s 染黑即可，然后检查，重复操作即可。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745404175639.png" alt=""></p><h4 id="2-2-3-删除"><a href="#2-2-3-删除" class="headerlink" title="2.2.3 删除"></a>2.2.3 删除</h4><p>删除同样与二叉搜索树相同，只是造成的不平衡情况需要的操作方式不同：</p><ol><li>如果删除的是红色节点，不影响红黑树结构；</li><li>如果删除的是黑色节点，它要么是叶子节点；要么只有一个子节点，且这个子节点一定是红色的叶子节点（否则这条路径上的度为 1 和叶子节点的黑色深度肯定矛盾）：<ul><li>对于第二种情况，即它有一个红色的叶子节点，只需将其接到祖父节点并染为黑色即可。</li><li>对于第一种情况，即删除的是一个黑色的叶子节点，则它的父节点变成了度为 1 或 0 的节点，其黑色深度减一，深度属性矛盾，需要特殊考虑。</li></ul></li></ol><p>如果删除的是一个（非根节点的）黑色叶子节点。可以采用如下操作：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745405126928.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745405176279.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745405202122.png" alt=""></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745405236407.png" alt=""></p><p>具体的例子：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745405282590.png" alt=""></p><h3 id="2-3-算法分析-性能"><a href="#2-3-算法分析-性能" class="headerlink" title="2.3 算法分析/性能"></a>2.3 算法分析/性能</h3><p><strong>性质：</strong>在一棵 n 个节点的红黑树中插入一项可在 <strong>O(log n)</strong> 的时间内完成，并且需要 <strong>O(log n)</strong> 的重新着色且至多需要 <strong>1</strong> 次的 trinode 重组。</p><p><strong>性质：</strong>在一棵 n 个节点的红黑树中删除一项可在 <strong>O(log n)</strong> 的时间内完成，并且需要 <strong>O(log n)</strong> 的重新着色且至多需要 <strong>2</strong> 次的 trinode 重组。</p><h3 id="2-4-Python-实现"><a href="#2-4-Python-实现" class="headerlink" title="2.4 Python 实现"></a>2.4 Python 实现</h3><p>同样继承自 <code>TreeMap</code> 类，需要覆写节点类 <code>_Node</code> ，添加红黑属性 <code>_red: bool</code> 。且需要重新定义“平衡”操作的钩子函数 <code>_rebalance_insert()</code> 和 <code>_rebalance_delete()</code> 操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .tree_map <span class="keyword">import</span> TreeMap</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> tree_map <span class="keyword">import</span> TreeMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTreeMap</span>(<span class="title class_ inherited__">TreeMap</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;红黑树&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 覆写节点类：添加红黑属性 ---------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Node</span>(TreeMap._Node):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加红黑属性&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_red&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, element, parent=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">            <span class="built_in">super</span>().__init__(element, parent, left, right)</span><br><span class="line">            <span class="variable language_">self</span>._red = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 红黑属性操作 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_set_red</span>(<span class="params">self, p</span>):</span><br><span class="line">        p._node._red = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_set_black</span>(<span class="params">self, p</span>):</span><br><span class="line">        p._node._red = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_set_color</span>(<span class="params">self, p, make_red</span>):</span><br><span class="line">        p._node._red = make_red</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_red</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> p._node._red</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_red_leaf</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._is_red(p) <span class="keyword">and</span> <span class="variable language_">self</span>.is_leaf(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_red_child</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回 p 的红子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> (<span class="variable language_">self</span>.left(p), <span class="variable language_">self</span>.right(p)):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._is_red(child):</span><br><span class="line">                <span class="keyword">return</span> child</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 插入 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_insert</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;覆写插入后的平衡操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._resolve_red(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_resolve_red</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;插入新元素后的平衡重构&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_root(p):</span><br><span class="line">            <span class="variable language_">self</span>._set_black(p)  <span class="comment"># 根节点为黑</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parent = <span class="variable language_">self</span>.parent(p)</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._is_red(parent):  <span class="comment"># 双红矛盾</span></span><br><span class="line">                uncle = <span class="variable language_">self</span>.sibling(p)</span><br><span class="line">                <span class="comment"># 情况 1: x 的父节点 y 的兄弟姐妹节点 s 为黑色或空</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._is_red(uncle):</span><br><span class="line">                    middle = <span class="variable language_">self</span>._restructure(p)  <span class="comment"># trinode 重构</span></span><br><span class="line">                    <span class="variable language_">self</span>._set_black(middle)</span><br><span class="line">                    <span class="variable language_">self</span>._set_red(<span class="variable language_">self</span>.left(middle))</span><br><span class="line">                    <span class="variable language_">self</span>._set_red(<span class="variable language_">self</span>.right(middle))</span><br><span class="line">                <span class="comment"># 情况 2: x 的父节点 y 的兄弟姐妹节点 s 为红色</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grand = <span class="variable language_">self</span>.parent(parent)</span><br><span class="line">                    <span class="variable language_">self</span>._set_red(grand)</span><br><span class="line">                    <span class="variable language_">self</span>._set_black(<span class="variable language_">self</span>.left(grand))</span><br><span class="line">                    <span class="variable language_">self</span>._set_black(<span class="variable language_">self</span>.right(grand))</span><br><span class="line">                    <span class="variable language_">self</span>._resolve_red(grand)  <span class="comment"># 染色后递归</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 删除 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_delete</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        覆写删除后的平衡操作</span></span><br><span class="line"><span class="string">        :param p: 父类 TreeMap 的 delete(p) 方法传入的是父节点 p.parent</span></span><br><span class="line"><span class="string">        所以父节点 n == 1 代表删除的是叶子节点，对于黑色叶子节点需要特殊考虑 _fix_deficit</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 根节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>) == <span class="number">1</span>:</span><br><span class="line">            <span class="variable language_">self</span>._set_black(<span class="variable language_">self</span>.root())  <span class="comment"># 根节点为黑</span></span><br><span class="line">        <span class="keyword">elif</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            n = <span class="variable language_">self</span>.num_children(p)</span><br><span class="line">            <span class="comment"># 2. 度为 1</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                c = <span class="built_in">next</span>(<span class="variable language_">self</span>.children(p))</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._is_red_leaf(c):  <span class="comment"># 黑色叶子节点被删除</span></span><br><span class="line">                    <span class="variable language_">self</span>._fix_deficit(p, c)</span><br><span class="line">            <span class="comment"># 3. 度为 2</span></span><br><span class="line">            <span class="keyword">elif</span> n == <span class="number">2</span>:  <span class="comment"># 被删除的点的父节点度为 2 只要重新染色即可</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._is_red_leaf(<span class="variable language_">self</span>.left(p)):</span><br><span class="line">                    <span class="variable language_">self</span>._set_black(<span class="variable language_">self</span>.left(p))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="variable language_">self</span>._set_black(<span class="variable language_">self</span>.right(p))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 度为 0 即黑色叶子节点为特殊情况，见函数 _fix_deficit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_fix_deficit</span>(<span class="params">self, z, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;z 为父节点，y 为更重子树的子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._is_red(y):  <span class="comment"># y 为黑，情形 1 和 2</span></span><br><span class="line">            x = <span class="variable language_">self</span>._get_red_child(y)</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 情形 1</span></span><br><span class="line">                old_color = <span class="variable language_">self</span>._is_red(z)</span><br><span class="line">                middle = <span class="variable language_">self</span>._restructure(x)</span><br><span class="line">                <span class="variable language_">self</span>._set_color(middle, old_color)</span><br><span class="line">                <span class="variable language_">self</span>._set_black(<span class="variable language_">self</span>.left(middle))</span><br><span class="line">                <span class="variable language_">self</span>._set_black(<span class="variable language_">self</span>.right(middle))</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 情形 2</span></span><br><span class="line">                <span class="variable language_">self</span>._set_red(y)</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._is_red(z):</span><br><span class="line">                    <span class="variable language_">self</span>._set_black(z)</span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_root(z):</span><br><span class="line">                    <span class="variable language_">self</span>._fix_deficit(<span class="variable language_">self</span>.parent(z), <span class="variable language_">self</span>.sibling(z))  <span class="comment"># 递归</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 情形 3: y 为红</span></span><br><span class="line">            <span class="variable language_">self</span>._rotate(y)</span><br><span class="line">            <span class="variable language_">self</span>._set_black(y)</span><br><span class="line">            <span class="variable language_">self</span>._set_red(z)</span><br><span class="line">            <span class="keyword">if</span> z == <span class="variable language_">self</span>.right(y):</span><br><span class="line">                <span class="variable language_">self</span>._fix_deficit(z, <span class="variable language_">self</span>.left(z))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>._fix_deficit(z, <span class="variable language_">self</span>.right(z))</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> RedBlackTreeMap</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;=============== Red Black Tree Map ===============&quot;&quot;&quot;</span></span><br><span class="line">red_black_tree = RedBlackTreeMap()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Red Black Tree Map&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">red_black_tree[<span class="number">1</span>] = <span class="string">&#x27;redblack1&#x27;</span></span><br><span class="line">red_black_tree[<span class="number">2</span>] = <span class="string">&#x27;redblack2&#x27;</span></span><br><span class="line">red_black_tree[<span class="number">3</span>] = <span class="string">&#x27;redblack3&#x27;</span></span><br><span class="line">red_black_tree[<span class="number">4</span>] = <span class="string">&#x27;redblack4&#x27;</span></span><br><span class="line">red_black_tree[<span class="number">5</span>] = <span class="string">&#x27;redblack5&#x27;</span></span><br><span class="line">red_black_tree[<span class="number">6</span>] = <span class="string">&#x27;redblack6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;key = 4, value = <span class="subst">&#123;red_black_tree[<span class="number">4</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;from 1 to 4&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> red_black_tree.find_range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nmin = <span class="subst">&#123;red_black_tree.find_min()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;del key = 1 and 2&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> red_black_tree[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">del</span> red_black_tree[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;min = <span class="subst">&#123;red_black_tree.find_min()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== Red Black Tree Map ===============</span></span><br><span class="line"><span class="comment"># key = 4, value = redblack4</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># from 1 to 4</span></span><br><span class="line"><span class="comment"># (1, &#x27;redblack1&#x27;)</span></span><br><span class="line"><span class="comment"># (2, &#x27;redblack2&#x27;)</span></span><br><span class="line"><span class="comment"># (3, &#x27;redblack3&#x27;)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># min = (1, &#x27;redblack1&#x27;)</span></span><br><span class="line"><span class="comment"># del key = 1 and 2</span></span><br><span class="line"><span class="comment"># min = (3, &#x27;redblack3&#x27;)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本章介绍的红黑树继承了这一思想，并进一步完善了一些缺点。除此之外，伸展树给出了新的思路，即完全不考虑树的结构，而是通过把最新访问的节点伸展到根节点来加快搜索。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>统计软件 R 语言学习笔记 (10) 回归分析：多元线性回归</title>
    <link href="https://blog.iskage.online/posts/33bad3cb.html"/>
    <id>https://blog.iskage.online/posts/33bad3cb.html</id>
    <published>2025-04-23T06:44:00.000Z</published>
    <updated>2025-04-24T08:57:29.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回归分析：多元线性回归"><a href="#回归分析：多元线性回归" class="headerlink" title="回归分析：多元线性回归"></a>回归分析：多元线性回归</h1><p>本章介绍多元线性回归的 R 语言实现，包括模型搭建、变量选择、多重共线性和模型预测和诊断。</p><p>代码和笔记存储在 <a href="https://github.com/iskage/r-notes">GitHub 库</a> <strong>【持续更新中，建议 star！】</strong></p><h2 id="1-多元线性回归模型"><a href="#1-多元线性回归模型" class="headerlink" title="1 多元线性回归模型"></a>1 多元线性回归模型</h2><h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h3><p><strong>模型：</strong></p><script type="math/tex; mode=display">y_i = \beta_0 + \beta_1\cdot x_{i1} + \cdots + \beta_p \cdot x_{ip} + \epsilon_i,\quad i = 1,\ 2,\ \cdots,\ n</script><p><strong>误差项的假设：</strong></p><script type="math/tex; mode=display">\epsilon_i \sim_{i.i.d} N(0,\ \sigma^2)</script><p><strong>拟合值：</strong></p><script type="math/tex; mode=display">\hat{y_i} = \hat{\beta_0} + \hat{\beta_1}\cdot x_{i1} + \cdots + \hat{\beta_p} \cdot x_{ip},\quad i = 1,\ 2,\ \cdots,\ n</script><p>使用<strong>最小二乘法：</strong></p><script type="math/tex; mode=display">\min_{\beta_j}\ \sum\limits_{i=1}^n\ (y_i - \hat{y_i})^2,\quad j = 0,\ 1,\ \cdots,\ p</script><h3 id="1-2-R-语言实现"><a href="#1-2-R-语言实现" class="headerlink" title="1.2 R 语言实现"></a>1.2 R 语言实现</h3><p>数据准备：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">101.8</span><span class="punctuation">,</span> <span class="number">44.4</span><span class="punctuation">,</span> <span class="number">108.3</span><span class="punctuation">,</span> <span class="number">85.1</span><span class="punctuation">,</span> <span class="number">77.1</span><span class="punctuation">,</span> <span class="number">158.7</span><span class="punctuation">,</span> <span class="number">180.4</span><span class="punctuation">,</span> <span class="number">64.2</span><span class="punctuation">,</span> <span class="number">74.6</span><span class="punctuation">,</span> <span class="number">143.4</span><span class="punctuation">,</span> <span class="number">120.6</span><span class="punctuation">,</span> <span class="number">69.7</span><span class="punctuation">,</span> <span class="number">67.8</span><span class="punctuation">,</span> <span class="number">106.7</span><span class="punctuation">,</span> <span class="number">119.6</span><span class="punctuation">)</span> <span class="comment"># nolint</span></span><br><span class="line">X1 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1.3</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">1.4</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">1.9</span><span class="punctuation">,</span> <span class="number">1.2</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">1.3</span><span class="punctuation">,</span> <span class="number">1.6</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">1.1</span><span class="punctuation">)</span> <span class="comment"># nolint</span></span><br><span class="line">X2 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.3</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">0.3</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.3</span><span class="punctuation">)</span> <span class="comment"># nolint</span></span><br><span class="line">X3 <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">20.4</span><span class="punctuation">,</span> <span class="number">30.5</span><span class="punctuation">,</span> <span class="number">24.6</span><span class="punctuation">,</span> <span class="number">19.6</span><span class="punctuation">,</span> <span class="number">25.5</span><span class="punctuation">,</span> <span class="number">21.7</span><span class="punctuation">,</span> <span class="number">6.8</span><span class="punctuation">,</span> <span class="number">12.6</span><span class="punctuation">,</span> <span class="number">31.3</span><span class="punctuation">,</span> <span class="number">18.6</span><span class="punctuation">,</span> <span class="number">19.9</span><span class="punctuation">,</span> <span class="number">25.6</span><span class="punctuation">,</span> <span class="number">27.4</span><span class="punctuation">,</span> <span class="number">24.3</span><span class="punctuation">,</span> <span class="number">13.7</span><span class="punctuation">)</span> <span class="comment"># nolint</span></span><br><span class="line">CountryKitchen <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>Sales <span class="operator">=</span> Y<span class="punctuation">,</span> Advertisement <span class="operator">=</span> X1<span class="punctuation">,</span> Promotion <span class="operator">=</span> X2<span class="punctuation">,</span> Competitor <span class="operator">=</span> X3<span class="punctuation">)</span> <span class="comment"># nolint</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 数据的相关性</span></span><br><span class="line"><span class="operator">&gt;</span> cor<span class="punctuation">(</span>CountryKitchen<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> plot<span class="punctuation">(</span>CountryKitchen<span class="punctuation">)</span> <span class="comment"># 绘图</span></span><br><span class="line">                   Sales Advertisement  Promotion Competitor</span><br><span class="line">Sales          <span class="number">1.0000000</span>     <span class="number">0.7076926</span>  <span class="number">0.6123033</span> <span class="operator">-</span><span class="number">0.6248346</span></span><br><span class="line">Advertisement  <span class="number">0.7076926</span>     <span class="number">1.0000000</span>  <span class="number">0.1613351</span> <span class="operator">-</span><span class="number">0.2131088</span></span><br><span class="line">Promotion      <span class="number">0.6123033</span>     <span class="number">0.1613351</span>  <span class="number">1.0000000</span> <span class="operator">-</span><span class="number">0.4939321</span></span><br><span class="line">Competitor    <span class="operator">-</span><span class="number">0.6248346</span>    <span class="operator">-</span><span class="number">0.2131088</span> <span class="operator">-</span><span class="number">0.4939321</span>  <span class="number">1.0000000</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/cor_plot.png" alt=""></p><p>回归分析：（4 种方法）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回归分析</span></span><br><span class="line"><span class="comment">## method 1</span></span><br><span class="line">result1 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X3<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result1<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## method 2</span></span><br><span class="line">X <span class="operator">&lt;-</span> cbind<span class="punctuation">(</span>X1<span class="punctuation">,</span> X2<span class="punctuation">,</span> X3<span class="punctuation">)</span></span><br><span class="line">result2 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Y <span class="operator">~</span> X<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result2<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## method 3</span></span><br><span class="line">result3 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Sales <span class="operator">~</span> Advertisement <span class="operator">+</span> Promotion <span class="operator">+</span> Competitor<span class="punctuation">,</span> data <span class="operator">=</span> CountryKitchen<span class="punctuation">)</span> <span class="comment"># nolint</span></span><br><span class="line">summary<span class="punctuation">(</span>result3<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## method 4</span></span><br><span class="line">result4 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Sales <span class="operator">~</span> .<span class="punctuation">,</span> data <span class="operator">=</span> CountryKitchen<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result4<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>最终结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> Sales <span class="operator">~</span> Advertisement <span class="operator">+</span> Promotion <span class="operator">+</span> Competitor<span class="punctuation">,</span> </span><br><span class="line">    data <span class="operator">=</span> CountryKitchen<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">34.625</span>  <span class="operator">-</span><span class="number">6.750</span>   <span class="number">1.335</span>   <span class="number">8.030</span>  <span class="number">26.435</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">              Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>    <span class="number">65.7046</span>    <span class="number">27.7311</span>   <span class="number">2.369</span> <span class="number">0.037195</span> <span class="operator">*</span>  </span><br><span class="line">Advertisement  <span class="number">48.9788</span>    <span class="number">10.6579</span>   <span class="number">4.596</span> <span class="number">0.000771</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Promotion      <span class="number">59.6543</span>    <span class="number">23.6247</span>   <span class="number">2.525</span> <span class="number">0.028219</span> <span class="operator">*</span>  </span><br><span class="line">Competitor     <span class="operator">-</span><span class="number">1.8376</span>     <span class="number">0.8138</span>  <span class="operator">-</span><span class="number">2.258</span> <span class="number">0.045233</span> <span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">17.6</span> on <span class="number">11</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.833</span><span class="punctuation">,</span>     Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.7875</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">18.29</span> on <span class="number">3</span> and <span class="number">11</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">0.0001388</span></span><br></pre></td></tr></table></figure><h3 id="1-3-R-结果分析"><a href="#1-3-R-结果分析" class="headerlink" title="1.3 R 结果分析"></a>1.3 R 结果分析</h3><p><strong>参数估计：</strong> <code>Residual standard error: 17.6</code> 代表了</p><script type="math/tex; mode=display">\hat{\sigma} = 17.6</script><p><strong>参数估计：</strong> <code>Estimate</code> 代表了</p><script type="math/tex; mode=display">\begin{align}\hat{\beta_0} &= 65.7046 \\\hat{\beta_1} &= 48.9788 \\\hat{\beta_2} &= 59.6543 \\\hat{\beta_3} &= -1.8376 \\\end{align}</script><p><strong>显著性检验：</strong> <code>Signif. codes</code> 和 <code>Pr(&gt;|t|)</code></p><script type="math/tex; mode=display">\frac{\hat{\beta_j} - \beta_j}{\hat{\sigma}_j} \sim t\ (n-p-1)</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Advertisement<span class="operator">:</span> Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span> <span class="operator">=</span> <span class="number">0.000771</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> 显著</span><br></pre></td></tr></table></figure><p>针对的假设检验：</p><script type="math/tex; mode=display">H_0: \beta_j = 0\quad vs\quad H_1: \beta_j \neq 0</script><p><strong>模型显著性检查：</strong> </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">18.29</span> on <span class="number">3</span> and <span class="number">11</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">0.0001388</span></span><br><span class="line"><span class="comment"># =====</span></span><br><span class="line">所以 p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">0.0001388</span> <span class="operator">&lt;</span> <span class="number">0.05</span> 拒绝原假设，模型显著</span><br></pre></td></tr></table></figure><p>针对的假设检验：</p><script type="math/tex; mode=display">H_0: \beta_1 = \beta_2 =\cdots = \beta_p = 0\quad vs\quad H_1: \text{至少存在一个 } \beta_j \neq 0</script><h2 id="2-R-方和调整-R-方"><a href="#2-R-方和调整-R-方" class="headerlink" title="2 R 方和调整 R 方"></a>2 R 方和调整 R 方</h2><p>模型中可能会存在无意义的变量，这回增加模型的复杂度，却不会显著提高模型表现。此时，定义调整 R 方，从而平衡模型表现和模型复杂度的衡量。</p><h3 id="2-1-增加变量后的回归分析"><a href="#2-1-增加变量后的回归分析" class="headerlink" title="2.1 增加变量后的回归分析"></a>2.1 增加变量后的回归分析</h3><p>例如：向上面的例子增加一个无关的变量 <code>Snow</code> </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CountryKitchen<span class="operator">$</span>Snow <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">24</span><span class="punctuation">,</span> <span class="number">31</span><span class="punctuation">,</span> <span class="number">31</span><span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> <span class="number">18</span><span class="punctuation">,</span> <span class="number">42</span><span class="punctuation">,</span> <span class="number">50</span><span class="punctuation">,</span> <span class="number">49</span><span class="punctuation">,</span> <span class="number">60</span><span class="punctuation">,</span> <span class="number">62</span><span class="punctuation">,</span> <span class="number">42</span><span class="punctuation">,</span> <span class="number">58</span><span class="punctuation">,</span> <span class="number">55</span><span class="punctuation">,</span> <span class="number">79</span><span class="punctuation">,</span> <span class="number">88</span><span class="punctuation">)</span> <span class="comment"># nolint</span></span><br><span class="line">pairs<span class="punctuation">(</span>CountryKitchen<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;pairs(dataname)&quot;</span><span class="punctuation">)</span> <span class="comment"># 绘图</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> cor<span class="punctuation">(</span>CountryKitchen<span class="punctuation">)</span></span><br><span class="line">                   Sales Advertisement   Promotion Competitor        Snow</span><br><span class="line">Sales          <span class="number">1.0000000</span>    <span class="number">0.70769256</span>  <span class="number">0.61230329</span> <span class="operator">-</span><span class="number">0.6248346</span>  <span class="number">0.19521113</span></span><br><span class="line">Advertisement  <span class="number">0.7076926</span>    <span class="number">1.00000000</span>  <span class="number">0.16133514</span> <span class="operator">-</span><span class="number">0.2131088</span> <span class="operator">-</span><span class="number">0.06041495</span></span><br><span class="line">Promotion      <span class="number">0.6123033</span>    <span class="number">0.16133514</span>  <span class="number">1.00000000</span> <span class="operator">-</span><span class="number">0.4939321</span>  <span class="number">0.05054504</span></span><br><span class="line">Competitor    <span class="operator">-</span><span class="number">0.6248346</span>   <span class="operator">-</span><span class="number">0.21310879</span> <span class="operator">-</span><span class="number">0.49393215</span>  <span class="number">1.0000000</span> <span class="operator">-</span><span class="number">0.20264187</span></span><br><span class="line">Snow           <span class="number">0.1952111</span>   <span class="operator">-</span><span class="number">0.06041495</span>  <span class="number">0.05054504</span> <span class="operator">-</span><span class="number">0.2026419</span>  <span class="number">1.00000000</span></span><br></pre></td></tr></table></figure><p>注意到 <code>Snow</code> 与响应变量 <code>Sales</code> 关系较小 <code>cor = 0.1952111</code> 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/cor_pairs.png" alt=""></p><p>此时进行线性回归：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result5 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Sales <span class="operator">~</span> .<span class="punctuation">,</span> data <span class="operator">=</span> CountryKitchen<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result5<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> Sales <span class="operator">~</span> .<span class="punctuation">,</span> data <span class="operator">=</span> CountryKitchen<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">33.706</span>  <span class="operator">-</span><span class="number">5.189</span>   <span class="number">5.557</span>   <span class="number">9.343</span>  <span class="number">16.964</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">              Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>    <span class="number">44.2094</span>    <span class="number">32.0045</span>   <span class="number">1.381</span> <span class="number">0.197254</span>    </span><br><span class="line">Advertisement  <span class="number">50.3533</span>    <span class="number">10.4476</span>   <span class="number">4.820</span> <span class="number">0.000703</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Promotion      <span class="number">61.1433</span>    <span class="number">23.0614</span>   <span class="number">2.651</span> <span class="number">0.024258</span> <span class="operator">*</span>  </span><br><span class="line">Competitor     <span class="operator">-</span><span class="number">1.6146</span>     <span class="number">0.8130</span>  <span class="operator">-</span><span class="number">1.986</span> <span class="number">0.075105</span> .  </span><br><span class="line">Snow            <span class="number">0.3035</span>     <span class="number">0.2419</span>   <span class="number">1.255</span> <span class="number">0.238081</span>    </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">17.16</span> on <span class="number">10</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.8557</span><span class="punctuation">,</span>    Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.798</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">14.83</span> on <span class="number">4</span> and <span class="number">10</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">0.00033</span></span><br></pre></td></tr></table></figure><h3 id="2-2-R-方与调整-R-方"><a href="#2-2-R-方与调整-R-方" class="headerlink" title="2.2 R 方与调整 R 方"></a>2.2 R 方与调整 R 方</h3><p>R-squared 从 0.833 增加到 0.856 ：</p><ul><li><p>基于 R-squared ，第二个模型似乎比第一个模型更好</p></li><li><p>但是从直观上来看 Snow 与年销售额 Sales 无关，并不应该将其放入模型中</p></li></ul><p><strong>R-squared 总是随着新的自变量不断进入模型而增加，哪怕该自变量与应变量几乎没有关系。</strong></p><p>为了修正这种影响，引入调整 R 方：</p><script type="math/tex; mode=display">R^2_a = 1 - (1 - R^2)(\frac{n-1}{n-p-1})</script><ul><li><p>$R^2_a$  $R_a^2$ 的增加量比 $R^2$ 的增加量小，这是因为前者考虑了模型中自变量 x 的个数</p></li><li><p>然而在这个例子中，即便是基于 $R_a^2$ 进行判断，仍会将与应变量几乎无关的自变量引入模型，修正判定系数只是一种修正的方法，未必在任何情况下都有效</p></li><li>为了衡量模型中每个自变量是否确实与应变量有关，一种更正规和有效的方法是对回归系数进行显著性检验：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">              Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line">Snow            <span class="number">0.3035</span>     <span class="number">0.2419</span>   <span class="number">1.255</span> <span class="number">0.238081</span>    </span><br></pre></td></tr></table></figure><p>由 <code>Pr(&gt;|t|) = 0.23 &gt; 0.05</code> 故接受 $H<em>0: \beta</em>{snow} = 0$ ，即不显著。</p><h2 id="3-多重共线性"><a href="#3-多重共线性" class="headerlink" title="3 多重共线性"></a>3 多重共线性</h2><p><strong>多重共线性：</strong>自变量之间存在高度线性相关性。</p><h3 id="3-1-多重共线性的例子"><a href="#3-1-多重共线性的例子" class="headerlink" title="3.1 多重共线性的例子"></a>3.1 多重共线性的例子</h3><p>例：变量 <code>GPA</code> 和 <code>GMAT</code> 去拟合 <code>salary</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多重共线性</span></span><br><span class="line">salary <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">    <span class="number">100000</span><span class="punctuation">,</span> <span class="number">100000</span><span class="punctuation">,</span> <span class="number">77500</span><span class="punctuation">,</span> <span class="number">77500</span><span class="punctuation">,</span> <span class="number">75000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">87500</span><span class="punctuation">,</span> <span class="number">77500</span><span class="punctuation">,</span> <span class="number">87500</span><span class="punctuation">,</span> <span class="number">77500</span><span class="punctuation">,</span> <span class="number">90000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">95000</span><span class="punctuation">,</span> <span class="number">65000</span><span class="punctuation">,</span> <span class="number">72500</span><span class="punctuation">,</span> <span class="number">82500</span><span class="punctuation">,</span> <span class="number">100000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">97500</span><span class="punctuation">,</span> <span class="number">68500</span><span class="punctuation">,</span> <span class="number">85000</span><span class="punctuation">,</span> <span class="number">88500</span><span class="punctuation">,</span> <span class="number">100000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">77500</span><span class="punctuation">,</span> <span class="number">92500</span><span class="punctuation">,</span> <span class="number">92500</span><span class="punctuation">,</span> <span class="number">97500</span><span class="punctuation">,</span> <span class="number">95000</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">GPA <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">    <span class="number">3.9</span><span class="punctuation">,</span> <span class="number">3.9</span><span class="punctuation">,</span> <span class="number">3.1</span><span class="punctuation">,</span> <span class="number">3.2</span><span class="punctuation">,</span> <span class="number">3.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">3.5</span><span class="punctuation">,</span> <span class="number">3.0</span><span class="punctuation">,</span> <span class="number">3.5</span><span class="punctuation">,</span> <span class="number">3.2</span><span class="punctuation">,</span> <span class="number">3.6</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">3.7</span><span class="punctuation">,</span> <span class="number">2.9</span><span class="punctuation">,</span> <span class="number">3.4</span><span class="punctuation">,</span> <span class="number">3.4</span><span class="punctuation">,</span> <span class="number">4.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">3.8</span><span class="punctuation">,</span> <span class="number">2.8</span><span class="punctuation">,</span> <span class="number">3.5</span><span class="punctuation">,</span> <span class="number">3.6</span><span class="punctuation">,</span> <span class="number">3.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">3.1</span><span class="punctuation">,</span> <span class="number">3.7</span><span class="punctuation">,</span> <span class="number">3.7</span><span class="punctuation">,</span> <span class="number">4.0</span><span class="punctuation">,</span> <span class="number">3.8</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">GMAT <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">    <span class="number">640</span><span class="punctuation">,</span> <span class="number">644</span><span class="punctuation">,</span> <span class="number">557</span><span class="punctuation">,</span> <span class="number">550</span><span class="punctuation">,</span> <span class="number">547</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">589</span><span class="punctuation">,</span> <span class="number">533</span><span class="punctuation">,</span> <span class="number">600</span><span class="punctuation">,</span> <span class="number">630</span><span class="punctuation">,</span> <span class="number">633</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">642</span><span class="punctuation">,</span> <span class="number">522</span><span class="punctuation">,</span> <span class="number">628</span><span class="punctuation">,</span> <span class="number">583</span><span class="punctuation">,</span> <span class="number">650</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">641</span><span class="punctuation">,</span> <span class="number">530</span><span class="punctuation">,</span> <span class="number">596</span><span class="punctuation">,</span> <span class="number">605</span><span class="punctuation">,</span> <span class="number">656</span><span class="punctuation">,</span></span><br><span class="line">    <span class="number">574</span><span class="punctuation">,</span> <span class="number">636</span><span class="punctuation">,</span> <span class="number">635</span><span class="punctuation">,</span> <span class="number">654</span><span class="punctuation">,</span> <span class="number">633</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result6 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>salary <span class="operator">~</span> GPA <span class="operator">+</span> GMAT<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result6<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> salary <span class="operator">~</span> GPA <span class="operator">+</span> GMAT<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line"><span class="operator">-</span><span class="number">10027.3</span>  <span class="operator">-</span><span class="number">1508.7</span>    <span class="number">549.5</span>   <span class="number">1831.0</span>   <span class="number">4103.3</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="operator">-</span><span class="number">2507.37</span>   <span class="number">10440.28</span>  <span class="operator">-</span><span class="number">0.240</span>    <span class="number">0.812</span>    </span><br><span class="line">GPA         <span class="number">32650.32</span>    <span class="number">4458.95</span>   <span class="number">7.322</span> <span class="number">2.48e-07</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">GMAT          <span class="operator">-</span><span class="number">41.36</span>      <span class="number">37.32</span>  <span class="operator">-</span><span class="number">1.108</span>    <span class="number">0.280</span>    </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">3201</span> on <span class="number">22</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9178</span><span class="punctuation">,</span>    Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9104</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">122.9</span> on <span class="number">2</span> and <span class="number">22</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">1.151e-12</span></span><br></pre></td></tr></table></figure><p>注意到：<code>Multiple R-squared:  0.9178,    Adjusted R-squared:  0.9104</code> 所以模型整体表现良好，但是</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line">GMAT          <span class="operator">-</span><span class="number">41.36</span>      <span class="number">37.32</span>  <span class="operator">-</span><span class="number">1.108</span>    <span class="number">0.280</span>    </span><br></pre></td></tr></table></figure><p>说明 <code>GMAT</code> 表现不显著，且系数为负，不符合常识。这可能的原因就是 <code>GMAT</code> 与 <code>GPA</code> 之间存在高度线性相关性，即多重共线性。</p><p>注意到：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> cor<span class="punctuation">(</span>GPA<span class="punctuation">,</span> GMAT<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">0.9150276</span></span><br></pre></td></tr></table></figure><p>所以二者存在极高的线性关系。可以删去不显著的 <code>GMAT</code> 重新线性回归：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result7 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>salary <span class="operator">~</span> GPA<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result7<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="3-2-多次共线性的判断"><a href="#3-2-多次共线性的判断" class="headerlink" title="3.2 多次共线性的判断"></a>3.2 多次共线性的判断</h3><p><strong>多重共线性：</strong>自变量线性相关，即</p><script type="math/tex; mode=display">\exist\ c_j \neq 0\quad s.t.\ c_1X_1 + c_2X_2 + \cdots + c_pX_p = c_0</script><p><strong>判断方法：</strong></p><ol><li>直接比较自变量 X 两两之间的线性相关系数</li><li>计算 $X^T X$ 的 Kappa 值，其中 $X = (X_1,\ X_2,\ \cdots,\ X_p) \in R^{n \times p}$ </li></ol><script type="math/tex; mode=display">Kappa(X^T X) = \frac{\max\ \lambda_{X^T X}}{\min\ \lambda_{X^T X}}</script><p>其中 $\lambda_{X^T X}$ 代表特征根。这是因为，若多重共线性，则 $X^T X$ 几乎不可逆。</p><p>经验判断：当 Kappa &gt; 1000 则认为有严重的多重共线性；当 100 &lt; Kappa &lt; 1000 认为有中等严重的多重共线性；当 Kappa &lt; 100 则认为多重共线性较弱。</p><p><strong>例如：</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X <span class="operator">&lt;-</span> cbind<span class="punctuation">(</span>GPA<span class="punctuation">,</span> GMAT<span class="punctuation">)</span></span><br><span class="line">kappa<span class="punctuation">(</span>t<span class="punctuation">(</span>X<span class="punctuation">)</span> <span class="operator">%*%</span> X<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 13666179 &gt;&gt; 1000</span></span><br></pre></td></tr></table></figure><h2 id="4-模型选择"><a href="#4-模型选择" class="headerlink" title="4 模型选择"></a>4 模型选择</h2><p>在回归模型中引入过多自变量可能会引起严重的问题，因此在所有可能的自变量中，应只选择一些与因变量“最有关”的进行建模，这就是<strong>变量选择</strong>问题。</p><h3 id="4-1-模型选择例子"><a href="#4-1-模型选择例子" class="headerlink" title="4.1 模型选择例子"></a>4.1 模型选择例子</h3><p>例：载入数据</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cement <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span></span><br><span class="line">    X1 <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">        <span class="number">7</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">11</span><span class="punctuation">,</span> <span class="number">11</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">11</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">2</span><span class="punctuation">,</span> <span class="number">21</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">11</span><span class="punctuation">,</span> <span class="number">10</span></span><br><span class="line">    <span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    X2 <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">        <span class="number">26</span><span class="punctuation">,</span> <span class="number">29</span><span class="punctuation">,</span> <span class="number">56</span><span class="punctuation">,</span> <span class="number">31</span><span class="punctuation">,</span> <span class="number">52</span><span class="punctuation">,</span> <span class="number">55</span><span class="punctuation">,</span> <span class="number">71</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">31</span><span class="punctuation">,</span> <span class="number">54</span><span class="punctuation">,</span> <span class="number">47</span><span class="punctuation">,</span> <span class="number">40</span><span class="punctuation">,</span> <span class="number">66</span><span class="punctuation">,</span> <span class="number">68</span></span><br><span class="line">    <span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    X3 <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">        <span class="number">6</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">17</span><span class="punctuation">,</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">18</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">23</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">8</span></span><br><span class="line">    <span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    X4 <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">        <span class="number">60</span><span class="punctuation">,</span> <span class="number">52</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">47</span><span class="punctuation">,</span> <span class="number">33</span><span class="punctuation">,</span> <span class="number">22</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">44</span><span class="punctuation">,</span> <span class="number">22</span><span class="punctuation">,</span> <span class="number">26</span><span class="punctuation">,</span> <span class="number">34</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">12</span></span><br><span class="line">    <span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    Y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span></span><br><span class="line">        <span class="number">78.5</span><span class="punctuation">,</span> <span class="number">74.3</span><span class="punctuation">,</span> <span class="number">104.3</span><span class="punctuation">,</span> <span class="number">87.6</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">95.9</span><span class="punctuation">,</span> <span class="number">109.2</span><span class="punctuation">,</span> <span class="number">102.7</span><span class="punctuation">,</span> <span class="number">72.5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">93.1</span><span class="punctuation">,</span> <span class="number">115.9</span><span class="punctuation">,</span> <span class="number">83.8</span><span class="punctuation">,</span> <span class="number">113.3</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">109.4</span></span><br><span class="line">    <span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>全变量回归：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result8 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X3 <span class="operator">+</span> X4<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result8<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X3 <span class="operator">+</span> X4<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">3.1750</span> <span class="operator">-</span><span class="number">1.6709</span>  <span class="number">0.2508</span>  <span class="number">1.3783</span>  <span class="number">3.9254</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>  </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>  <span class="number">62.4054</span>    <span class="number">70.0710</span>   <span class="number">0.891</span>   <span class="number">0.3991</span>  </span><br><span class="line">X1            <span class="number">1.5511</span>     <span class="number">0.7448</span>   <span class="number">2.083</span>   <span class="number">0.0708</span> .</span><br><span class="line">X2            <span class="number">0.5102</span>     <span class="number">0.7238</span>   <span class="number">0.705</span>   <span class="number">0.5009</span>  </span><br><span class="line">X3            <span class="number">0.1019</span>     <span class="number">0.7547</span>   <span class="number">0.135</span>   <span class="number">0.8959</span>  </span><br><span class="line">X4           <span class="operator">-</span><span class="number">0.1441</span>     <span class="number">0.7091</span>  <span class="operator">-</span><span class="number">0.203</span>   <span class="number">0.8441</span>  </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">2.446</span> on <span class="number">8</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9824</span><span class="punctuation">,</span>    Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9736</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">111.5</span> on <span class="number">4</span> and <span class="number">8</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">4.756e-07</span></span><br></pre></td></tr></table></figure><p>注意到，所有系数的 p 值均大于 0.05 ，即都不显著，但模型整体 $R^2$ 表现良好。故下面检查多重共线性：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X.cement <span class="operator">&lt;-</span> as.matrix<span class="punctuation">(</span>cement<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">kappa<span class="punctuation">(</span>t<span class="punctuation">(</span>X.cement<span class="punctuation">)</span> <span class="operator">%*%</span> X.cement<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 548.3885 &gt; 100</span></span><br></pre></td></tr></table></figure><p>故，存在着较强的多重共线性，检查相关系数：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> cor<span class="punctuation">(</span>X.cement<span class="punctuation">)</span></span><br><span class="line">           X1         X2         X3         X4</span><br><span class="line">X1  <span class="number">1.0000000</span>  <span class="number">0.2285795</span> <span class="operator">-</span><span class="number">0.8241338</span> <span class="operator">-</span><span class="number">0.2454451</span></span><br><span class="line">X2  <span class="number">0.2285795</span>  <span class="number">1.0000000</span> <span class="operator">-</span><span class="number">0.1392424</span> <span class="operator">-</span><span class="number">0.9729550</span></span><br><span class="line">X3 <span class="operator">-</span><span class="number">0.8241338</span> <span class="operator">-</span><span class="number">0.1392424</span>  <span class="number">1.0000000</span>  <span class="number">0.0295370</span>  <span class="comment"># cor(X1, X3) = -0.82</span></span><br><span class="line">X4 <span class="operator">-</span><span class="number">0.2454451</span> <span class="operator">-</span><span class="number">0.9729550</span>  <span class="number">0.0295370</span>  <span class="number">1.0000000</span>  <span class="comment"># cor(X2, X4) = -0.97</span></span><br></pre></td></tr></table></figure><p>考虑去除 X3 和 去除 X3 、X4</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result9 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X4<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result9<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">result10 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Y <span class="operator">~</span> X1 <span class="operator">+</span> X2<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>result10<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>result10<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> Y <span class="operator">~</span> X1 <span class="operator">+</span> X2<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">   Min     <span class="number">1</span>Q Median     <span class="number">3</span>Q    Max </span><br><span class="line"><span class="operator">-</span><span class="number">2.893</span> <span class="operator">-</span><span class="number">1.574</span> <span class="operator">-</span><span class="number">1.302</span>  <span class="number">1.363</span>  <span class="number">4.048</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="number">52.57735</span>    <span class="number">2.28617</span>   <span class="number">23.00</span> <span class="number">5.46e-10</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">X1           <span class="number">1.46831</span>    <span class="number">0.12130</span>   <span class="number">12.11</span> <span class="number">2.69e-07</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">X2           <span class="number">0.66225</span>    <span class="number">0.04585</span>   <span class="number">14.44</span> <span class="number">5.03e-08</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">2.406</span> on <span class="number">10</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9787</span><span class="punctuation">,</span>    Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9744</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">229.5</span> on <span class="number">2</span> and <span class="number">10</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">4.407e-09</span></span><br></pre></td></tr></table></figure><h3 id="4-2-模型选择方法"><a href="#4-2-模型选择方法" class="headerlink" title="4.2 模型选择方法"></a>4.2 模型选择方法</h3><p><strong>向后选择法(backward)：</strong>假设总共有 p 个可能的自变量，用所有的 p 个自变量拟合一个多元回归模型；如果其中有一些自变量系数估计值的 p-value 大于 0.05 ，则找出其中 p-value 最大的自变量剔除出模型，用余下的 p - 1 个自变量拟合多元回归模型；重复直至基于 p-value 没有自变量可以从回归模型中可以被剔除。</p><p><strong>向后选择法(backward)：</strong>与向后选择法相反，不断加入新的变量。</p><p><strong>逐步回归：</strong>类似于穷举，即将不同的变量都进行尝试，然后基于一些指标，找到最优的模型选择变量组合。</p><p>基于某个指标，这个指标被称为 <strong>AIC</strong> ，AIC 越小越好，一般而言，$AIC = -2\log(f(x)) + 2p$ 其中 f 为联合密度函数，而 p 为变量个数。</p><h3 id="4-3-R-语言实现模型选择"><a href="#4-3-R-语言实现模型选择" class="headerlink" title="4.3 R 语言实现模型选择"></a>4.3 R 语言实现模型选择</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result8 <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X3 <span class="operator">+</span> X4<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line">lm.step <span class="operator">&lt;-</span> step<span class="punctuation">(</span>result8<span class="punctuation">,</span> direction <span class="operator">=</span> <span class="string">&quot;back&quot;</span><span class="punctuation">)</span> <span class="comment"># 向后选择</span></span><br></pre></td></tr></table></figure><p>向后选择的结果（AIC）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Start<span class="operator">:</span>  AIC<span class="operator">=</span><span class="number">26.94</span></span><br><span class="line">Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X3 <span class="operator">+</span> X4</span><br><span class="line"></span><br><span class="line">       Df Sum of Sq    RSS    AIC</span><br><span class="line"><span class="operator">-</span> X3    <span class="number">1</span>    <span class="number">0.1091</span> <span class="number">47.973</span> <span class="number">24.974</span></span><br><span class="line"><span class="operator">-</span> X4    <span class="number">1</span>    <span class="number">0.2470</span> <span class="number">48.111</span> <span class="number">25.011</span></span><br><span class="line"><span class="operator">-</span> X2    <span class="number">1</span>    <span class="number">2.9725</span> <span class="number">50.836</span> <span class="number">25.728</span></span><br><span class="line"><span class="operator">&lt;</span>none<span class="operator">&gt;</span>              <span class="number">47.864</span> <span class="number">26.944</span></span><br><span class="line"><span class="operator">-</span> X1    <span class="number">1</span>   <span class="number">25.9509</span> <span class="number">73.815</span> <span class="number">30.576</span></span><br><span class="line"></span><br><span class="line">Step<span class="operator">:</span>  AIC<span class="operator">=</span><span class="number">24.97</span></span><br><span class="line">Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X4</span><br><span class="line"></span><br><span class="line">       Df Sum of Sq    RSS    AIC</span><br><span class="line"><span class="operator">&lt;</span>none<span class="operator">&gt;</span>               <span class="number">47.97</span> <span class="number">24.974</span></span><br><span class="line"><span class="operator">-</span> X4    <span class="number">1</span>      <span class="number">9.93</span>  <span class="number">57.90</span> <span class="number">25.420</span></span><br><span class="line"><span class="operator">-</span> X2    <span class="number">1</span>     <span class="number">26.79</span>  <span class="number">74.76</span> <span class="number">28.742</span></span><br><span class="line"><span class="operator">-</span> X1    <span class="number">1</span>    <span class="number">820.91</span> <span class="number">868.88</span> <span class="number">60.629</span></span><br></pre></td></tr></table></figure><p>结果：选择 <code>X1, X2, X4</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>lm.step<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X4<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">3.0919</span> <span class="operator">-</span><span class="number">1.8016</span>  <span class="number">0.2562</span>  <span class="number">1.2818</span>  <span class="number">3.8982</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>  <span class="number">71.6483</span>    <span class="number">14.1424</span>   <span class="number">5.066</span> <span class="number">0.000675</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">X1            <span class="number">1.4519</span>     <span class="number">0.1170</span>  <span class="number">12.410</span> <span class="number">5.78e-07</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">X2            <span class="number">0.4161</span>     <span class="number">0.1856</span>   <span class="number">2.242</span> <span class="number">0.051687</span> .  </span><br><span class="line">X4           <span class="operator">-</span><span class="number">0.2365</span>     <span class="number">0.1733</span>  <span class="operator">-</span><span class="number">1.365</span> <span class="number">0.205395</span>    </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">2.309</span> on <span class="number">9</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9823</span><span class="punctuation">,</span>    Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9764</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">166.8</span> on <span class="number">3</span> and <span class="number">9</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">3.323e-08</span></span><br></pre></td></tr></table></figure><p>或者使用 <code>step()</code> 函数：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">step<span class="punctuation">(</span>result8<span class="punctuation">,</span> direction <span class="operator">=</span> <span class="string">&quot;back&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Start<span class="operator">:</span>  AIC<span class="operator">=</span><span class="number">26.94</span><span class="comment"># 初始 AIC</span></span><br><span class="line">Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X3 <span class="operator">+</span> X4</span><br><span class="line"></span><br><span class="line"><span class="comment"># RSS 残差平方和 sum(ei^2) = sum((yi - yi_hat)^2)</span></span><br><span class="line">       Df Sum of Sq    RSS    AIC</span><br><span class="line"><span class="operator">-</span> X3    <span class="number">1</span>    <span class="number">0.1091</span> <span class="number">47.973</span> <span class="number">24.974</span>  <span class="comment"># 删除 X3</span></span><br><span class="line"><span class="operator">-</span> X4    <span class="number">1</span>    <span class="number">0.2470</span> <span class="number">48.111</span> <span class="number">25.011</span>  <span class="comment"># 删除 X4</span></span><br><span class="line"><span class="operator">-</span> X2    <span class="number">1</span>    <span class="number">2.9725</span> <span class="number">50.836</span> <span class="number">25.728</span>  <span class="comment"># 删除 X2</span></span><br><span class="line"><span class="operator">&lt;</span>none<span class="operator">&gt;</span>              <span class="number">47.864</span> <span class="number">26.944</span>  <span class="comment"># 不删</span></span><br><span class="line"><span class="operator">-</span> X1    <span class="number">1</span>   <span class="number">25.9509</span> <span class="number">73.815</span> <span class="number">30.576</span>  <span class="comment"># 删除 X1</span></span><br><span class="line"></span><br><span class="line">Step<span class="operator">:</span>  AIC<span class="operator">=</span><span class="number">24.97</span>  <span class="comment"># 上一步最小的 AIC -&gt; 删除 X3</span></span><br><span class="line">Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X4</span><br><span class="line"></span><br><span class="line">       Df Sum of Sq    RSS    AIC</span><br><span class="line"><span class="operator">&lt;</span>none<span class="operator">&gt;</span>               <span class="number">47.97</span> <span class="number">24.974</span></span><br><span class="line"><span class="operator">-</span> X4    <span class="number">1</span>      <span class="number">9.93</span>  <span class="number">57.90</span> <span class="number">25.420</span></span><br><span class="line"><span class="operator">-</span> X2    <span class="number">1</span>     <span class="number">26.79</span>  <span class="number">74.76</span> <span class="number">28.742</span></span><br><span class="line"><span class="operator">-</span> X1    <span class="number">1</span>    <span class="number">820.91</span> <span class="number">868.88</span> <span class="number">60.629</span></span><br><span class="line"><span class="comment"># 删除任意一个 AIC 都会变大，故结束</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X4<span class="punctuation">,</span> data <span class="operator">=</span> cement<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>           X1           X2           X4  </span><br><span class="line">    <span class="number">71.6483</span>       <span class="number">1.4519</span>       <span class="number">0.4161</span>      <span class="operator">-</span><span class="number">0.2365</span>  </span><br></pre></td></tr></table></figure><p>强制删去一个变量，使用函数 <code>drop1()</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop1<span class="punctuation">(</span>lm.step<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Single term deletions</span><br><span class="line"></span><br><span class="line">Model<span class="operator">:</span></span><br><span class="line">Y <span class="operator">~</span> X1 <span class="operator">+</span> X2 <span class="operator">+</span> X4</span><br><span class="line">       Df Sum of Sq    RSS    AIC</span><br><span class="line"><span class="operator">&lt;</span>none<span class="operator">&gt;</span>               <span class="number">47.97</span> <span class="number">24.974</span></span><br><span class="line">X1      <span class="number">1</span>    <span class="number">820.91</span> <span class="number">868.88</span> <span class="number">60.629</span></span><br><span class="line">X2      <span class="number">1</span>     <span class="number">26.79</span>  <span class="number">74.76</span> <span class="number">28.742</span></span><br><span class="line">X4      <span class="number">1</span>      <span class="number">9.93</span>  <span class="number">57.90</span> <span class="number">25.420</span></span><br></pre></td></tr></table></figure><h2 id="5-回归分析：预测、诊断"><a href="#5-回归分析：预测、诊断" class="headerlink" title="5 回归分析：预测、诊断"></a>5 回归分析：预测、诊断</h2><h3 id="5-1-预测"><a href="#5-1-预测" class="headerlink" title="5.1 预测"></a>5.1 预测</h3><p>对于新数据，进行预测：</p><script type="math/tex; mode=display">y^* = \hat{\beta_0} + \hat{\beta_1}x^*_1 + \cdots + \hat{\beta_p}x^*_p</script><p>多个数据同样可以预测，使用 R 语言实现：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newdata <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span></span><br><span class="line">    Advertisement <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1.2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1.4</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    Promotion <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    Competitor <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">25</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 点估计</span></span><br><span class="line">predict<span class="punctuation">(</span>result3<span class="punctuation">,</span> new <span class="operator">=</span> newdata<span class="punctuation">)</span></span><br><span class="line">       <span class="number">1</span>        <span class="number">2</span>        <span class="number">3</span> </span><br><span class="line"><span class="number">108.3655</span> <span class="number">132.0996</span> <span class="number">161.3318</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间估计</span></span><br><span class="line">predict<span class="punctuation">(</span>result3<span class="punctuation">,</span> new <span class="operator">=</span> newdata<span class="punctuation">,</span> interval <span class="operator">=</span> <span class="string">&quot;prediction&quot;</span><span class="punctuation">)</span></span><br><span class="line">       fit       lwr      upr</span><br><span class="line"><span class="number">1</span> <span class="number">108.3655</span>  <span class="number">67.19011</span> <span class="number">149.5408</span></span><br><span class="line"><span class="number">2</span> <span class="number">132.0996</span>  <span class="number">88.15866</span> <span class="number">176.0406</span></span><br><span class="line"><span class="number">3</span> <span class="number">161.3318</span> <span class="number">115.96753</span> <span class="number">206.6961</span></span><br></pre></td></tr></table></figure><h3 id="5-2-诊断"><a href="#5-2-诊断" class="headerlink" title="5.2 诊断"></a>5.2 诊断</h3><p>我们需要诊断模型假设的成立性，多元线性回归模型的假设包括</p><ul><li>随机误差相互独立（独立性）</li><li>随机误差均值为 0 ，并且有相同的标准差（同方差性）</li><li>随机误差服从正态分布</li></ul><p>这些检验均有误差的估计残差来判断：</p><script type="math/tex; mode=display">\hat{\epsilon_i} = e_i = y_i - \hat{y_i}</script><h4 id="5-2-1-同方差性"><a href="#5-2-1-同方差性" class="headerlink" title="5.2.1 同方差性"></a>5.2.1 同方差性</h4><p>检测同方差性：画出残差（纵轴）对单个自变量或拟合因变量（横轴）的散点图，从图中观察残差对于单个自变量或拟合应变量的取值是否呈现出（函数形式的）趋势。</p><h4 id="5-2-2-随机误差的正态分布检验"><a href="#5-2-2-随机误差的正态分布检验" class="headerlink" title="5.2.2 随机误差的正态分布检验"></a>5.2.2 随机误差的正态分布检验</h4><p>随机误差的正态性假设可以用残差的直方图或 Q-Q 图来进行检测。</p><h4 id="5-2-3-随机误差独立（自相关性）"><a href="#5-2-3-随机误差独立（自相关性）" class="headerlink" title="5.2.3 随机误差独立（自相关性）"></a>5.2.3 随机误差独立（自相关性）</h4><p>自相关性：是一种常见的违反独立性的现象，当样本观测是以某种自然序列（如时间）被记录时，可能出现自相关性。将残差按自然序列作图并检测趋势。</p><p>上面的检验图像的绘制，可以使用 R 语言简单地作出：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 诊断</span></span><br><span class="line">png<span class="punctuation">(</span><span class="string">&quot;img/ei.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">1200</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">1200</span><span class="punctuation">,</span> res <span class="operator">=</span> <span class="number">200</span><span class="punctuation">)</span></span><br><span class="line">op <span class="operator">&lt;-</span> par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>result3<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>op<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/ei.png" alt=""></p>]]></content>
    
    
    <summary type="html">本章介绍多元线性回归的 R 语言实现，包括模型搭建、变量选择、多重共线性和模型预测和诊断。</summary>
    
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/categories/R-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/tags/R-%E8%AF%AD%E8%A8%80/"/>
    
    <category term="统计软件" scheme="https://blog.iskage.online/tags/%E7%BB%9F%E8%AE%A1%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="R programming" scheme="https://blog.iskage.online/tags/R-programming/"/>
    
  </entry>
  
  <entry>
    <title>搜索树（1）：二叉搜索树、平衡搜索树、AVL 树</title>
    <link href="https://blog.iskage.online/posts/e59b7364.html"/>
    <id>https://blog.iskage.online/posts/e59b7364.html</id>
    <published>2025-04-19T00:16:00.000Z</published>
    <updated>2025-04-19T08:00:39.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搜索树（1）：二叉搜索树、平衡搜索树、AVL-树"><a href="#搜索树（1）：二叉搜索树、平衡搜索树、AVL-树" class="headerlink" title="搜索树（1）：二叉搜索树、平衡搜索树、AVL 树"></a>搜索树（1）：二叉搜索树、平衡搜索树、AVL 树</h1><p>本章使用树结构来高效地实现有序映射，例如：二叉搜索树、平衡搜索树、 AVL 树。二叉搜索树根据比较左右节点和根节点的大小决定存储，例如 <code>左 &gt; 根 &gt; 右</code> 。平衡搜索树和 AVL 实现高度平衡属性，则进一步保证了树的高度为 log n ，从而使得时间复杂度为 O(log n) 。</p><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><h2 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1 二叉搜索树"></a>1 二叉搜索树</h2><p>映射 M 最重要的 5 类行为（查找、增添、删除、修改、遍历）：</p><ul><li><code>M[k]</code> ：如果存在，返回映射 M 中键 k 对应的值，否则抛出 KeyError 。Python 中该功能由特殊方法 <code>__getitem__</code> 实现。</li><li><code>M[k] = v</code> ：使得映射 M 中键 k 对应于值 v 。如 k 有之前对应的值，则替换掉该值。Python 中该功能由特殊方法 <code>__setitem__</code> 实现。</li><li><code>del M[k]</code> ：从映射 M 中删除键为 k 的键值对。如键 k 不存在则抛出 KeyError 。Python 中该功能由特殊方法 <code>__delitem__</code> 实现。</li><li><code>len(M)</code> ：返回映射 M 中键值对的数量。Python 中该功能由特殊方法 <code>__len__</code> 实现。</li><li><code>iter(M)</code> ：返回一个包含映射 M 所有键的迭代器。Python 中该功能由特殊方法 <code>__iter__</code> 实现。</li></ul><p>有序映射的映射 ADT 的扩展，它包括标准映射的所有行为，还增加了以下方法：</p><ul><li><code>M.find_min()</code> ：用最小键返回键值对（或None，如果映射为空）</li><li><code>M.find_max()</code> ：用最大键返回键值对（或 None，如果映射为空）</li><li><code>M.find_It(k)</code> ：用严格小于 k 的最大键返回键值对（或 None，若没有这样的项存在）</li><li><code>M.find_le(k)</code> :用严格小于等于 k 的最大键返回键值对（或 None，若没有这样的项存在）</li><li><code>M.find_gt(k)</code> ：用严格大于 k 的最小的键返回键值对（或 None，若没有这样的项存在）</li><li><code>M.fnd_ge(k)</code> ：用严格大于或等于 k 的最小的键返回键值对（或None，若没有这样的项存在）</li><li><code>M.fnd_range(start, stop)</code> ：用 start &lt;= 键 &lt; stop 迭代遍历所有键值对。如果 start 指定为 None ，从最小的键开始迭代；如果 stop 指定 None，到最大键迭代结束</li><li><code>iter(M)</code> ：根据自然顺序从最小到最大迭代遍历映射中的所有键</li><li><code>reversed(M)</code> ：根据逆序迭代映射中的所有键 r ，这在 Python 中是用 reversed 来实现的</li></ul><p><strong>二叉搜索树：</strong>二叉树的每个节点 p 存储一个键值对 <code>(k, v)</code> ，使得：</p><ul><li>存储在 p 的左子树的键都小于 k 。</li><li>存储在 p 的右子树的键都大于 k 。</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744966390556.png" alt="二叉搜索树的例子"></p><h3 id="1-1-遍历二叉搜索树"><a href="#1-1-遍历二叉搜索树" class="headerlink" title="1.1 遍历二叉搜索树"></a>1.1 遍历二叉搜索树</h3><p>采用<strong>中序遍历</strong>可以按照键的顺序遍历二叉搜索树。中序遍历即利用的递归的方式先访问左子树，再访问节点，最后访问右子树。中序遍历的复杂度为 <strong>O(n)</strong> 其中 n 为树的节点个数。</p><p>对于树的 ADT ，除了常见的 <code>parent(), left(), right()</code> 方法，二叉搜索树还提供根基中序遍历返回元素的方法：</p><ul><li><code>frist()</code> ：返回一个包含最小键的节点，如果树为空，则返回 None 。</li><li><code>last()</code> ：返回一个包含最大键的节点，如果树为空，则返回 None 。</li><li><code>before(p)</code> ：返回比节点 p 的键小的所有节点中键最大的节点（即中序遍历中在 p 之前的节点），如果p是第一个节点，则返回 None 。</li><li><code>after(p)</code> ：返回比节点 p 的键大的所有节点中键最小的节点（即中序遍历中在 p 之后的节点），如果p是最后一个节点，则返回 None 。</li></ul><p>以 <code>after()</code> 为例，展示如何返回在中序遍历时 p 后面的节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Algorithm after(p):</span><br><span class="line"><span class="keyword">if</span> right(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="comment"># p 有右子节点</span></span><br><span class="line">walk = right(p) </span><br><span class="line"><span class="keyword">while</span> left(walk) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> do</span><br><span class="line">walk = left(walk)  <span class="comment"># 右子树的最左子节点为 after(p)</span></span><br><span class="line"><span class="keyword">return</span> walk</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">walk = p</span><br><span class="line">ancestor = parent(walk)</span><br><span class="line">        <span class="keyword">while</span> ancestor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> walk == right(ancestor) do</span><br><span class="line">            walk = ancestor</span><br><span class="line">            ancestor = parent(walk)  <span class="comment"># 第一个作为祖先节点的左子节点的父节点为 after(p)</span></span><br><span class="line">        <span class="keyword">return</span> ancestor</span><br></pre></td></tr></table></figure><p>显然，利用这种方法最坏情况便是遍历树的每一层，所以复杂度为 <strong>O(h)</strong> 其中 h 为树的层数。</p><h3 id="1-2-搜索"><a href="#1-2-搜索" class="headerlink" title="1.2 搜索"></a>1.2 搜索</h3><p>搜索键 k 时，我们从树根开始向下搜索，在每个节点 p 上，下一步操作由当前节点的键与 k 的比较结果而决定：</p><ul><li><p>若 <code>p.key() &gt; k</code> ，则继续搜索左子树</p></li><li><p>若 <code>p.key() == k</code> ，则搜索成功且终止</p></li><li><p>若 <code>p.key() &lt; k</code> ，则继续搜索右子树</p></li><li><p>若最后探查到空子树，则搜索失败</p></li></ul><p>实现可以采用递归的方式，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Algorithm TreeSearch(T, p, k):</span><br><span class="line">    <span class="keyword">if</span> k == p.key() then</span><br><span class="line">    <span class="keyword">return</span> p  <span class="comment"># 搜索成功</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> k &lt; p.key() <span class="keyword">and</span> T.left(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> then</span><br><span class="line">    <span class="keyword">return</span> TreeSearch(T, T.left(p), k)  <span class="comment"># 递归搜索左子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> k &gt; p.key() <span class="keyword">and</span> T.right(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> then</span><br><span class="line">    <span class="keyword">return</span> TreeSearch(T, T.right(p), k)  <span class="comment"># 递归搜索右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>类似地，这里的搜索查看也是最坏需要遍历树的每一层，复杂度为 <strong>O(h)</strong> 。</p><h3 id="1-3-插入和删除"><a href="#1-3-插入和删除" class="headerlink" title="1.3 插入和删除"></a>1.3 插入和删除</h3><h4 id="1-3-1-插入"><a href="#1-3-1-插入" class="headerlink" title="1.3.1 插入"></a>1.3.1 插入</h4><p>对于插入操作，首先搜索键 k 。如找到则重新对其值进行赋值，否则返回搜索失败时最后一个探查的节点 p ：</p><ul><li>若 <code>k &lt; p.key()</code> ，则将包含  k的新节点作为 p 的左孩子</li><li>若 <code>k &gt; p.key()</code> ，则将包含 k 的新节点作为 p 的右孩子</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744968042824.png" alt="插入新元素的例子"></p><p>伪代码见下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Algorithm TreeInsert(T, k, v):</span><br><span class="line">    p = TreeSearch(T, T.root(), k)  <span class="comment"># 先搜索键 k</span></span><br><span class="line">    <span class="keyword">if</span> k == p.key() then</span><br><span class="line">        <span class="type">Set</span> p’s value to v  <span class="comment"># 找到则修改值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 否则，查看当前 key 与需要插入的 (k, v) 比较</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> k &lt; p.key() then</span><br><span class="line">        add node <span class="keyword">with</span> item (k, v) <span class="keyword">as</span> left child of p</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        add node <span class="keyword">with</span> item (k, v) <span class="keyword">as</span> right child of p</span><br></pre></td></tr></table></figure><h4 id="1-3-2-删除"><a href="#1-3-2-删除" class="headerlink" title="1.3.2 删除"></a>1.3.2 删除</h4><p>删除操作比插入更复杂，因为删除的可能是度为 2 的节点。首先搜索键 k 。如找到，设找到的节点为 p，则：</p><ul><li>若 p 无孩子节点，直接删除即可</li><li>若 p 有一个孩子节点 r，则删除 p 且用其孩子节点替代它</li></ul><p>但是，若 p 有两个孩子节点，则：</p><ul><li><p>使用 <code>before(p)</code> 找到中序遍历中节点 p 的前一个节点 r</p></li><li><p>用节点 r 替代节点 p</p></li><li><p>删除节点 r</p></li></ul><blockquote><p>删除 <code>before(p)</code> 的方法一定能保持树的结构完整，前一个节点 r 一定只有 1 个或 0 个孩子节点。</p></blockquote><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744968441749.png" alt="删除的节点有 2 个字节点，则寻找前一个节点 r 交换后再删除"></p><h3 id="1-3-Python-实现二叉搜索树"><a href="#1-3-Python-实现二叉搜索树" class="headerlink" title="1.3 Python 实现二叉搜索树"></a>1.3 Python 实现二叉搜索树</h3><p>下面实现二叉搜索树的抽象数据类型 ADT <code>TreeMap</code> ，它继承了两个基类：一个是基于双向链表实现的二叉树类 <code>LinkedBinaryTree</code> ，另一个为映射的基础类 <code>MapBase</code> 。</p><blockquote><p>关于 <code>LinkedBinaryTree</code> 和 <code>MapBase</code> 类的实现可以分别查看 <a href="https://github.com/isKage/dsa-notes/blob/main/lec7_tree/utils/linked_binary_tree.py">LinkedBinaryTree 基于双向链表实现的二叉树</a> 和 <a href="https://github.com/isKage/dsa-notes/blob/main/lec9_map_hash/utils/map_base.py">MapBase 映射的基类 ADT</a> 。或者直接查看本章的代码仓库 <a href="https://github.com/isKage/dsa-notes/tree/main/lec10_search_tree/utils">搜索树实现的完整代码</a> 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .linked_binary_tree <span class="keyword">import</span> LinkedBinaryTree</span><br><span class="line">    <span class="keyword">from</span> .map_base <span class="keyword">import</span> MapBase</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> linked_binary_tree <span class="keyword">import</span> LinkedBinaryTree</span><br><span class="line">    <span class="keyword">from</span> map_base <span class="keyword">import</span> MapBase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeMap</span>(LinkedBinaryTree, MapBase):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;有序映射：二叉搜索树&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 覆写 LinkedBinaryTree 的 Position 类 ---------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Position</span>(LinkedBinaryTree.Position):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;负责指明节点是否属于当前树，以及存储了节点类 _Node&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">key</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;返回键&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.element()._key</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">value</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;返回值&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.element()._value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 非公有方法 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_subtree_search</span>(<span class="params">self, p, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;搜索：从 p 节点开始搜索键为 k 的子节点，或最后一个搜索到的节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k == p.key():</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">elif</span> k &lt; p.key():</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.left(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>._subtree_search(<span class="variable language_">self</span>.left(p), k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.right(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>._subtree_search(<span class="variable language_">self</span>.right(p), k)</span><br><span class="line">        <span class="keyword">return</span> p  <span class="comment"># 未搜索到则返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_subtree_first_position</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从 p 节点开始搜索，一直搜索到最左的子节点&quot;&quot;&quot;</span></span><br><span class="line">        walk = p</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.left(walk) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            walk = <span class="variable language_">self</span>.left(walk)</span><br><span class="line">        <span class="keyword">return</span> walk</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_subtree_last_position</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从 p 节点开始搜索，一直搜索到最右的子节点&quot;&quot;&quot;</span></span><br><span class="line">        walk = p</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.right(walk) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            walk = <span class="variable language_">self</span>.right(walk)</span><br><span class="line">        <span class="keyword">return</span> walk</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 引导方法 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历第一个元素，即最小元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._subtree_first_position(<span class="variable language_">self</span>.root())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历最后一个元素，即最大元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._subtree_last_position(<span class="variable language_">self</span>.root())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">before</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历 p 节点的前一个元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._validate(p)  <span class="comment"># 判断是否为当前树的节点，不重要</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.left(p):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._subtree_last_position(<span class="variable language_">self</span>.left(p))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            walk = p</span><br><span class="line">            above = <span class="variable language_">self</span>.parent(walk)</span><br><span class="line">            <span class="keyword">while</span> above <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> walk == <span class="variable language_">self</span>.left(above):</span><br><span class="line">                walk = above</span><br><span class="line">                above = <span class="variable language_">self</span>.parent(walk)</span><br><span class="line">            <span class="keyword">return</span> above</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">after</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历 p 节点的后一个元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.right(p):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._subtree_first_position(<span class="variable language_">self</span>.right(p))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            walk = p</span><br><span class="line">            above = <span class="variable language_">self</span>.parent(walk)</span><br><span class="line">            <span class="keyword">while</span> above <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> walk == <span class="variable language_">self</span>.right(above):</span><br><span class="line">                walk = above</span><br><span class="line">                above = <span class="variable language_">self</span>.parent(walk)</span><br><span class="line">            <span class="keyword">return</span> above</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_position</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到键为 k 的节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = <span class="variable language_">self</span>._subtree_search(<span class="variable language_">self</span>.root(), k)</span><br><span class="line">            <span class="variable language_">self</span>._rebalance_access(p)  <span class="comment"># 平衡树结构的钩子方法，实现方法见后</span></span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 有序映射方法 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;最小 k&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = <span class="variable language_">self</span>.first()</span><br><span class="line">            <span class="keyword">return</span> (p.key(), p.value())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_max</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;最大 k&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = <span class="variable language_">self</span>.last()</span><br><span class="line">            <span class="keyword">return</span> (p.key(), p.value())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_ge</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;大于或等于 k 的最小的键 (key, value)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = <span class="variable language_">self</span>.find_position(k)</span><br><span class="line">            <span class="keyword">if</span> p.key() &lt; k:</span><br><span class="line">                p = <span class="variable language_">self</span>.after(p)</span><br><span class="line">            <span class="keyword">return</span> (p.key(), p.value()) <span class="keyword">if</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_range</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器：(key, value) 使得 start &lt;= key &lt; stop&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                p = <span class="variable language_">self</span>.first()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = <span class="variable language_">self</span>.find_position(start)</span><br><span class="line">                <span class="keyword">if</span> p.key() &lt; start:</span><br><span class="line">                    p = <span class="variable language_">self</span>.after(p)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> (stop <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> p.key() &lt; stop):</span><br><span class="line">                <span class="keyword">yield</span> (p.key(), p.value())</span><br><span class="line">                p = <span class="variable language_">self</span>.after(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 访问和插入节点的映射操作 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看元素 M[k]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error: &#x27;</span> + <span class="built_in">repr</span>(k))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = <span class="variable language_">self</span>._subtree_search(<span class="variable language_">self</span>.root(), k)</span><br><span class="line">            <span class="variable language_">self</span>._rebalance_access(p)</span><br><span class="line">            <span class="keyword">if</span> k != p.key():</span><br><span class="line">                <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error: &#x27;</span> + <span class="built_in">repr</span>(k))</span><br><span class="line">            <span class="keyword">return</span> p.value()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, k, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新/插入元素 M[k] = v&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            leaf = <span class="variable language_">self</span>._add_root(<span class="variable language_">self</span>._Item(k, v))  <span class="comment"># 从零插入根节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = <span class="variable language_">self</span>._subtree_search(<span class="variable language_">self</span>.root(), k)</span><br><span class="line">            <span class="keyword">if</span> p.key() == k:</span><br><span class="line">                p.element()._value = v</span><br><span class="line">                <span class="variable language_">self</span>._rebalance_access(p)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                item = <span class="variable language_">self</span>._Item(k, v)</span><br><span class="line">                <span class="keyword">if</span> p.key() &lt; k:</span><br><span class="line">                    leaf = <span class="variable language_">self</span>._add_right(p, item)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    leaf = <span class="variable language_">self</span>._add_left(p, item)</span><br><span class="line">        <span class="variable language_">self</span>._rebalance_insert(leaf)  <span class="comment"># 平衡操作的钩子函数，插入时的平衡变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;按照顺序，以迭代器的方式返回 k&quot;&quot;&quot;</span></span><br><span class="line">        p = <span class="variable language_">self</span>.first()</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> p.key()</span><br><span class="line">            p = <span class="variable language_">self</span>.after(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除节点 p&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.left(p) <span class="keyword">and</span> <span class="variable language_">self</span>.right(p):  <span class="comment"># 度为 2 特殊处理</span></span><br><span class="line">            replacement = <span class="variable language_">self</span>._subtree_last_position(<span class="variable language_">self</span>.left(p))  <span class="comment"># 前一个节点</span></span><br><span class="line">            <span class="variable language_">self</span>._replace(p, replacement.element())  <span class="comment"># LinkedBinaryTree 的方法</span></span><br><span class="line">            p = replacement</span><br><span class="line">        <span class="comment"># p 的度为 1 或 0</span></span><br><span class="line">        parent = <span class="variable language_">self</span>.parent(p)</span><br><span class="line">        <span class="variable language_">self</span>._delete(p)  <span class="comment"># LinkedBinaryTree 的方法</span></span><br><span class="line">        <span class="variable language_">self</span>._rebalance_delete(parent)  <span class="comment"># 平衡操作的钩子函数，删除时的平衡变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除键为 k 元素 del M[k]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            p = <span class="variable language_">self</span>._subtree_search(<span class="variable language_">self</span>.root(), k)</span><br><span class="line">            <span class="keyword">if</span> k == p.key():</span><br><span class="line">                <span class="variable language_">self</span>.delete(p)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="variable language_">self</span>._rebalance_access(p)</span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error: &#x27;</span> + <span class="built_in">repr</span>(k))</span><br></pre></td></tr></table></figure><h3 id="1-4-算法分析：二叉搜索树的性能"><a href="#1-4-算法分析：二叉搜索树的性能" class="headerlink" title="1.4 算法分析：二叉搜索树的性能"></a>1.4 算法分析：二叉搜索树的性能</h3><p>分析<strong>搜索</strong>操作时间：</p><ul><li>二叉搜索算法为递归算法，每个递归调用执行常数次操作</li><li>递归调用发生在从根节点向下的一条路径中的每一个节点上</li><li>因此，二叉搜索的运行时间与树的高度 h 有关，为 <strong>O(h)</strong></li></ul><p>分析<strong>插入、删除</strong>操作，依赖于搜索操作，其运行时间也为 <strong>O(h)</strong> 。</p><p>二叉搜索树的性能很大程度上由其高度 h 决定：</p><ul><li>最好情况下，h 为 <strong>O(log n)</strong> ，此时二叉搜索树为高效数据结构，搜索操作运行时间为 <strong>O(log n)</strong></li><li>最坏情况下，二叉搜索树退化为线性的链表，搜索操作运行时间为 <strong>O(n)</strong></li></ul><h3 id="1-5-补充练习：查找最近公共祖先"><a href="#1-5-补充练习：查找最近公共祖先" class="headerlink" title="1.5 补充练习：查找最近公共祖先"></a>1.5 补充练习：查找最近公共祖先</h3><p>给定一个二又搜索树，请设计一个算法，找到该树中两个指定节点的最近公共祖先。</p><p><strong>思路：</strong>对于两个节点 p 和 q ，它们对应的键值为 <code>k1</code> 和 <code>k2</code> ，那么它们的最近的公共祖先。即为从根节点向下寻找，直到找到一个节点的键 <code>k</code> 满足 <code>k1 &lt;= k &lt;= k2</code> 。</p><p>因为二叉搜索树每次分叉 2 个字节点，一定是 <code>左边 &lt; 父节点 &lt; 右边</code> ，所以对于在公共节点前的每个节点，p 和 q 都是在它的一个分支上，所以不是 p q 同时大于它，就是同时小于它。只有当 <code>k1 &lt;= k &lt;= k2</code> 才找到了开始分叉的祖先节点。</p><h2 id="2-平衡搜索树"><a href="#2-平衡搜索树" class="headerlink" title="2 平衡搜索树"></a>2 平衡搜索树</h2><p>注意到，虽然二叉搜索树理论最优是 <strong>O(h) = O(log n)</strong> ，前提是树的结构尽可能矮（即节点尽可能占满前 h - 1 层）。但是每次对二叉搜索树进行插入、删除时，很有可能破坏树的结构，例如退化到一个近似单链的结构，如此就是最坏情况，复杂度为 <strong>O(n)</strong> 。</p><p>为了解决这种问题，介绍更加先进的数据结构：<strong>AVL 树</strong>、<strong>伸展树</strong>、<strong>红黑树</strong>。</p><h3 id="2-1-二叉搜索树的重构"><a href="#2-1-二叉搜索树的重构" class="headerlink" title="2.1 二叉搜索树的重构"></a>2.1 二叉搜索树的重构</h3><p>平衡二叉树的主要操作是<strong>旋转</strong>（zig），及基于旋转的 <strong>trinode 重构</strong>（trinode restructuring）。</p><h4 id="2-1-1-旋转（zig）"><a href="#2-1-1-旋转（zig）" class="headerlink" title="2.1.1 旋转（zig）"></a>2.1.1 旋转（zig）</h4><p>旋转（zig）：将一个孩子节点旋转到其父亲节点上方，左图旋转至右图被称为右旋转（right rotation），反之为左旋转（left rotation）。下图中右旋转后可将子树 T1 的节点深度减 1 ，并将子树T3 的节点深度加 1 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745032358311.png" alt="旋转的例子"></p><h4 id="2-1-2-trinode重构（trinode-restructuring）"><a href="#2-1-2-trinode重构（trinode-restructuring）" class="headerlink" title="2.1.2 trinode重构（trinode restructuring）"></a>2.1.2 trinode重构（trinode restructuring）</h4><p>Trinode重构（trinode restructuring）：考虑对三个节点的操作，使用 1 到 2 次旋转。假设我们考虑的位置为 <code>x</code> ，其父节点为 <code>y</code> ，祖父节点为 <code>z</code> ；以 z 为根节点的树的中序遍历中，这三个节点分别为 <code>a, b, c</code> 。</p><ul><li>目标：重建以 z 为根的子树，缩短到 x 及其子树的总路径长度。</li><li>两种情况需要 1 次旋转（zig -zig），两种情况需要 2 次旋转（zig -zag）。</li></ul><p><code>1.</code> 需要 1 次旋转（single rotation）的情况（zig-zig）：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745032645510.png" alt="需要 1 次旋转（zig -zig）中序遍历的顺序为 a、b、c"></p><p><code>2.</code>需要2次旋转（double rotations）的情况（zig-zag）：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745032723445.png" alt="需要 2 次旋转（zig -zag）中序遍历的顺序为 a、b、c"></p><h3 id="2-2-平衡搜索树的-Python-框架"><a href="#2-2-平衡搜索树的-Python-框架" class="headerlink" title="2.2 平衡搜索树的 Python 框架"></a>2.2 平衡搜索树的 Python 框架</h3><p>之前定义的 <code>TreeMap</code> 类，只是一个具体的映射，不执行显示的平衡操作。下面，我们定义的其他具有平衡操作的类，均继承自 <code>TreeMap</code> 类。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745032900691.png" alt="继承关系框架图" style="zoom:50%;" /></p><h4 id="2-2-1-平衡操作的钩子"><a href="#2-2-1-平衡操作的钩子" class="headerlink" title="2.2.1 平衡操作的钩子"></a>2.2.1 平衡操作的钩子</h4><p>平衡算法的钩子函数，即 <code>MapBase</code> 类暂时未定义的 <code>_rebalance_insert(p)</code> <code>_rebalance_delete(p)</code> 和 <code>_rebalance_access(p)</code> 。它们分别在搜索树插入新元素、删除元素和查看元素时调用（特别地，查看时调用是为了使得更接近根的节点更频繁被访问）。</p><p>在 <code>MapBase</code> 类后为这三个钩子函数存根：即补充三个函数的定义，但具体实现由子类实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapBase</span>(...):</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># --------------- 钩子函数挂钩存根，由子类实现 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_insert</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_delete</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_access</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-旋转和重组的非公开方法"><a href="#2-2-2-旋转和重组的非公开方法" class="headerlink" title="2.2.2 旋转和重组的非公开方法"></a>2.2.2 旋转和重组的非公开方法</h4><p>第二种支持平衡搜索树的形式是非公开的 <code>_rotate</code> 和 <code>_restructure</code> 方法，它们分别实现单一旋转和 trinode 重组。</p><p>在 <code>TreeMap</code> 类后补充这两个方法，让它们被所有平衡树的子类继承，从而促进代码重用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapBase</span>(...):</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># --------------- 单一旋转和 trinode 重组 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_relink</span>(<span class="params">self, parent, child, make_left_child</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;重新链接父节点和子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> make_left_child:</span><br><span class="line">            parent._left = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parent._right = child</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            child._parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rotate</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将子节点 p 旋转上去，p 的父节点选择下来，祖先节点不变&quot;&quot;&quot;</span></span><br><span class="line">        x = p._node</span><br><span class="line">        y = x._parent</span><br><span class="line">        z = y._parent</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>._root = x</span><br><span class="line">            x._parent = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># x 成为 z 的子节点</span></span><br><span class="line">            <span class="variable language_">self</span>._relink(z, x, make_left_child=(y == z._left))</span><br><span class="line">        <span class="keyword">if</span> x == y._left:</span><br><span class="line">            <span class="comment"># x 右子树成为 y 左子节点</span></span><br><span class="line">            <span class="variable language_">self</span>._relink(y, x._right, make_left_child=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># y 成为 x 的右子节点</span></span><br><span class="line">            <span class="variable language_">self</span>._relink(x, y, make_left_child=<span class="literal">False</span>)  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># x 左子树成为 y 的右子节点</span></span><br><span class="line">            <span class="variable language_">self</span>._relink(y, x._left, make_left_child=<span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># y 成为 x 的左子节点</span></span><br><span class="line">            <span class="variable language_">self</span>._relink(x, y, make_left_child=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_restructure</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;trinode 重构：将节点 x 与它的父节点和祖先节点重构&quot;&quot;&quot;</span></span><br><span class="line">        y = <span class="variable language_">self</span>.parent(x)</span><br><span class="line">        z = <span class="variable language_">self</span>.parent(y)</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="variable language_">self</span>.right(y)) == (y == <span class="variable language_">self</span>.right(z)):</span><br><span class="line">            <span class="variable language_">self</span>._rotate(y)  <span class="comment"># 一次旋转 (zig-zig)</span></span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 两次旋转 (zig-zag)</span></span><br><span class="line">            <span class="variable language_">self</span>._rotate(x)</span><br><span class="line">            <span class="variable language_">self</span>._rotate(x)</span><br><span class="line">            <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="3-AVL-树"><a href="#3-AVL-树" class="headerlink" title="3 AVL 树"></a>3 AVL 树</h2><p>在传统的二叉搜索树上施加限制，得到 AVL （Adelson-Velskii and Landis）树，从而保证所有基本映射操作最坏都在对数复杂度下完成。</p><h3 id="3-1-平衡的二叉搜索树"><a href="#3-1-平衡的二叉搜索树" class="headerlink" title="3.1 平衡的二叉搜索树"></a>3.1 平衡的二叉搜索树</h3><h4 id="3-1-1-AVL-树的定义"><a href="#3-1-1-AVL-树的定义" class="headerlink" title="3.1.1 AVL 树的定义"></a>3.1.1 AVL 树的定义</h4><p>对二叉搜索树的定义添加一条规则：对树维持对数的高度。更改高度的定义，叶子节点的高度为 1 ，定义 null 空节点的高度是 0 。任何满足<strong>高度平衡属性</strong>的二叉搜索树被称为 AVL 树（Adelson-Velskii and Landis）。</p><h4 id="3-1-2-高度平衡属性"><a href="#3-1-2-高度平衡属性" class="headerlink" title="3.1.2 高度平衡属性"></a>3.1.2 高度平衡属性</h4><p><strong>高度平衡属性：对树 T 的每一个节点 p ，p 的左右两个子树高度相差最多为 1 。</strong></p><p>例如：下图所示，对任意一个节点，其左右子树的高度相差为 0 或 1 。这里我们定义空节点（即叶子节点的子节点）的子树高度/度为 0 ，图中的 17, 32, 48, 62, 88 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745039817690.png" alt="具有高度平衡属性的 AVL 树的例子"></p><h4 id="3-1-3-数学性质"><a href="#3-1-3-数学性质" class="headerlink" title="3.1.3 数学性质"></a>3.1.3 数学性质</h4><p>由于 AVL 树的高度平衡属性，可以推导出下面的命题：</p><p><strong>命题：一颗存有 n 个节点的 AVL 树的高度是 O(log n) 。</strong></p><p><strong>证明：</strong>设高度 h 的树的节点数为 $n(h)$ 。且容易得到 $n(1) = 1,\ n(2) = 2$ 。对于 $h &gt; 2$ 的情况，如果希望节点数最小，但又满足高度平衡属性，则必有子树高度分别为 $h-1, \ h-2$ 。考虑根节点，则有递推关系式：</p><script type="math/tex; mode=display">n(h) = 1 + n(h-1) + n(h-2)</script><p>由类似斐波那契数列的推导，有：</p><script type="math/tex; mode=display">n(h) > 2 \cdot n(h-2) > 2^2 \cdot n(h-4) > \cdots > 2^i \cdot n(h-2i)</script><p>再结合 $n(1) = 1,\ n(2) = 2$ 可得：</p><script type="math/tex; mode=display">n(h) > 2^{\frac{h}{2} - 1}</script><p>于是有 $h &lt; 2\log(n(h)) + 2$ 。故有 AVL 树的高度是 O(log n) 。</p><h3 id="3-2-更新操作"><a href="#3-2-更新操作" class="headerlink" title="3.2 更新操作"></a>3.2 更新操作</h3><h4 id="3-2-1-插入"><a href="#3-2-1-插入" class="headerlink" title="3.2.1 插入"></a>3.2.1 插入</h4><p>首先以二叉搜索树的插入方式进行插入操作。插入操作可能导致新节点 p 及其祖先处的高度平衡属性被破坏，需要通过 trinode 重构恢复。</p><p>我们通过一个简单的 “查找-修复” 策略来恢复 AVL 树中节点的平衡：</p><ul><li>z 表示从新节点 p 到根的路径上遇到的第一个不平衡位置</li><li>y 表示 z 具有更高高度的孩子（ y 必为 p 的祖先）</li><li><p>x 表示 y 具有更高高度的孩子（ x 必为 p 的祖先或 p 自身）</p></li><li><p>在 x 处进行 trinode 重构，即可使以 z 为根的子树重新平衡</p></li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745040939815.png" alt="插入 54 后的平衡操作"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745041278133.png" alt="抽象化的操作"></p><h4 id="3-2-2-删除"><a href="#3-2-2-删除" class="headerlink" title="3.2.2 删除"></a>3.2.2 删除</h4><p>首先以二叉搜索树的删除方式进行删除操作，被删除节点的父节点 p 到根节点的路径上可能存在一个不平衡的节点，需要通过 trinode 重构恢复高度平衡。</p><p>我们通过一个简单的 “查找-修复” 策略来恢复 AVL 树中节点的平衡：</p><ul><li><p>z 表示从新节点 p 到根的路径上遇到的第一个不平衡位置</p></li><li><p>y 表示 z 具有更高高度的孩子（ y 必不为 p 的祖先 ）</p></li><li>x的定义方式如下：如 y 的两个孩子高度不同，则令 x 为 y 较高的孩子；否则，令 x 为与 y 在同一侧的孩子，即 trinode 重构只需一次旋转</li><li>在 x 处进行 trinode 重构，即可使以 z 为根的子树重新平衡</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745041315182.png" alt="删除 32 后的平衡操作"></p><h4 id="3-2-3-算法分析：AVL-树的性能"><a href="#3-2-3-算法分析：AVL-树的性能" class="headerlink" title="3.2.3 算法分析：AVL 树的性能"></a>3.2.3 算法分析：AVL 树的性能</h4><p>搜索的运行时间为 <strong>O(log n)</strong></p><ul><li>AVL 树的高度为 O(log n) ，搜索不需要 trinode 重构</li></ul><p>插入的运行时间为 <strong>O(log n)</strong></p><ul><li>找到插入位置需要的时间为 O(log n)</li><li>进行一次 trinode 重构需要的时间为 O(1) ，更新节点高度信息需要的时间为 O(log n)</li></ul><p>删除的运行时间为 <strong>O(log n)</strong></p><ul><li>找到删除位置需要的时间为 O(log n)</li><li>进行 trinode 重构需要的时间为 O(log n) ，更新节点高度信息需要的时间为 O(log n)</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1745042913398.png" alt=""></p><h3 id="3-3-Python-实现-AVL"><a href="#3-3-Python-实现-AVL" class="headerlink" title="3.3 Python 实现 AVL"></a>3.3 Python 实现 AVL</h3><p>继承 <code>TreeMap</code> 类，实现 AVL 树的 <code>AVLTreeMap</code> 类。首先为 <code>TreeMap._Node</code> 类补充计算高度的方法。平衡操作的核心方法由 <code>_rebalance()</code> 实现。最后补充平衡操作的钩子函数 <code>_rebalance_insert()</code> 和 <code>_rebalance_delete()</code> 的具体实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .tree_map <span class="keyword">import</span> TreeMap</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> tree_map <span class="keyword">import</span> TreeMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTreeMap</span>(<span class="title class_ inherited__">TreeMap</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;有序映射：AVL 树&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 覆写内嵌的 _Node 节点类 ---------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Node</span>(TreeMap._Node):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;补充节点方法：计算高度&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_height&#x27;</span>  <span class="comment"># 存储高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, element, parent=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;初始化，并增加 _height 存储高度&quot;&quot;&quot;</span></span><br><span class="line">            <span class="built_in">super</span>().__init__(element, parent, left, right)</span><br><span class="line">            <span class="variable language_">self</span>._height = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">left_height</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;左子树高度&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._left._height</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">right_height</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;右子树高度&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._right._height</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 平衡的基础操作 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recompute_height</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算当前节点的高度 h = 1 + max(h_left, h_right)&quot;&quot;&quot;</span></span><br><span class="line">        p._node._height = <span class="number">1</span> + <span class="built_in">max</span>(p._node.left_height(), p._node.right_height())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_isbalanced</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断是否平衡 if |left - right| &lt;= 1&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(p._node.left_height() - p._node.right_height()) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_tall_child</span>(<span class="params">self, p, favorleft=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回更高的子节点：favorleft = True 代表左闭右开&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># favorleft = True 时 left = right 时返回 left</span></span><br><span class="line">        <span class="keyword">if</span> p._node.left_height() + (<span class="number">1</span> <span class="keyword">if</span> favorleft <span class="keyword">else</span> <span class="number">0</span>) &gt; p._node.right_height():</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.left(p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.right(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_tall_grandchild</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回更高的子节点的子节点&quot;&quot;&quot;</span></span><br><span class="line">        child = <span class="variable language_">self</span>._tall_child(p)  <span class="comment"># 更高的子节点</span></span><br><span class="line">        alignment = (child == <span class="variable language_">self</span>.left(p))  <span class="comment"># 判断是否左闭</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._tall_child(child, alignment)  <span class="comment"># 左右相等时偏好方向相同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;平衡操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            old_height = p._node._height</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._isbalanced(p):</span><br><span class="line">                <span class="comment"># TreeMap 方法 trinode 重构</span></span><br><span class="line">                p = <span class="variable language_">self</span>._restructure(<span class="variable language_">self</span>._tall_grandchild(p))</span><br><span class="line">                <span class="comment"># 更新高度</span></span><br><span class="line">                <span class="variable language_">self</span>._recompute_height(<span class="variable language_">self</span>.left(p))</span><br><span class="line">                <span class="variable language_">self</span>._recompute_height(<span class="variable language_">self</span>.right(p))</span><br><span class="line">            <span class="variable language_">self</span>._recompute_height(p)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> p._node._height == old_height:  <span class="comment"># 无变化 -&gt; 已经平衡</span></span><br><span class="line">                p = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = <span class="variable language_">self</span>.parent(p)  <span class="comment"># 从 p 节点向上检查平衡性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------- 平衡操作的钩子函数 ---------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_insert</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="variable language_">self</span>._rebalance(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rebalance_delete</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="variable language_">self</span>._rebalance(p)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本章使用树结构来高效地实现有序映射，例如：二叉搜索树、平衡搜索树、 AVL 树。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>统计软件 R 语言学习笔记 (9) 回归分析：简单线性回归</title>
    <link href="https://blog.iskage.online/posts/bae67ad7.html"/>
    <id>https://blog.iskage.online/posts/bae67ad7.html</id>
    <published>2025-04-17T06:44:00.000Z</published>
    <updated>2025-04-19T08:00:39.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回归分析：简单线性回归"><a href="#回归分析：简单线性回归" class="headerlink" title="回归分析：简单线性回归"></a>回归分析：简单线性回归</h1><p>本章介绍回顾分析的原理，从单变量的简单线性回归为入门，介绍相关理论。利用 R 语言实现线性回归模型的分析。</p><p>代码和笔记存储在 <a href="https://github.com/iskage/r-notes">GitHub 库</a> <strong>【持续更新中，建议 star！】</strong></p><h2 id="1-模型搭建"><a href="#1-模型搭建" class="headerlink" title="1 模型搭建"></a>1 模型搭建</h2><p><strong>简单线性回归模型：</strong></p><script type="math/tex; mode=display">y_i = \beta_0 + \beta_1 \cdot x_i + \epsilon_i,\quad i = 1,\ 2,\ \cdots,\ n</script><ul><li><p>模型中核心部分 $\beta_0 + \beta_1 \cdot x_i$ 称为系统性因素，指的是本质的，重要的，不可忽略的那些因素。</p></li><li><p>模型中非系统性因素 $\epsilon_i$ 称为非系统性因素，指的是相对来说非本质的，不重要的，可忽略的那些因素。</p></li></ul><p>因为自变量只有一个，且模型是线性的，因此我们把该模型称为<strong>简单线性回归模型</strong>。</p><p><strong>随机误差：</strong></p><script type="math/tex; mode=display">\epsilon_i \sim N(0,\ \sigma^2)</script><p>这里 $\epsilon_i $ 代表了系统性因素以外的影响，即非系统性因素，同时它们之间相互独立，且与 $x_i$ 无关。注意：一般假设 $\epsilon_i$ 服从正态分布。</p><p><strong>系统因素：</strong></p><script type="math/tex; mode=display">E(Y_i\ |\ x_i) = \beta_0 + \beta_1 \cdot x_i</script><p>这是因为 $\epsilon_i \sim N(0,\ \sigma^2)$ 故 $E(\epsilon_i) = 0$ ，我们关心的是给定 x 之后对应的 Y 的期望，即这里的 $E(Y_i\ |\ x_i)$ 。特别地，由于 $\beta_0,\ \beta_1,\ x_i$ 为常数，所以 $var(y_i) = 0 + var(\epsilon_i) = \sigma^2$ 称为信噪比。</p><h2 id="2-参数估计"><a href="#2-参数估计" class="headerlink" title="2 参数估计"></a>2 参数估计</h2><h3 id="2-1-参数估计"><a href="#2-1-参数估计" class="headerlink" title="2.1 参数估计"></a>2.1 参数估计</h3><p>首先，明确需要估计的参数：</p><script type="math/tex; mode=display">\beta_0 \quad \beta_1 \quad \sigma^2</script><p>目标：找到一条直线，使得所有观测值到直线的距离平方和最短，即误差最小</p><script type="math/tex; mode=display">\hat{y_i} = \hat{\beta_0} + \hat{\beta_1} \cdot x_i</script><script type="math/tex; mode=display">\min_{\beta_0,\ \beta_1}\ \sum\limits_{i = 1}^n \ (y_i - \hat{y_i})^2 = \sum\limits_{i=1}^n \ (y_i - (\beta_0 + \beta_1 \cdot x_i))^2</script><p>使用<strong>最小二乘法</strong>可以得到参数的估计值为：</p><script type="math/tex; mode=display">\hat{\beta_1} = \frac{\sum\limits_{i=1}^n\ (x_i - \bar{x})(y_i - \bar{y})}{\sum\limits_{i=1}^n \ (x_i - \bar{x})^2}</script><script type="math/tex; mode=display">\hat{\beta_0} = \bar{y} - \bar{x} \cdot \hat{\beta_1}</script><p>其他估计值：</p><ul><li><strong>拟合值估计：</strong> $\hat{y} = \hat{\beta_0} + \hat{\beta_1} \cdot x_i$</li><li><strong>方差估计：</strong> $\hat{\sigma^2} = s^2 = \frac{1}{n-2}\sum_{i=1}^n (y_i - \hat{y_i})^2$</li><li><strong>误差的估计（残差）：</strong> $e_i = y_i - \hat{y_i}$</li></ul><h3 id="2-3-R-语言实现：lm-函数"><a href="#2-3-R-语言实现：lm-函数" class="headerlink" title="2.3 R 语言实现：lm 函数"></a>2.3 R 语言实现：lm 函数</h3><p>使用 <code>lm()</code> 函数直接实现简单线性回归：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple regression</span></span><br><span class="line">student <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">16</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">22</span><span class="punctuation">,</span> <span class="number">26</span><span class="punctuation">)</span></span><br><span class="line">sales <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">58</span><span class="punctuation">,</span> <span class="number">105</span><span class="punctuation">,</span> <span class="number">88</span><span class="punctuation">,</span> <span class="number">118</span><span class="punctuation">,</span> <span class="number">117</span><span class="punctuation">,</span> <span class="number">137</span><span class="punctuation">,</span> <span class="number">157</span><span class="punctuation">,</span> <span class="number">169</span><span class="punctuation">,</span> <span class="number">149</span><span class="punctuation">,</span> <span class="number">202</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">result <span class="operator">&lt;-</span> lm<span class="punctuation">(</span>sales <span class="operator">~</span> student<span class="punctuation">)</span>  <span class="comment"># sales 是 yi 因变量；而 student 是 xi 自变量</span></span><br><span class="line"></span><br><span class="line">summary<span class="punctuation">(</span>result<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>result<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> sales <span class="operator">~</span> student<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">   Min     <span class="number">1</span>Q Median     <span class="number">3</span>Q    Max </span><br><span class="line"><span class="operator">-</span><span class="number">21.00</span>  <span class="operator">-</span><span class="number">9.75</span>  <span class="operator">-</span><span class="number">3.00</span>  <span class="number">11.25</span>  <span class="number">18.00</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>  <span class="number">60.0000</span>     <span class="number">9.2260</span>   <span class="number">6.503</span> <span class="number">0.000187</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">student       <span class="number">5.0000</span>     <span class="number">0.5803</span>   <span class="number">8.617</span> <span class="number">2.55e-05</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">13.83</span> on <span class="number">8</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9027</span><span class="punctuation">,</span>    Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.8906</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">74.25</span> on <span class="number">1</span> and <span class="number">8</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">2.549e-05</span></span><br></pre></td></tr></table></figure><p><strong>1. $\beta$ 的估计值：</strong> <code>Intercept</code> 的第一列表示 $\hat{\beta_0}$ 为 <code>60.0000</code> 。而下一个即为 $\hat{\beta_1}$ 为 <code>5.0000</code> 。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>  <span class="number">60.0000</span>     <span class="number">9.2260</span>   <span class="number">6.503</span> <span class="number">0.000187</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">student       <span class="number">5.0000</span>     <span class="number">0.5803</span>   <span class="number">8.617</span> <span class="number">2.55e-05</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure><p><strong>2. 方差 $\hat{\sigma} = s$ 的估计：</strong> <code>Residual standard error</code> 展示了方差的估计 <code>s = 13.83</code> 。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Residual standard error<span class="operator">:</span> <span class="number">13.83</span> on <span class="number">8</span> degrees of freedom</span><br></pre></td></tr></table></figure><p><strong>3. 查看相关变量：</strong>可以使用 <code>names()</code> 函数查看结果的变量名，然后使用 <code>result$xx</code> 的方式取得 <code>result</code> 的 <code>xx</code> 变量数据。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="built_in">names</span><span class="punctuation">(</span>result<span class="punctuation">)</span></span><br><span class="line"> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;coefficients&quot;</span>  <span class="string">&quot;residuals&quot;</span>     <span class="string">&quot;effects&quot;</span>       <span class="string">&quot;rank&quot;</span>         </span><br><span class="line"> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span> <span class="string">&quot;fitted.values&quot;</span> <span class="string">&quot;assign&quot;</span>        <span class="string">&quot;qr&quot;</span>            <span class="string">&quot;df.residual&quot;</span>  </span><br><span class="line"> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span> <span class="string">&quot;xlevels&quot;</span>       <span class="string">&quot;call&quot;</span>          <span class="string">&quot;terms&quot;</span>         <span class="string">&quot;model&quot;</span>        </span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">names</span><span class="punctuation">(</span>summary<span class="punctuation">(</span>result<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;call&quot;</span>          <span class="string">&quot;terms&quot;</span>         <span class="string">&quot;residuals&quot;</span>     <span class="string">&quot;coefficients&quot;</span> </span><br><span class="line"> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span> <span class="string">&quot;aliased&quot;</span>       <span class="string">&quot;sigma&quot;</span>         <span class="string">&quot;df&quot;</span>            <span class="string">&quot;r.squared&quot;</span>    </span><br><span class="line"> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span> <span class="string">&quot;adj.r.squared&quot;</span> <span class="string">&quot;fstatistic&quot;</span>    <span class="string">&quot;cov.unscaled&quot;</span> </span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> result<span class="operator">$</span>coefficients</span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>     student </span><br><span class="line">         <span class="number">60</span>           <span class="number">5</span> </span><br></pre></td></tr></table></figure><h2 id="3-模型评估"><a href="#3-模型评估" class="headerlink" title="3 模型评估"></a>3 模型评估</h2><h3 id="3-1-模型总体评估"><a href="#3-1-模型总体评估" class="headerlink" title="3.1 模型总体评估"></a>3.1 模型总体评估</h3><p><strong>总平方误差（Total Sum of Squares，SST）：</strong></p><script type="math/tex; mode=display">SST = \sum\limits_{i=1}^n (y_i - \bar{y})^2</script><p><strong>残差平方和（Sum of Squares due to Error，SSE）：</strong></p><script type="math/tex; mode=display">SSE = \sum\limits_{i=1}^n (y_i - \hat{y_i})^2</script><p><strong>回归平方和（Sum of Squares due to Regression，SSR）：</strong></p><script type="math/tex; mode=display">SSR = \sum\limits_{i=1}^n (\hat{y_i} - \bar{y})^2</script><p>这三个指标满足下面的等式：</p><script type="math/tex; mode=display">SST = SSR + SSE</script><p><strong>模型总体评估：$R^2$</strong></p><script type="math/tex; mode=display">R^2 = \frac{SSR}{SST}</script><p>从直觉上判断，当 $R^2$ 越大（越接近 1），说明模型的误差对真实误差的占比更高，模型解释性更强。即，我们希望模型的 $R^2$ 尽可能的接近 1 。</p><p><strong>从 R 语言结果中查看：</strong>可见 <code>R-squared = 0.9027</code> 代表了 $R^2$ ，后面的 <code>Adjusted R-squared = 0.8906</code> 代表了调整 $R^2$ ，调整之后更多的反应了综合水平，加入考虑了模型过于复杂的情况（例如：当自变量 xi 过多；模型过于复杂，过拟合也是不佳的）。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.9027</span><span class="punctuation">,</span>    Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.8906</span> </span><br></pre></td></tr></table></figure><h3 id="3-2-模型参数的评估"><a href="#3-2-模型参数的评估" class="headerlink" title="3.2 模型参数的评估"></a>3.2 模型参数的评估</h3><p>进一步观察 $\hat{\beta_0},\ \hat{\beta_1}$ 的统计推断：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>  <span class="number">60.0000</span>     <span class="number">9.2260</span>   <span class="number">6.503</span> <span class="number">0.000187</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">student       <span class="number">5.0000</span>     <span class="number">0.5803</span>   <span class="number">8.617</span> <span class="number">2.55e-05</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure><ul><li><code>Std. Error</code> 代表了参数 $\beta$ 的标准差估计</li><li><code>t value</code> 和 <code>Pr(&gt;|t|)</code> 代表了对与 $H_0: \beta_i = 0$ 的假设检验（特别的，这里的 p 值均小于 0.05 故大致可以认为自变量 <code>student</code> 确实对因变量 <code>sales</code> 存在线性关系）</li></ul><p>特别地，当误差 $\epsilon_i$ 满足正态分布时，参数也满足分布：</p><script type="math/tex; mode=display">\hat{\beta_i} \sim N(\beta_i,\ \sigma_i^2)</script><p>其中 $\sigma_i^2$ 未知，只能通过样本方差估计。故有：</p><script type="math/tex; mode=display">\frac{\hat{\beta_i} - \beta_i}{s_i} \sim t(n-2)</script><p>特别地，简单线性回归模型是单一变量，故模型整体的假设检验也等价于 $H_0: \beta_1 = 0$ 的检验：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">74.25</span> on <span class="number">1</span> and <span class="number">8</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="number">2.549e-05</span></span><br></pre></td></tr></table></figure><p>这里的 p 值为 <code>2.549e-05 &lt; 0.05</code> 故拒绝原假设。</p><h2 id="4-模型假设的检验"><a href="#4-模型假设的检验" class="headerlink" title="4 模型假设的检验"></a>4 模型假设的检验</h2><p><strong>模型假设一：</strong> $\epsilon_i,\ i=1,\ 2,\ \cdots,\ n$ 相互独立，均值为 0 ，方差相同，且与 $x_i$ 无关。</p><p><strong>模型假设二：</strong>一般假设 $\epsilon_i$ 服从正态分布</p><p>检查误差/残差的正态性和相关性：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">png<span class="punctuation">(</span><span class="string">&quot;img/ei.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">1200</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">500</span><span class="punctuation">,</span> res <span class="operator">=</span> <span class="number">150</span><span class="punctuation">)</span></span><br><span class="line">op <span class="operator">&lt;-</span> par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 残差 ei 的散点分布</span></span><br><span class="line">plot<span class="punctuation">(</span>result<span class="operator">$</span>residuals<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Residuals, ei scatters plot&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查残差 ei 是否与 xi 相关（残差是误差的估计）</span></span><br><span class="line">plot<span class="punctuation">(</span>student<span class="punctuation">,</span> result<span class="operator">$</span>residuals<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Students v.s. Residuals, xi vs ei&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查残差 ei 是否近似正态（残差是误差的估计）</span></span><br><span class="line">qqnorm<span class="punctuation">(</span>result<span class="operator">$</span>residuals<span class="punctuation">)</span></span><br><span class="line">qqline<span class="punctuation">(</span>result<span class="operator">$</span>residuals<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>op<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/ei.png" alt=""></p><p>其他：</p><ul><li><p>A plot of residuals versus fitted (predicted) values ：类似 resid vs x 。希望没有任何趋势。</p></li><li><p>A normal quantile-quantile plot of the standardized residuals 。希望基本成一直线。</p></li><li>A scale-location plot ：类似 resid vs x 。希望没有任何趋势。</li><li>A Cook’s distance plot 库克距离：如果某一条数据被排除在外，那么由此造成的回归系数变化有多大。如果 Cook 距离过大，那么就表明这条数据对回归系数的计算产生了明显的影响，这条数据就有可能是是异常数据。如果 Cook 距离大于 0.5 ， 那么这个点就有可能是强影响点；如果 Cook 距离大于 1 ，那么这个点就非常有可能是强影响点，必须得到关注。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他</span></span><br><span class="line">png<span class="punctuation">(</span><span class="string">&quot;img/others.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">1200</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">1200</span><span class="punctuation">,</span> res <span class="operator">=</span> <span class="number">200</span><span class="punctuation">)</span></span><br><span class="line">op <span class="operator">&lt;-</span> par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>result<span class="punctuation">,</span> which <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>op<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/others.png" style="zoom:50%;" /></p><h2 id="5-拟合和预测"><a href="#5-拟合和预测" class="headerlink" title="5 拟合和预测"></a>5 拟合和预测</h2><h3 id="5-1-R-语言实现"><a href="#5-1-R-语言实现" class="headerlink" title="5.1 R 语言实现"></a>5.1 R 语言实现</h3><p><code>predict()</code> 函数实现预测，格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predict<span class="punctuation">(</span></span><br><span class="line">    object<span class="punctuation">,</span></span><br><span class="line">    newdata<span class="punctuation">,</span></span><br><span class="line">    interval <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;none&quot;</span><span class="punctuation">,</span> <span class="string">&quot;confidence&quot;</span><span class="punctuation">,</span> <span class="string">&quot;prediction&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">    level <span class="operator">=</span> <span class="number">0.95</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> object<span class="operator">:</span> 某个线性模型，lm<span class="punctuation">(</span><span class="punctuation">)</span> 的结果。如 result1 <span class="operator">=</span> lm<span class="punctuation">(</span>sales <span class="operator">~</span> student<span class="punctuation">)</span></span><br><span class="line"><span class="operator">-</span> newdata<span class="operator">:</span> 某个变量名跟原来线性模型中自变量一致的数据框。如 new <span class="operator">=</span> data.frame<span class="punctuation">(</span>student <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>例如：</p><p><strong>1. 预测问题：</strong>选择 <code>interval = &quot;prediction&quot;</code> 点估计相同为 <code>fit = 110</code> ，但此时给出的置信区间为预测区间 <code>Prediction Interval, PI</code> 给出的是对预测值的置信区间 <code>lwr, upr</code> 。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 预测</span></span><br><span class="line"><span class="operator">&gt;</span> new <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>student <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> predict<span class="punctuation">(</span>result<span class="punctuation">,</span> new<span class="punctuation">,</span> interval <span class="operator">=</span> <span class="string">&quot;prediction&quot;</span><span class="punctuation">,</span> level <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">)</span></span><br><span class="line">  fit      lwr      upr</span><br><span class="line"><span class="number">1</span> <span class="number">110</span> <span class="number">76.12745</span> <span class="number">143.8725</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> new <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>student <span class="operator">=</span> <span class="number">18</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> predict<span class="punctuation">(</span>result<span class="punctuation">,</span> new<span class="punctuation">,</span> interval <span class="operator">=</span> <span class="string">&quot;prediction&quot;</span><span class="punctuation">,</span> level <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">)</span></span><br><span class="line">  fit      lwr      upr</span><br><span class="line"><span class="number">1</span> <span class="number">150</span> <span class="number">116.1275</span> <span class="number">183.8725</span></span><br></pre></td></tr></table></figure><p><strong>2. 估计问题：</strong>选择 <code>interval = &quot;confidence&quot;</code> 点估计相同为 <code>fit = 110</code> ，但此时给出的置信区间为对期望 $E(y)$ 的置信区间 <code>Confidence Interval, CI</code> 是因变量期望的置信区间 <code>lwr, upr</code>  。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 估计/拟合</span></span><br><span class="line"><span class="operator">&gt;</span> new <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>student <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> predict<span class="punctuation">(</span>result<span class="punctuation">,</span> new<span class="punctuation">,</span> interval <span class="operator">=</span> <span class="string">&quot;confidence&quot;</span><span class="punctuation">,</span> level <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">)</span></span><br><span class="line">  fit      lwr     upr</span><br><span class="line"><span class="number">1</span> <span class="number">110</span> <span class="number">98.58299</span> <span class="number">121.417</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> new <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>student <span class="operator">=</span> <span class="number">18</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> predict<span class="punctuation">(</span>result<span class="punctuation">,</span> new<span class="punctuation">,</span> interval <span class="operator">=</span> <span class="string">&quot;confidence&quot;</span><span class="punctuation">,</span> level <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">)</span></span><br><span class="line">  fit     lwr     upr</span><br><span class="line"><span class="number">1</span> <span class="number">150</span> <span class="number">138.583</span> <span class="number">161.417</span></span><br></pre></td></tr></table></figure><h3 id="5-2-理论分析"><a href="#5-2-理论分析" class="headerlink" title="5.2 理论分析"></a>5.2 理论分析</h3><p><strong>拟合值：</strong>对原来的数据中 $x_0$ ，给出拟合值，包括估计水平为 0.95 的置信区间</p><ul><li>真值：$E(y_0) = \beta_0 + \beta_1 \cdot x_0$</li><li>置信区间：$P(L \leq E(y_0) = \beta_0 + \beta_1 \cdot x_0 \leq U) = 1 - \alpha$</li></ul><p>根据如下结论：</p><script type="math/tex; mode=display">var(\hat{y_0}) = var(\hat{\beta_0} + \hat{\beta_1}\cdot x_0) = \sigma^2(\frac{1}{n} + \frac{(x_0 - \bar{x})^2}{s_{xx}}) = sd(\hat{y})</script><script type="math/tex; mode=display">(n-2)\hat{\sigma^2} \sim \sigma^2 \cdot \chi^2(n-2)</script><script type="math/tex; mode=display">\frac{\hat{y_0} - (\beta_0 + \beta_1 \cdot x_0)}{\sqrt{var(\hat{y_0})}} \sim t(n-2)</script><p>于是，置信区间为：</p><script type="math/tex; mode=display">CI = \left[\quad \hat{\beta_0} + \hat{\beta_1}\cdot x_0 \pm t_{\alpha/2}(n-2)\cdot\hat{\sigma}\sqrt{\frac{1}{n} + \frac{(x_0 - \bar{x})^2}{s_{xx}}}\quad \right]</script><p><strong>预测值：</strong>对一个新的观测值 $x’ \notin {x<em>i}</em>{i=1,\, 2,\ \cdots,\ n}$，给出预测值，包括水平为 0.95 的预测区间</p><ul><li>真实值（随机变量）：$y’ = \beta_0 + \beta_1\cdot x’ + \epsilon$</li><li>点预测：$\hat{y’} = \hat{\beta_0} + \hat{\beta_1}\cdot x’$</li><li>预测区间：$P(L \leq y’ = \beta_0 + \beta_1\cdot x’ + \epsilon \leq U) = 1 - \alpha$</li></ul><p>根据如下结论：</p><script type="math/tex; mode=display">y' \ \bot \ y</script><script type="math/tex; mode=display">y' - \hat{y'} \sim N(\beta_0 + \beta_1 \cdot x',\ \sigma^2(1 + \frac{1}{n} + \frac{(x'- \bar{x})^2}{s_{xx}}))</script><script type="math/tex; mode=display">\frac{\hat{\beta_0} + \hat{\beta_1}\cdot x' - (\beta_0 + \beta_1\cdot x' + \epsilon)}{\hat{\sigma}\sqrt{1 + \frac{1}{n} + \frac{(x'- \bar{x})^2}{s_{xx}}}} \sim t(n-2)</script><p>于是，预测区间为：</p><script type="math/tex; mode=display">PI = \left[\quad \hat{\beta_0} + \hat{\beta_1}\cdot x' \pm t_{\alpha/2}(n-2)\cdot \hat{\sigma}\sqrt{1 + \frac{1}{n} + \frac{(x'- \bar{x})^2}{s_{xx}}} \quad \right]</script><p><strong>总结：</strong></p><ul><li><p>拟合值的置信区间：给定自变量 x 的值时，响应变量的期望可能落入的范围，这是一个估计问题。</p></li><li><p>预测值的预测区间：给定自变量 x 的值时，单个响应变量可能落入的范围，这是一个预测问题。</p></li><li>预测区间 <code>PI</code> 总是要比对应的置信区间 <code>CI</code> 大。</li></ul>]]></content>
    
    
    <summary type="html">本章介绍回顾分析的原理，从单变量的简单线性回归为入门，介绍相关理论。利用 R 语言实现线性回归模型的分析。</summary>
    
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/categories/R-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/tags/R-%E8%AF%AD%E8%A8%80/"/>
    
    <category term="统计软件" scheme="https://blog.iskage.online/tags/%E7%BB%9F%E8%AE%A1%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="R programming" scheme="https://blog.iskage.online/tags/R-programming/"/>
    
  </entry>
  
  <entry>
    <title>有序映射：排序检索表、跳跃表</title>
    <link href="https://blog.iskage.online/posts/f16f683a.html"/>
    <id>https://blog.iskage.online/posts/f16f683a.html</id>
    <published>2025-04-16T00:16:00.000Z</published>
    <updated>2025-04-19T08:00:39.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有序映射：排序检索表、跳跃表"><a href="#有序映射：排序检索表、跳跃表" class="headerlink" title="有序映射：排序检索表、跳跃表"></a>有序映射：排序检索表、跳跃表</h1><p>本章补充部分有关映射的知识——有序映射，主要讲解了线性结构实现有序映射的方法，如排序检索表。介绍了一种新颖的实现方法——跳跃表。不过，更好的实现推荐使用搜索树这种非线形结构。</p><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><h2 id="1-有序映射"><a href="#1-有序映射" class="headerlink" title="1 有序映射"></a>1 有序映射</h2><h3 id="1-1-有序映射的抽象数据类型"><a href="#1-1-有序映射的抽象数据类型" class="headerlink" title="1.1 有序映射的抽象数据类型"></a>1.1 有序映射的抽象数据类型</h3><p>传统的映射 ADT 允许用户查找与给定键关联的值，这种键的查找被称为精确查找。在这一部分，我们介绍一个称为有序映射的映射 ADT 的扩展，它包括标准映射的所有行为，还增加了以下方法：</p><ul><li><code>M.find_min()</code> ：用最小键返回键值对（或None，如果映射为空）</li><li><code>M.find_max()</code> ：用最大键返回键值对（或 None，如果映射为空）</li><li><code>M.find_It(k)</code> ：用严格小于 k 的最大键返回键值对（或 None，若没有这样的项存在）</li><li><code>M.find_le(k)</code> :用严格小于等于 k 的最大键返回键值对（或 None，若没有这样的项存在）</li><li><code>M.find_gt(k)</code> ：用严格大于 k 的最小的键返回键值对（或 None，若没有这样的项存在）</li><li><code>M.fnd_ge(k)</code> ：用严格大于或等于 k 的最小的键返回键值对（或None，若没有这样的项存在）</li><li><p><code>M.fnd_range(start, stop)</code> ：用 start &lt;= 键 &lt; stop 迭代遍历所有键值对。如果 start 指定<br>  为 None ，从最小的键开始迭代；如果 stop 指定 None，到最大键迭代结束</p></li><li><p><code>iter(M)</code> ：根据自然顺序从最小到最大迭代遍历映射中的所有键</p></li><li><p><code>reversed(M)</code> ：根据逆序迭代映射中的所有键 r ，这在 Python 中是用 reversed 来实现的</p></li></ul><h3 id="1-2-排序检索表"><a href="#1-2-排序检索表" class="headerlink" title="1.2 排序检索表"></a>1.2 排序检索表</h3><p>一些先进的技术可以支持排序映射 ADT，例如二叉搜索树。在本节中，我们从探索一个简单有序映射的实现开始。我们将映射的元组存储在一个基于数组的序列 A 中，以键的升序排列，我们将这个映射实现称为<strong>排序检索表（sorted search table）</strong>。如此可以根据二分查找来实现相关操作。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744803543695.png" alt=""></p><h4 id="1-2-1-Python-实现"><a href="#1-2-1-Python-实现" class="headerlink" title="1.2.1 Python 实现"></a>1.2.1 Python 实现</h4><p><code>MapBase</code> 类是映射的基类，实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> collections.abc <span class="keyword">import</span> MutableMapping  <span class="comment"># Python 3.3+</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> MutableMapping  <span class="comment"># Python 2.7 - 3.2 (已废弃)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapBase</span>(<span class="title class_ inherited__">MutableMapping</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;映射 Map 的基础父类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- 嵌套的 _Item 类，存储键值对 ----------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Item</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储键值对&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_key&#x27;</span>, <span class="string">&#x27;_value&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k, v</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;初始化键值对&quot;&quot;&quot;</span></span><br><span class="line">            <span class="variable language_">self</span>._key = k</span><br><span class="line">            <span class="variable language_">self</span>._value = v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;a == b 等价于 a 和 b 键值相等&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._key == other._key</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;a != b 等价于 a 和 b 键值不等&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> (<span class="variable language_">self</span> == other)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;比较键值&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._key &lt; other._key</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">value</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">key</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._key</span><br></pre></td></tr></table></figure><p>继承 <code>MapBase</code> 类，实现有序映射，采用数字/列表的方式存储，每次插入都使用二分查找的方式，最终得到一个有序映射（有序列表，排序按照 key 从小到大）。核心在于 <code>_find_index</code> 二分查找方法的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortedTableMap</span>(<span class="title class_ inherited__">MapBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;有序映射：有序数组实现&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------- 非公有方法 -------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find_index</span>(<span class="params">self, k, low, high</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;二分查找：最左边且 &gt;= k&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> high &lt; low:</span><br><span class="line">            <span class="keyword">return</span> high + <span class="number">1</span>  <span class="comment"># 未找到</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid = (high + low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="variable language_">self</span>._table[mid]._key:  <span class="comment"># 找到对应的键</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> k &lt; <span class="variable language_">self</span>._table[mid]._key:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>._find_index(k, low, mid - <span class="number">1</span>)  <span class="comment"># 二分查找递归</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>._find_index(k, mid + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------- 公有方法 -------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化列表存储&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._table = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._table)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找键为 k&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._find_index(k, <span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>._table) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(<span class="variable language_">self</span>._table) <span class="keyword">or</span> <span class="variable language_">self</span>._table[j]._key != k:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error: &#x27;</span> + <span class="built_in">repr</span>(k))  <span class="comment"># 没有找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._table[j]._value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, k, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;插入/修改元素&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._find_index(k, <span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>._table) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>._table) <span class="keyword">and</span> <span class="variable language_">self</span>._table[j]._key == k:</span><br><span class="line">            <span class="variable language_">self</span>._table[j]._value = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>._table.insert(j, <span class="variable language_">self</span>._Item(k, v))  <span class="comment"># 在 j 位置插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._find_index(k, <span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>._table) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(<span class="variable language_">self</span>._table) <span class="keyword">or</span> <span class="variable language_">self</span>._table[j]._key != k:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error: &#x27;</span> + <span class="built_in">repr</span>(k))  <span class="comment"># 没有找到元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._table.pop(j)  <span class="comment"># 删除并返回被删除的 _Item 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器饿的方式返回键&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable language_">self</span>._table:</span><br><span class="line">            <span class="keyword">yield</span> item._key</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reversed__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;反向返回序列&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="variable language_">self</span>._table):</span><br><span class="line">            <span class="keyword">yield</span> item._key</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回键值对 (k, v) 最小的 k&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._table) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 有序映射：第一个即为最小</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">self</span>._table[<span class="number">0</span>]._key, <span class="variable language_">self</span>._table[<span class="number">0</span>]._value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_max</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回最大键值的 (k, v)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._table) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 有序映射：最后一个即为最大</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">self</span>._table[-<span class="number">1</span>]._key, <span class="variable language_">self</span>._table[-<span class="number">1</span>]._value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_lt</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到 k 的前一个&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._find_index(k, <span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>._table) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">self</span>._table[j - <span class="number">1</span>]._key, <span class="variable language_">self</span>._table[j - <span class="number">1</span>]._value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_gt</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到 k 的后一个&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._find_index(k, <span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>._table) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>._table) <span class="keyword">and</span> <span class="variable language_">self</span>._table[j]._key == k:</span><br><span class="line">            <span class="comment"># 避免出界</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>._table):</span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">self</span>._table[j]._key, <span class="variable language_">self</span>._table[j]._value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_range</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器的方式返回 start &lt;= key &lt; stop&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = <span class="variable language_">self</span>._find_index(start, <span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>._table) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>._table) <span class="keyword">and</span> (stop <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="variable language_">self</span>._table[j]._key &lt; stop):</span><br><span class="line">                <span class="keyword">yield</span> (<span class="variable language_">self</span>._table[j]._key, <span class="variable language_">self</span>._table[j]._value)</span><br><span class="line">                j += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stm = SortedTableMap()</span><br><span class="line"></span><br><span class="line">    n = <span class="number">16</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">f&quot;Add <span class="subst">&#123;n&#125;</span> (key, value) for test&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> new <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        stm[new + <span class="number">1</span>] = <span class="string">&quot;test&quot;</span> + <span class="built_in">str</span>(new + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key = 6, then Value =&quot;</span>, stm[<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">    start, stop = <span class="number">2</span>, <span class="number">8</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">f&quot;From <span class="subst">&#123;start&#125;</span> to <span class="subst">&#123;stop&#125;</span>&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> stm.find_range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">    key, value = -<span class="number">4</span>, <span class="string">&quot;Smallest&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">f&quot;Add a new one (<span class="subst">&#123;key&#125;</span>, <span class="subst">&#123;value&#125;</span>) and find it&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    stm[key] = value</span><br><span class="line">    <span class="built_in">print</span>(stm.find_min())</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== Add 16 (key, value) for test ===============</span></span><br><span class="line"><span class="comment"># Key = 6, then Value = test6</span></span><br><span class="line"><span class="comment"># =============== From 2 to 8 ===============</span></span><br><span class="line"><span class="comment"># (1, &#x27;test1&#x27;)</span></span><br><span class="line"><span class="comment"># (2, &#x27;test2&#x27;)</span></span><br><span class="line"><span class="comment"># (3, &#x27;test3&#x27;)</span></span><br><span class="line"><span class="comment"># (4, &#x27;test4&#x27;)</span></span><br><span class="line"><span class="comment"># (5, &#x27;test5&#x27;)</span></span><br><span class="line"><span class="comment"># =============== Add a new one (-4, Smallest) and find it ===============</span></span><br><span class="line"><span class="comment"># (-4, &#x27;Smallest&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-算法分析"><a href="#1-2-2-算法分析" class="headerlink" title="1.2.2 算法分析"></a>1.2.2 算法分析</h4><p>由于二分查找的性质，查找某个特定元素的复杂度为 <strong>O(log n)</strong> ，无论是查找 <code>k == key</code> 还是查看这个元素的前后。但对于 <code>M[k] = v</code> 因为存储找不到 <code>k == key</code> 的情况，即需要插入元素，此时复杂度为 <strong>O(n)</strong> 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744805526278.png" alt="有序映射：采用排序检索表这种线性结构实现的时间复杂度"></p><h2 id="2-跳跃表"><a href="#2-跳跃表" class="headerlink" title="2 跳跃表"></a>2 跳跃表</h2><p>数组实现有序映射在插入元素时复杂度为 O(n) ，而链表实现无法通过二分查找提高效率。<strong>跳跃表</strong>提供一个聪明的折衷方式以有效地支持查找和更新操作。</p><p>一个映射 M 的跳跃表 S 包含一列表序列 <code>&#123;S0, S1, ..., Sh&#125;</code> 。每一个列表 <code>Si</code> 依照键的升序存储着 M 的一个元组子集，用两个标注为 <code>-inf</code> 和 <code>+inf</code> 的哨兵键追加元组，其中 <code>inf</code> 表示无穷。此外，列表 S 还要满足下面的条件：</p><ul><li>列表 <code>S0</code> 包含映射 M 中的每一项 (包含 -inf 和 +inf)</li><li>对于 <code>i = 1, 2, ..., h - 1</code> 列表 <code>S&#123;i&#125;</code> 包含一个列表 <code>S&#123;i-1&#125;</code>随机生成的元组的子集（还有-∞和＋8）。</li><li>列表 <code>Sh</code> 仅包含 -inf 和 +inf</li></ul><p>一个跳跃表如图所示。在列表 S 中，列表 <code>S0</code> 在最底部，在 <code>S0</code> 之上有列表 <code>S1, S2, ..., Sh</code> 并且，我们称 h 为列表 S 的高度。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744807762142.png" alt=""></p><p>列表 <code>S&#123;i+1&#125;</code> 的元素从 <code>S&#123;i&#125;</code> 中选取，按照每一个元素 1/2 的概率，于是 <code>S&#123;i+1&#125;</code> 的长度大致为 <code>S&#123;i&#125;</code> 的一半。如此列表 S 的长度为 <strong>h = log n</strong> 。</p><p>我们视跳跃表为一个<strong>水平组织成层（level）、垂直组织成塔（tower）</strong>的二维位置集合。每个水平层是一个列表 <code>Si</code> ，每个垂直塔包含了存储着相同元组的位置，这些元组跨越连续的列表。可以使用以下操作遍历跳跃表中的每个位置：</p><ul><li><code>next(p)</code> ：返回在同一水平层位置上紧接着 p 的位置。</li><li><code>prev(p)</code> ：返回在同一水平层位置上在 p 之前的位置。</li><li><code>below(p)</code> ：返回在同一垂直塔位置上在 p 下面的位置。</li><li><code>above(p)</code> ：返回在同一垂直塔位置上在 p 上面的位置。</li></ul><p>我们注意到可以通过链结构简单地实现一个跳跃表，给定一个跳跃表 p 的位置，每一个单独的遍历方法需要 <strong>O(1)</strong> 时间，这样的链结构本质上是在垂直塔方向上对齐的双链表集合。</p>]]></content>
    
    
    <summary type="html">本章补充部分有关映射的知识——有序映射，主要讲解了线性结构实现有序映射的方法，如排序检索表。介绍了一种新颖的实现方法——跳跃表。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>SQL 自学笔记（13）视图</title>
    <link href="https://blog.iskage.online/posts/4761994e.html"/>
    <id>https://blog.iskage.online/posts/4761994e.html</id>
    <published>2025-04-15T09:24:00.000Z</published>
    <updated>2025-04-19T08:00:39.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是一种虚拟表，本身不存储数据，占用很少的内存空间，可以理解为存储查询语句的对象。本章介绍视图的概念，如何创建视图，查看、更新视图的数据，以及修改和删除视图本身。</p><p>代码和笔记存储在我的 <a href="https://github.com/isKage/sql-notes">Github 仓库</a> 【持续更新中，建议 star ！】</p><h2 id="1-视图概述"><a href="#1-视图概述" class="headerlink" title="1 视图概述"></a>1 视图概述</h2><h3 id="1-1-数据库对象"><a href="#1-1-数据库对象" class="headerlink" title="1.1 数据库对象"></a>1.1 数据库对象</h3><div class="table-container"><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>表 <code>TABLE</code></td><td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，只可查看，不建议修改</td></tr><tr><td>约束 <code>CONSTRAINT</code></td><td>执行数据校验的规则，用于保证数据完整性的规则</td></tr><tr><td>视图 <code>VIEW</code></td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引 <code>INDEX</code></td><td>用于提高查询性能，相当于书的目录</td></tr><tr><td>存储过程 <code>PROCEDURE</code></td><td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数 <code>FUNCTION</code></td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器 <code>TRIGGER</code></td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table></div><h3 id="1-2-视图"><a href="#1-2-视图" class="headerlink" title="1.2 视图"></a>1.2 视图</h3><p><strong>视图：</strong>是一种 <em>虚拟表</em> ，本身是 <em>不具有数据的</em> ，占用很少的内存空间。视图建立在已有表的基础上, 视图赖以建立的这些表称为<strong>基表</strong>。</p><ul><li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li><li>向视图提供数据内容的语句为 <code>SELECT</code> 语句, 可以将视图理解为存储起来的 SELECT 语句</li><li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。</li></ul><h2 id="2-创建视图"><a href="#2-创建视图" class="headerlink" title="2 创建视图"></a>2 创建视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE]</span><br><span class="line">[ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> 视图名称 [(字段列表)]</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure><ul><li><code>OR REPLACE</code> ：如果视图已存在，则替换它</li><li><code>ALGORITHM</code> ：指定 MySQL 处理视图的算法</li><li>字段列表（可选）：为视图的列指定自定义名称</li><li><code>WITH CHECK OPTION</code> ：确保通过视图修改的数据符合视图定义的条件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> 查询语句;</span><br></pre></td></tr></table></figure><h3 id="2-1-创建单表视图"><a href="#2-1-创建单表视图" class="headerlink" title="2.1 创建单表视图"></a>2.1 创建单表视图</h3><p>例如：创建视图，查找 employees 表中 department_id = 80 的 employee_id, last_name, salary 字段信息。这里相当于存储了一个 SELECT 查询语句，在后面调用时，自动展示视图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_dept_id80</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure><p>使用 SELECT 语句查看视图名称 emp_dept_id80 的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp_dept_id80;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744705154256.png" alt=""></p><p>再例如：指定字段名 (emp_name, year_salary) 即为从表 employees 取出的数据进行列名重命名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_year_salary (emp_name, year_salary)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name, salary <span class="operator">*</span> <span class="number">12</span> <span class="operator">*</span> (<span class="number">1</span> <span class="operator">+</span> IFNULL(commission_pct, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>最后会展示新的列名 emp_name 代表 last_name 而 year_salary 代表 salary <em> 12 </em> (1 + IFNULL(commission_pct, 0))</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp_year_salary;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> emp_name    <span class="operator">|</span> year_salary <span class="operator">|</span>  <span class="comment">-- 新的列名</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> King        <span class="operator">|</span>   <span class="number">288000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Kochhar     <span class="operator">|</span>   <span class="number">204000.00</span> <span class="operator">|</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>第一个语句，相当于在 SQL 中封装了视图 VIEW 。这样再次调用时，就会基于 SQL 语句的结果形成一张虚拟表。</p></blockquote><h3 id="2-2-创建多表联合视图"><a href="#2-2-创建多表联合视图" class="headerlink" title="2.2 创建多表联合视图"></a>2.2 创建多表联合视图</h3><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_dept_name</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> e.employee_id emp_id, e.last_name emp_name, d.department_name dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,</span><br><span class="line">     departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> dept_sal (dept_name, min_sal, max_sal, avg_sal)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> d.department_name, <span class="built_in">MIN</span>(e.salary), <span class="built_in">MAX</span>(e.salary), <span class="built_in">AVG</span>(e.salary)</span><br><span class="line"><span class="keyword">FROM</span> employees e,</span><br><span class="line">     departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.department_name;</span><br></pre></td></tr></table></figure><h3 id="2-3-利用视图进行格式化"><a href="#2-3-利用视图进行格式化" class="headerlink" title="2.3 利用视图进行格式化"></a>2.3 利用视图进行格式化</h3><p>例如：输出员工姓名和对应的部门名，对应格式为 <code>&quot;emp_name(department_name)&quot;</code> ，就可以使用视图来完成数据格式化的操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> employee_department_name</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(e.last_name, <span class="string">&#x27;(&#x27;</span>, d.department_name, <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> emp_dept</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line">         <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employee_department_name;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> emp_dept                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> Whalen(Administration)  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Hartstein(Marketing)    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Fay(Marketing)          <span class="operator">|</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-4-基于视图创建视图"><a href="#2-4-基于视图创建视图" class="headerlink" title="2.4 基于视图创建视图"></a>2.4 基于视图创建视图</h3><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。例如：联合 <code>emp_dept_name</code> 视图和 <code>emp_year_salary</code> 视图查询员工姓名、部门名称、年薪信息创建 <code>emp_dept_year_salary</code> 视图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_dept_year_salary</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> edn.emp_name, edn.dept_name, eys.year_salary</span><br><span class="line"><span class="keyword">FROM</span> emp_dept_name <span class="keyword">AS</span> edn</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> emp_year_salary <span class="keyword">AS</span> eys</span><br><span class="line">                    <span class="keyword">ON</span> edn.emp_name <span class="operator">=</span> eys.emp_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp_dept_year_salary;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744706732277.png" alt=""></p><h2 id="3-查看视图"><a href="#3-查看视图" class="headerlink" title="3 查看视图"></a>3 查看视图</h2><p><strong>1. 查看数据库的表对象、视图对象</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES; <span class="comment">-- 视图和表都会展示</span></span><br></pre></td></tr></table></figure><p><strong>2. 查看视图的结构</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 视图名称;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> emp_dept_year_salary;</span><br><span class="line"><span class="keyword">DESCRIBE</span> emp_dept_year_salary;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field       <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> emp_name    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">25</span>)  <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> dept_name   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">30</span>)  <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> year_salary <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">19</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>3. 查看视图的属性信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> &quot;视图名称&quot;;  <span class="comment">-- 一定要用 &quot;&quot; 包裹</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> &quot;emp_dept_year_salary&quot;;</span><br><span class="line"><span class="comment">-- 其中 Comment 为 VIEW -&gt; 说明为视图</span></span><br></pre></td></tr></table></figure><p><strong>4. 查看视图的详细定义信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_dept_year_salary;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744707161426.png" alt=""></p><h2 id="4-更新视图的数据"><a href="#4-更新视图的数据" class="headerlink" title="4 更新视图的数据"></a>4 更新视图的数据</h2><p>使用 <code>INSERT</code> <code>UPDATE</code> 和 <code>DELETE</code> 语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。（与正常对表操作的使用方法相同）</p><h3 id="4-1-可更新的视图"><a href="#4-1-可更新的视图" class="headerlink" title="4.1 可更新的视图"></a>4.1 可更新的视图</h3><p>为展示例子，先创建表和视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> view_test</span><br><span class="line">(</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    age  <span class="type">INT</span>,</span><br><span class="line">    tel  <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. INSERT: 插入一些数据后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_changed</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> view_test</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>此时的表结果为 <code>view_test</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> view_test;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> tel         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Mike   <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span> <span class="number">12345678911</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sarah  <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span> <span class="number">12345678912</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> John   <span class="operator">|</span>   <span class="number">45</span> <span class="operator">|</span> <span class="number">12345678913</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Emily  <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> <span class="number">12345678914</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> David  <span class="operator">|</span>   <span class="number">62</span> <span class="operator">|</span> <span class="number">12345678915</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Lisa   <span class="operator">|</span>   <span class="number">55</span> <span class="operator">|</span> <span class="number">12345678916</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Tom    <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> <span class="number">12345678917</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Anna   <span class="operator">|</span>    <span class="number">8</span> <span class="operator">|</span> <span class="number">12345678918</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Robert <span class="operator">|</span>   <span class="number">70</span> <span class="operator">|</span> <span class="number">12345678919</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Grace  <span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span> <span class="number">12345678920</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------+-------------+</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>此时的视图结果为 <code>view_changed</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> view_changed;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> tel         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Sarah <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span> <span class="number">12345678912</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Emily <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> <span class="number">12345678914</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Tom   <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> <span class="number">12345678917</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Anna  <span class="operator">|</span>    <span class="number">8</span> <span class="operator">|</span> <span class="number">12345678918</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+-------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>1. <code>UPDATE</code> 操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> view_changed</span><br><span class="line"><span class="keyword">SET</span> tel <span class="operator">=</span> <span class="string">&#x27;0000000&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Sarah&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时表 <code>view_test</code> 和视图 <code>view_changed</code> 的 <code>Sarah</code> 行数据均发生改变。</p><p><strong>2. <code>INSERT</code> 操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> view_changed</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;TEST&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;???&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时表 <code>view_test</code> 和视图 <code>view_changed</code> 增加了一行 <code>TEST</code> 的数据。</p><p><strong>3. <code>DELETE</code> 操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> view_changed</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时表 <code>view_test</code> 和视图 <code>view_changed</code> 的 <code>TEST</code> 均被删除。</p><h3 id="4-2-不可更新的视图"><a href="#4-2-不可更新的视图" class="headerlink" title="4.2 不可更新的视图"></a>4.2 不可更新的视图</h3><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<strong>一对一</strong>的关系。</p><p>另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li><p>在定义视图的时候指定了 <code>ALGORITHM = TEMPTABLE</code>，视图将不支持 <code>INSERT</code> 和 <code>DELETE</code> 操作；</p></li><li><p>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持 <code>INSERT</code> 操作；</p></li><li><p>在定义视图的 <code>SELECT</code> 语句中使用了 <code>JOIN</code>  ，视图将不支持 <code>INSERT</code> 和 <code>DELETE</code> 操作；</p></li><li><p>在定义视图的 <code>SELECT</code> 语句后的字段列表中使用了 <em>数学表达式</em> 或 <em>子查询</em> ，视图将不支持<code>INSERT</code> ，也不支持 <code>UPDATE</code> 使用了数学表达式、子查询的字段值；</p></li><li><p>在定义视图的 <code>SELECT</code> 语句后的字段列表中使用 <code>DISTINCT</code> 、 聚合函数 、 <code>GROUP BY</code> 、 <code>HAVING</code> 、<code>UNION</code> 等，视图将不支持 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>；</p></li><li><p>在定义视图的 <code>SELECT</code> 语句中包含了子查询，而子查询中引用了 <code>FROM</code> 后面的表，视图将不支持<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>；</p></li><li>视图定义基于一个 <em>不可更新视图</em> ，例如常量视图。</li></ul><blockquote><p>【注意】即使视图可以进行更新、修改和删除数据，也不建议使用。视图的本意就是为了查询和展示，如果要对数据进行修改，一般对数据表进行操作，而非视图！</p></blockquote><h2 id="5-修改和删除视图"><a href="#5-修改和删除视图" class="headerlink" title="5 修改和删除视图"></a>5 修改和删除视图</h2><h3 id="5-1-修改视图"><a href="#5-1-修改视图" class="headerlink" title="5.1 修改视图"></a>5.1 修改视图</h3><p><strong>1. 使用 <code>CREATE OR REPLACE VIEW</code> 子句修改视图</strong></p><p>相当于检查是否存在，存在则替换原视图中的一些设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_changed</span><br><span class="line"><span class="keyword">AS</span>  <span class="comment">-- 修改条件</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> view_test</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>ALTER VIEW</code> 修改</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_changed</span><br><span class="line">    <span class="keyword">AS</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> view_test</span><br><span class="line">        <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h3 id="5-2-删除视图"><a href="#5-2-删除视图" class="headerlink" title="5.2 删除视图"></a>5.2 删除视图</h3><p><strong>删除视图</strong>只是删除视图的定义，并不会删除基表的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> 视图名称 [视图名称<span class="number">1</span>, 视图名称<span class="number">2</span>, ...];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> view_changed;</span><br></pre></td></tr></table></figure><blockquote><p>【注意】基于视图创建的视图，如果被依赖的视图被删除，则基于其创建的视图功能丧失，也需要被删除。</p></blockquote>]]></content>
    
    
    <summary type="html">视图是一种虚拟表，本身不存储数据，占用很少的内存空间，可以理解为存储查询语句的对象。本章介绍视图的概念，如何创建视图，查看、更新视图的数据，以及修改和删除视图本身。</summary>
    
    
    
    <category term="MySQL" scheme="https://blog.iskage.online/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.iskage.online/tags/MySQL/"/>
    
    <category term="SQL" scheme="https://blog.iskage.online/tags/SQL/"/>
    
    <category term="数据库" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>映射 (Map) 与 哈希 (Hash)</title>
    <link href="https://blog.iskage.online/posts/ab7a595d.html"/>
    <id>https://blog.iskage.online/posts/ab7a595d.html</id>
    <published>2025-04-11T00:16:00.000Z</published>
    <updated>2025-04-10T15:12:34.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="映射-Map-与-哈希-Hash"><a href="#映射-Map-与-哈希-Hash" class="headerlink" title="映射 (Map) 与 哈希 (Hash)"></a>映射 (Map) 与 哈希 (Hash)</h1><p>本章介绍映射、哈希表、哈希函数、哈希码、压缩函数、冲突处理。核心问题：以最快的速度实现查找、删除、插入键值对的功能。</p><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。<strong>【持续更新中，建议 star !】</strong></p><h2 id="1-映射"><a href="#1-映射" class="headerlink" title="1 映射"></a>1 映射</h2><p><strong>映射 map</strong> ：是由键值对所构成的集合，其中的键是唯一的，但值不一定唯一。映射上的主要操作为查找、插入和删除。其中映射需要解决的核心问题就是<strong>加速查找操作</strong>。</p><p><strong>字典 dict</strong> ：是 Python 中最重要的数据结构。</p><ul><li><p><code>dict</code> 类表示一种被称为字典的抽象概念，其中的每个键是唯一的，且被映射到对应的值上。</p></li><li><p><code>dict</code> 类是一种<strong>无序映射</strong>的实现。</p></li></ul><p>为避免混淆，我们使用 “字典” 这一术语来指代 Python 的 <code>dict</code> 类，而使用 “映射” 这一术语来讨论更为一般的抽象数据类型概念。</p><h3 id="1-1-映射的抽象数据类型-ADT"><a href="#1-1-映射的抽象数据类型-ADT" class="headerlink" title="1.1 映射的抽象数据类型 ADT"></a>1.1 映射的抽象数据类型 ADT</h3><p>引入映射 M 的 ADT ，并定义其行为与 dict 类一致：</p><p><strong>映射 M 最重要的 5 类行为（查找、增添、删除、修改、遍历）：</strong></p><ul><li><code>M[k]</code> ：如果存在，返回映射 M 中键 k 对应的值，否则抛出 KeyError 。Python 中该功能由特殊方法 <code>__getitem__</code> 实现。</li><li><code>M[k] = v</code> ：使得映射 M 中键 k 对应于值 v 。如 k 有之前对应的值，则替换掉该值。Python 中该功能由特殊方法 <code>__setitem__</code> 实现。</li><li><code>del M[k]</code> ：从映射 M 中删除键为 k 的键值对。如键 k 不存在则抛出 KeyError 。Python 中该功能由特殊方法 <code>__delitem__</code> 实现。</li><li><code>len(M)</code> ：返回映射 M 中键值对的数量。Python 中该功能由特殊方法 <code>__len__</code> 实现。</li><li><code>iter(M)</code> ：返回一个包含映射 M 所有键的迭代器。Python 中该功能由特殊方法 <code>__iter__</code> 实现。</li></ul><p><strong>为实现其他方便的功能，映射 M 也应支持以下行为：</strong></p><ul><li><code>k in M</code> ：如果映射 M 中包含键 k 则返回 True ，否则返回 False 。Python 中该功能由特殊方法 <code>__contains__</code> 实现。</li><li><code>M.get(k, d=None)</code> ：如映射 M 中存在 k 则返回 M[k] ，否则返回默认值 d 。这提供了一种避免 KeyError 风险的 M[k] 查询方法。</li><li><code>M.setdefault(k, d)</code> ：如映射 M 中存在键 k ，则返回 M[k] ，否则令 M[k] = d 并返回 d 。</li><li><code>M.pop(k, d=None)</code> ：从映射 M 中删除键为 k 的键值对，并将其值 v 返回。如 M 中不存在键 k 则返回默认值 d（如 d 为 None 则抛出 KeyError ）。</li><li><code>M.popitem()</code> ：从映射 M 中随机删除并返回一个键值对 (k, v) 。如 M 为空则抛出 KeyError 。</li><li><code>M.clear()</code> : 删除映射M中所有的键值对。</li><li><code>M.keys()</code> : 返回 M 的所有键。</li><li><code>M.values()</code> : 返回 M 的所有值。</li><li><code>M.items()</code> : 返回 M 的所有键值对。</li><li><code>M.update(M2)</code> : 将 M2 中的所有键值对信息插入 M 中。</li><li><code>M == M2</code> : 如果映射 M 和 M2 中包含的所有键值对完全相同则返回 True ，否则返回 False 。</li><li><code>M != M2</code> : 如果映射 M 和 M2 中有不同的键值对则返回 True ，否则返回 False 。</li></ul><p>例如：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744194185818.png" alt="映射 ADT 的一些操作例子"></p><p><strong>应用</strong> 考虑统计一个文档中单词出现频率的问题。使用 Python 的 dict 类实现该映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_word_count</span>(<span class="params">filename: <span class="built_in">str</span></span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]:</span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">open</span>(filename).read().lower().split():</span><br><span class="line">        <span class="comment"># 只考虑小写字母的单词</span></span><br><span class="line">        word = <span class="string">&#x27;&#x27;</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> piece <span class="keyword">if</span> c.isalpha())</span><br><span class="line">        <span class="keyword">if</span> word:  <span class="comment"># 单词存在</span></span><br><span class="line">            freq[word] = <span class="number">1</span> + freq.get(word, <span class="number">0</span>)  <span class="comment"># 有则 +1 无则初始化为 0</span></span><br><span class="line"></span><br><span class="line">    max_word = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    max_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (w, c) <span class="keyword">in</span> freq.items():</span><br><span class="line">        <span class="keyword">if</span> c &gt; max_count:</span><br><span class="line">            max_word = w</span><br><span class="line">            max_count = c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_word, max_count</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_path = <span class="string">&quot;example.txt&quot;</span></span><br><span class="line">    max_word, max_count = max_word_count(filename=file_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The most frequent word is: \&#x27;&#123;&#125;\&#x27;&#x27;</span>.<span class="built_in">format</span>(max_word))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Its number of occurrences is: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(max_count))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># The most frequent word is: &#x27;file&#x27;</span></span><br><span class="line"><span class="comment"># Its number of occurrences is: 3</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Python-实现映射"><a href="#1-2-Python-实现映射" class="headerlink" title="1.2 Python 实现映射"></a>1.2 Python 实现映射</h3><p>我们可以使用 Python 自带的抽象基类帮助我们构建自己的映射类。</p><p>Python 的 <code>collections.abc</code> 模块中有以下两个抽象基类：</p><ul><li><code>Mapping</code> ：包含 dict 类支持的所有<strong>不可变方法</strong>。</li><li><code>MutableMapping</code> ：包含 dict 类支持的<strong>不可变及可变方法</strong>。</li></ul><blockquote><p>【注意】在高版本的 Python 中 <code>MutableMapping</code> 已移到 <code>collections.abc</code> 中。</p></blockquote><p><code>MutableMapping</code> 类提供映射 ADT 中<strong>除以下 5 种行为外</strong>所有行为的具体实现：<code>__getitem__</code> ， <code>__setitem__</code> ， <code>__delitem__</code> ，<code>__len__</code> 和 <code>__iter__</code> 。所以我们只需在继承类中给出以上 5 种行为的具体实现即可得到映射 ADT 中所有行为的实现。</p><p>后续实现的类的关系图如下：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744200161055.png" alt="各个类的关系图"></p><h4 id="1-2-1-基于-MutableMapping-自定义实现的-MapBase"><a href="#1-2-1-基于-MutableMapping-自定义实现的-MapBase" class="headerlink" title="1.2.1 基于 MutableMapping 自定义实现的 MapBase"></a>1.2.1 基于 MutableMapping 自定义实现的 MapBase</h4><p>继承类 <code>MutableMapping</code> 并定义内嵌类 <code>_Item</code> 存储<strong>键值对</strong>，得到映射的基础类 <code>MapBase</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> collections.abc <span class="keyword">import</span> MutableMapping  <span class="comment"># Python 3.3+</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> MutableMapping  <span class="comment"># Python 2.7 - 3.2 (已废弃)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapBase</span>(<span class="title class_ inherited__">MutableMapping</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;映射 Map 的基础父类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- 嵌套的 _Item 类，存储键值对 ----------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Item</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储键值对&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_key&#x27;</span>, <span class="string">&#x27;_value&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k, v</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;初始化键值对&quot;&quot;&quot;</span></span><br><span class="line">            <span class="variable language_">self</span>._key = k</span><br><span class="line">            <span class="variable language_">self</span>._value = v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;a == b 等价于 a 和 b 键值相等&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._key == other._key</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;a != b 等价于 a 和 b 键值不等&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> (<span class="variable language_">self</span> == other)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;比较键值&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._key &lt; other._key</span><br></pre></td></tr></table></figure><h4 id="1-2-2-简单的非有序映射实现-UnsortedTableMap"><a href="#1-2-2-简单的非有序映射实现-UnsortedTableMap" class="headerlink" title="1.2.2 简单的非有序映射实现 UnsortedTableMap"></a>1.2.2 简单的非有序映射实现 UnsortedTableMap</h4><p>继承映射的基础类 <code>MapBase</code> ，使用列表简单实现可实例化的非有序映射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsortedTableMap</span>(<span class="title class_ inherited__">MapBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于未排序列表实现映射&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化列表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._table = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据键取值 M[k]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable language_">self</span>._table:</span><br><span class="line">            <span class="keyword">if</span> k == item._key:</span><br><span class="line">                <span class="keyword">return</span> item._value</span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error: &#x27;</span> + <span class="built_in">repr</span>(k))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, k, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置键为 k 的值为 v 若没有则新建 M[k] = v&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable language_">self</span>._table:</span><br><span class="line">            <span class="keyword">if</span> k == item._key:</span><br><span class="line">                item._value = v</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 若没有找到匹配的 key 则新建</span></span><br><span class="line">        <span class="variable language_">self</span>._table.append(<span class="variable language_">self</span>._Item(k, v))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除键为 k 的对象&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>._table)):</span><br><span class="line">            <span class="keyword">if</span> k == <span class="variable language_">self</span>._table[j]._key:</span><br><span class="line">                <span class="variable language_">self</span>._table.pop(j)  <span class="comment"># 找到后使用列表的删除方式</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error: &#x27;</span> + <span class="built_in">repr</span>(k))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;对象总数目&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._table)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器，指出 for item in M 操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable language_">self</span>._table:</span><br><span class="line">            <span class="keyword">yield</span> item._key  <span class="comment"># 返回键 key</span></span><br></pre></td></tr></table></figure><p>测试案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = UnsortedTableMap()</span><br><span class="line">    m[<span class="string">&#x27;test1&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    m[<span class="string">&#x27;test2&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    m[<span class="string">&#x27;test3&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> m:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key: &#123;&#125;, value: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(key, m[key]))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># key: test1, value: 1</span></span><br><span class="line"><span class="comment"># key: test2, value: 2</span></span><br><span class="line"><span class="comment"># key: test3, value: 3</span></span><br></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p><code>UnsortedTableMap</code> 类的性能：</p><ul><li>插入操作只需在无序列表尾增加新元素，故运行时间为 <strong>O(1)</strong> 。</li><li>查找及删除时，最坏情况下需要遍历整个列表，故运行时间为 <strong>O(n)</strong> 。</li><li>基于列表实现的无序映射，只在映射规模较小，或插入操作经常执行，但查找和删除很少执行时，较有效率。</li></ul><h2 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2 哈希表"></a>2 哈希表</h2><p>实践中最常用来实现映射的数据结构—— <strong>哈希表（hash table）</strong></p><ul><li>在哈希表中，我们直接使用键作为索引来查找键值对</li><li>考虑一种简单情况：映射 M 中含有 n 个元组，如使用 0 到 N-1 的整数作为键（N &gt;= n），则可使用长为 N 的查找表来表示此映射：</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744201795319.png" alt="简单哈希的例子"></p><p>因为记住了索引，此时查找、插入、删除操作均可在 <strong>O(1)</strong> 时间内完成。</p><h3 id="2-1-哈希函数"><a href="#2-1-哈希函数" class="headerlink" title="2.1 哈希函数"></a>2.1 哈希函数</h3><p><strong>哈希函数（hash function）</strong>解决了下面的问题：</p><ul><li>如果 N &gt;&gt; n ，如何减小分配的空间？</li><li>映射的键不为整数的情况下，如何将其转换为索引？</li></ul><p>哈希函数 h(k) 包括两部分：<strong>哈希码 + 压缩函数</strong> 。其中哈希码是将任意输入的的键值 key 转换为整数，而压缩函数则是将得到的哈希码压缩到 [0, N-1] 范围。然后再将对象存储在当下哈希函数值索引对应的位置上，即：</p><script type="math/tex; mode=display">M\ [\ h(k)\ ] = (k,\ v), \quad h(k)\in [0,\ N-1]\quad \forall\ k</script><p>理想情况下，哈希函数将键均匀地映射到 [0, N-1] 这一范围内，但实践中可能有两个或更多不同键被映射到同一个索引上，这时需要进行 <strong>冲突（collision）</strong>处理。</p><h3 id="2-2-哈希码"><a href="#2-2-哈希码" class="headerlink" title="2.2 哈希码"></a>2.2 哈希码</h3><p><strong>哈希码</strong>过程，相当于将任意不可变类型的键值 <code>k</code> 变为一个整数：</p><script type="math/tex; mode=display">h_1: k \to \N</script><h4 id="2-2-1-将位作为整数处理"><a href="#2-2-1-将位作为整数处理" class="headerlink" title="2.2.1 将位作为整数处理"></a>2.2.1 将位作为整数处理</h4><p>设键对应的二进制表达（不可变对象在计算机内部都对应这一个固定的 0 1 数字串）为：</p><script type="math/tex; mode=display">x = (x_0\ x_1\ x_2\ \cdots\ x_{n-1})_2</script><p><strong>分量求和法：</strong>将键的位（二进制表示）表示分为固定长度的几部分（如16或32位），再将各部分相加，忽略溢出。</p><script type="math/tex; mode=display">h_1(x) = \sum\limits_{i=0}^{n-1}\ x_i</script><p><strong>分量异或法：</strong>将键的位表示分为固定长度的几部分（如16或32位），再将各部分进行位异或运算。</p><script type="math/tex; mode=display">h_1(x) = x_0\ \oplus\ x_1\ \oplus\ x_2\ \cdots\ \oplus\ x_{n-1}</script><p><strong>按位处理的特点：</strong></p><ul><li><p>适用于键的位数大于整数位数的情况</p></li><li><p>可能存在的问题：忽略了各部分间的顺序，对字符串或可变长度对象不一定是个好选择</p></li></ul><h4 id="2-2-2-多项式哈希码"><a href="#2-2-2-多项式哈希码" class="headerlink" title="2.2.2 多项式哈希码"></a>2.2.2 多项式哈希码</h4><p>类似地，先将键的位表示分为固定长度的几部分（如16或32位）：</p><script type="math/tex; mode=display">x = (x_0\ x_1\ x_2\ \cdots\ x_{n-1})_2</script><p>选择一个非零常数 a ，计算如下多项式的值，忽略溢出：</p><script type="math/tex; mode=display">p(a) = x_0 \cdot a^{n-1} + x_1 \cdot a^{n-2} + \cdots + x_{n-2} \cdot a + x_{n-1}</script><p>处理英文字符串时，33、37、39、41 特别适合选作 a 值，在超过 50000 个英文单词构成的集合上每个哈希码上的冲突小于 7 次。</p><p>为提高性能，利用 <strong>Horner</strong> 规则，多项式的值可以在 <strong>O(n)</strong> 内计算出来：</p><script type="math/tex; mode=display">p_i(a) = x_i + a\cdot p_{i-1}(a),\quad i=1,\ 2,\ \cdots\ n-1</script><h4 id="2-2-3-循环移位哈希码"><a href="#2-2-3-循环移位哈希码" class="headerlink" title="2.2.3 循环移位哈希码"></a>2.2.3 循环移位哈希码</h4><p>多项式哈希码的一个变种，将多项式哈希码中乘 a 的操作变为对部分和的循环移位。</p><p>例如，一个32位数 <strong>00111</strong>XX…X 的五位循环移位值取其最左边五位，并且将它们放置到数据的最右边，得到结果 XX…X<strong>00111</strong>。在 Python 中，二进制位循环移位可以通过使用按位运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 完成，从而截取结果 32 位整数。</p><p>5 位循环移位在 230000 个单词构成的集合中哈希码的最大冲突次数为 3 。</p><h4 id="2-2-4-Python-中的哈希码"><a href="#2-2-4-Python-中的哈希码" class="headerlink" title="2.2.4 Python 中的哈希码"></a>2.2.4 Python 中的哈希码</h4><p>Python 中使用<strong>内置函数</strong> <code>hash(x)</code> 计算对象 x 的哈希码。只有<strong>不可变数据类型才是可哈希的</strong>：</p><ul><li><code>int</code>、<code>float</code>、<code>str</code>、<code>tuple</code>、<code>frozenset</code> 可哈希</li><li><code>list</code>、<code>dict</code>、<code>set</code> 不可哈希</li></ul><p>默认情况下，用户定义的类不可哈希。但可通过在类中实现一个使用<strong>不可变对象计算哈希码的特殊方法</strong> <code>__hash__</code>，有此方法的类即可哈希，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">x</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;对象存储这 RGB 三色的数值&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">hash</span>((<span class="variable language_">self</span>._red, <span class="variable language_">self</span>._green, <span class="variable language_">self</span>._blue))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="2-3-压缩函数"><a href="#2-3-压缩函数" class="headerlink" title="2.3 压缩函数"></a>2.3 压缩函数</h3><p><strong>压缩函数</strong>的目的是将哈希码压缩到 [0, N-1] 范围：</p><script type="math/tex; mode=display">h_2: \N \to [0,\ N-1]</script><p>最终<strong>哈希函数</strong>即为</p><script type="math/tex; mode=display">h(k) = h_2(h_1(k))</script><h4 id="2-3-1-模函数取余-划分方法"><a href="#2-3-1-模函数取余-划分方法" class="headerlink" title="2.3.1 模函数取余/划分方法"></a>2.3.1 模函数取余/划分方法</h4><p>哈希表的大小 <code>N</code> （通常取质数），则对于某个键 <code>k</code> ，用模 N 的方法将其压缩到 [0, N-1]</p><script type="math/tex; mode=display">h_2(k) \equiv y \mod N \quad \Rightarrow \quad y \in [0,\ N-1]</script><p>如 N 不为质数，则出现冲突的概率大幅提升。例：哈希码为 {200, 205, 210, 215, 220, …, 600}。如 N = 100，则每个哈希码将至少与另三个哈希码冲突；但如 N = 101，则不会发生冲突。</p><h4 id="2-3-2-MAD-方法"><a href="#2-3-2-MAD-方法" class="headerlink" title="2.3.2 MAD 方法"></a>2.3.2 MAD 方法</h4><p>有一个更复杂的压缩函数，即 <strong>Multiply-Add-and-Divide, MAD 方法</strong>。这个方法通过</p><script type="math/tex; mode=display">h_2(k) = [(a\cdot k+b)\mod p] \mod N</script><p>其中 p 为比 N 大的质数， a 和 b 为区间内任意选择的整数，且 a &gt; 0 。该函数使得哈希函数得到的结果更好地被分散在 [0, N − 1] 中。</p><h3 id="2-4-处理冲突"><a href="#2-4-处理冲突" class="headerlink" title="2.4 处理冲突"></a>2.4 处理冲突</h3><p>当两个不同的键被映射到同一个索引时，就发生了<strong>冲突</strong>。哈希函数的设计可以减少冲突，但往往不能完全避免冲突的发生。</p><p>我们将表概念化为<strong>桶数组（bucket array）</strong>，每个桶里可能装着多个由哈希函数映射到该桶的键值对，例如下面的例子：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744204546431.png" alt="出现冲突时，一种存储方式：桶数组"></p><p>两类常见的冲突处理方式：<strong>链地址法 (sepearate chaining)</strong> 和 <strong>开放寻址法 (open addressing)</strong></p><h4 id="2-4-1-链地址法-分离链表"><a href="#2-4-1-链地址法-分离链表" class="headerlink" title="2.4.1 链地址法/分离链表"></a>2.4.1 链地址法/分离链表</h4><p><strong>链地址法（sepearate chaining）</strong>：在桶数组中的每个位置建立一个二级容器，存储所有映射到该位置的键值对，此容器通常为数组或链表。</p><ul><li>链地址法实现简单，但需要额外的空间</li></ul><p>例如下面直观的例子：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744204591880.png" alt="链地址法"></p><h4 id="2-4-2-开放寻址法"><a href="#2-4-2-开放寻址法" class="headerlink" title="2.4.2 开放寻址法"></a>2.4.2 开放寻址法</h4><p>链地址法需要占用额外空间存储链，所以开放寻址法成为了一个替代方法。<strong>开放寻址法（open addressing）</strong>直接将键值对存储在对应索引处，并采取更复杂的机制处理冲突。</p><ul><li>开放寻址法需要哈希表长度 N 始终大于所需存储的键值对数目 n</li><li>冲突发生时，当前键值对的位置已被另一个键值对占据，则根据某种规则探测下一个位置尝试进行插入，而探测的方法有：<strong>线性探测法</strong>、<strong>二次探测法</strong>、<strong>双重哈希法</strong>。</li></ul><h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p><strong>线性探测法（linear probing）：</strong>冲突发生时，尝试将新键值对插入紧邻的下一个位置。</p><p>例如：不断 $j+1\mod N,\ j+2\mod N,\ \cdots$ </p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744204839541.png" alt="线性探测"></p><p><strong>可能存在的问题</strong>：</p><ul><li>倾向于将键值对集中连续地存储，很大程度上影响搜索效率。</li><li>冲突时，因为查找和插入会不断向后直到遇到 <code>None</code> ，所以删除元素时不可以简单置空，可以填充一个特殊的对象，例如自定义一个对象 <code>AVAIL</code> 用作删除时填充。同样的，下次插入时 <code>AVAIL</code> 是可插入位置。具体实现可见后文的 Python 实现。</li></ul><p><strong>总结：</strong></p><p>查找操作 <code>get(k)</code> ：从索引 h(k) 处开始探测连续探测下一个位置，直到发生以下某种情况</p><ul><li>找到一个键为 k 的键值对</li><li>找到一个未存储键值对的空位置</li><li>遍历 N 个位置后未出现以上两种情况</li></ul><p>删除操作 <code>remove(k)</code> ：</p><ul><li>使用查找操作 <code>get(k)</code> 寻找键为 k 的元素</li><li>如果找到这样的元素 (k, v) ，则将其替换为 AVAIL ，并返回 v</li><li>否则，返回 None</li></ul><p>插入操作 <code>set(k)</code>：从索引 h(k) 处开始探测，连续探测下一个位置，直到发生以下情况</p><ul><li>找到一个空位置或存储着 AVAIL 的位置。如成功找到插入位置，则将键值对 (k, v) 存在此处。</li><li>遍历 N 个位置后未出现以上情况，插入不成功</li></ul><h5 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h5><p><strong>二次探测法（quadratic probing）</strong>：冲突发生时，尝试依次探测以下位置，直到发现一个空位置：</p><script type="math/tex; mode=display">[\ h(k) + f(i)\ ] \mod N,\quad i = 0,\ 1,\ 2,\ \cdots</script><p>其中 $h(k)$ 为哈希码，对与线性探索 $f(i) = i$ 但对于二次探索则 $f(i) = i^2$ 。</p><h5 id="双重哈希法"><a href="#双重哈希法" class="headerlink" title="双重哈希法"></a>双重哈希法</h5><p><strong>双重哈希法（double hashing）</strong>：使用第二个哈希函数 h’(k) 确定下一个探测的位置。具体来说，冲突发生时，依次探索以下位置，直到发现一个空位置：</p><script type="math/tex; mode=display">h(k) + i\cdot h'(k) \mod N,\quad i = 0,\ 1,\ 2,\ \cdots</script><p>第二个哈希函数 $h’(k) \neq 0$ 以避免原地寻找。哈希表的长度 N 应保证为质数，以使得所有位置都可被探测到。</p><p>常用的第二个哈希函数 h’(k) 为：</p><script type="math/tex; mode=display">h'(k) = q - (k \mod q)</script><p>其中 q &lt; N 且为质数。</p><h3 id="2-5-负载因子、重新哈希和效率"><a href="#2-5-负载因子、重新哈希和效率" class="headerlink" title="2.5 负载因子、重新哈希和效率"></a>2.5 负载因子、重新哈希和效率</h3><h4 id="2-5-1-负载因子"><a href="#2-5-1-负载因子" class="headerlink" title="2.5.1 负载因子"></a>2.5.1 负载因子</h4><p>对需要存放 n 个元素且长为 N 的哈希表，定义其<strong>负载因子（load factor）</strong>为：</p><script type="math/tex; mode=display">\lambda = \frac{n}{N}</script><p>若 𝜆 为 <strong>O(1)</strong> ，则哈希表的核心操作时间复杂度也为 <strong>O(1)</strong> 。𝜆 应选择较小的常数，最好不大于 1 。</p><ul><li>对于链地址法，冲突发生后找到目标键的时间与链的长度成正比；𝜆 接近 1 时，冲突发生的概率急剧上升。一般来说，建议将链地址法的负载因子控制在 𝜆 &lt; 0.9 。</li><li>当 N 为质数，且负载因子小于 0.5 时，二次探测能保证找到一个空位置。</li><li>随着负载因子 𝜆 增长到 0.5 以上并向 1 逼近时，开放寻址法下桶数组中元素的集群开始增加，这使得各探测策略均需花费较长时间寻找空位置。</li></ul><p><strong>结论：</strong>实验表明，对于线性探测法，应保持 𝜆 &lt; 0.5，对其他探测法负载因子可略高（Python实现的开放寻址法规定 𝜆 &lt; 2/3）。</p><h4 id="2-5-2-重新哈希"><a href="#2-5-2-重新哈希" class="headerlink" title="2.5.2 重新哈希"></a>2.5.2 重新哈希</h4><p>当对哈希表的插入操作导致负载因子超过给定阈值时，需要调整哈希表的大小并将所有对象重新插入新的哈希表，这被称为<strong>重新哈希（rehashing）</strong></p><ul><li>不需要重新定义哈希码，但需要基于新哈希表重新设计一个压缩函数</li><li>新哈希表大小通常约为原表大小的 2 倍</li><li>建立新哈希表的时间被摊销到所有插入操作上</li></ul><h4 id="2-5-3-哈希表的效率"><a href="#2-5-3-哈希表的效率" class="headerlink" title="2.5.3 哈希表的效率"></a>2.5.3 哈希表的效率</h4><p><strong>哈希表的时间复杂度：</strong></p><ul><li><p>最坏情况下，哈希表的查找、插入和删除操作均需花费 <strong>O(n)</strong> 的时间。</p></li><li><p>平均情况下，哈希表的查找、插入和删除操作仅需花费 <strong>O(1)</strong> 的时间。</p></li></ul><p><strong>负载因子 𝜆 对哈希表的效率有很大的影响：</strong></p><ul><li><p>假设哈希值的分布是随机的，则在开放寻址法下，期望的探测次数为 $\frac{1}{1-\lambda}$ 。</p></li><li><p>在实践中，当负载因子 𝜆 显著小于1时，哈希表的速度非常快</p></li></ul><p><strong>哈希表的应用：</strong></p><ul><li>小型数据库</li><li>编译器</li><li>浏览器缓存</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744206564848.png" alt="哈希表实现映射与列表实现映射的性能比较"></p><h2 id="3-Python-实现哈希表"><a href="#3-Python-实现哈希表" class="headerlink" title="3 Python 实现哈希表"></a>3 Python 实现哈希表</h2><p>在这部分，根据前面的知识，实现两种哈希表，一种使用<strong>链地址法</strong>，而另一种使用<strong>线性探测的开放寻址</strong>。</p><h3 id="3-1-哈希表基类"><a href="#3-1-哈希表基类" class="headerlink" title="3.1 哈希表基类"></a>3.1 哈希表基类</h3><p>扩展 <code>MapBase</code> 类来定义一个新的哈希表基类 <code>HashMapBase</code> 类。HashMapBase 类主要的设计元素是：</p><ul><li>桶数组由一个 Python 列表表示，名为 <code>self._table</code> ，并且所有的条目初始为 None 。</li><li><code>self._n</code> 的实例变量用来表示当前存储在哈希表中不同元组的个数。</li><li>如果表格的负载因子 <code>n / N</code> 增加到超过 0.5 ，我们会将哈希表的大小扩大 2 倍并且将所有元组重新哈希到新的表中。</li><li>我们定义一个<code>_hash_</code> 方法，该方法依靠 Python 内置哈希函数 <code>hash()</code> 来生成键的哈希码，并用 <code>MAD</code> 公式生成压缩函数。</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .map_base <span class="keyword">import</span> MapBase</span><br><span class="line">    <span class="keyword">from</span> .unsorted_table_map <span class="keyword">import</span> UnsortedTableMap</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> map_base <span class="keyword">import</span> MapBase</span><br><span class="line">    <span class="keyword">from</span> unsorted_table_map <span class="keyword">import</span> UnsortedTableMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapBase</span>(<span class="title class_ inherited__">MapBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;哈希表基础抽象类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cap=<span class="number">11</span>, p=<span class="number">109345121</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化空哈希表</span></span><br><span class="line"><span class="string">        :param cap: 初始表可存储的大小，非实际大小</span></span><br><span class="line"><span class="string">        :param p: 一个充分大的质数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._table = cap * [<span class="literal">None</span>]  <span class="comment"># 可存储空间大小</span></span><br><span class="line">        <span class="variable language_">self</span>._n = <span class="number">0</span>  <span class="comment"># 哈希表内存储的键值对个数</span></span><br><span class="line">        <span class="variable language_">self</span>._prime = p  <span class="comment"># MAD: ax+b mod p 的 p 一个充分大的质数</span></span><br><span class="line">        <span class="variable language_">self</span>._scale = <span class="number">1</span> + randrange(p - <span class="number">1</span>)  <span class="comment"># MAD: ax+b mod p 的 a</span></span><br><span class="line">        <span class="variable language_">self</span>._shift = randrange(p)  <span class="comment"># MAD: ax+b mod p 的 b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash_function</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;自定义哈希函数 MAD 方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># (ax+b mod p) mod N belong to [0, N-1]: N 为实际表的大小 len(_table)</span></span><br><span class="line">        mad = (<span class="built_in">hash</span>(k) * <span class="variable language_">self</span>._scale + <span class="variable language_">self</span>._shift) % <span class="variable language_">self</span>._prime</span><br><span class="line">        <span class="keyword">return</span> mad % <span class="built_in">len</span>(<span class="variable language_">self</span>._table)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储的键值对个数 _n &lt;= N&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据键获取值 M[k]&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._hash_function(k)  <span class="comment"># calculate hash</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._bucket_getitem(j, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, k, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置/修改/新增键值对 M[k] = v&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._hash_function(k)  <span class="comment"># calculate hash</span></span><br><span class="line">        <span class="variable language_">self</span>._bucket_setitem(j, k, v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否达到容量的一半，进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._n &gt; <span class="built_in">len</span>(<span class="variable language_">self</span>._table) // <span class="number">2</span>:</span><br><span class="line">            <span class="variable language_">self</span>._resize(<span class="number">2</span> * <span class="built_in">len</span>(<span class="variable language_">self</span>._table) - <span class="number">1</span>)  <span class="comment"># 2 * len - 1 尽可能保证是质数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素 del M[k]&quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="variable language_">self</span>._hash_function(k)  <span class="comment"># calculate hash</span></span><br><span class="line">        <span class="variable language_">self</span>._bucket_delitem(j, k)</span><br><span class="line">        <span class="variable language_">self</span>._n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_resize</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;扩展空间&quot;&quot;&quot;</span></span><br><span class="line">        old = <span class="built_in">list</span>(<span class="variable language_">self</span>.items())  <span class="comment"># 继承自 MutableMapping 类</span></span><br><span class="line">        <span class="variable language_">self</span>._table = c * [<span class="literal">None</span>]  <span class="comment"># 扩容至 c</span></span><br><span class="line">        <span class="variable language_">self</span>._n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (k, v) <span class="keyword">in</span> old:</span><br><span class="line">            <span class="variable language_">self</span>[k] = v  <span class="comment"># 利用已经定义的 __setitem__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_getitem</span>(<span class="params">self, j, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取桶数组元素，由子类定义&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_setitem</span>(<span class="params">self, j, k, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修改桶数组元素，由子类定义&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_delitem</span>(<span class="params">self, j, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除桶数组元素，由子类定义&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器的方式返回键值，由子类定义&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在我们的设计中，<code>HashMapBase</code> 类假定有以下抽象方法，且每一个方法必须<strong>在具体子类中实现</strong>：</p><ul><li><code>_bucket_getitem(i, k)</code> ：这个方法在桶 j 中搜索查找键为 k 的元组，如果找到了则返回对应的值，如果找不到则抛出 KeyError 。 </li><li><code>_bucket_setitem(i, k, v)</code> ：这个方法将桶 j 中键 k 的值修改为 v 。如键 k 的值已经存在，则新的值覆盖已经存在的值。否则，将这个新元组插入桶中，并且这个方法负责增加 self._n 的值。</li><li><code>_bucket_delitem(i, k)</code> ：这个方法删除桶 j 中键为 k 的元组，如果这样的元组不存在则抛出 KeyError 异常（在这个方法之后 self._n 的值会减小）。</li><li><code>__iter__</code> ：迭代器的方式遍历所有键。</li></ul><h3 id="3-2-链地址法-分离链表"><a href="#3-2-链地址法-分离链表" class="headerlink" title="3.2 链地址法/分离链表"></a>3.2 链地址法/分离链表</h3><p><code>ChainHashMap</code> 类的形式实现链地址法的哈希表。它采用 <code>UnsortedTableMap</code> 类的一个实例来表示单个的桶。</p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChainHashMap</span>(<span class="title class_ inherited__">HashMapBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用链址法实习哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- 不需初始化，只需要实现 HashMapBase 未实现的方法 ----------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_getitem</span>(<span class="params">self, j, k</span>):</span><br><span class="line">        bucket = <span class="variable language_">self</span>._table[j]</span><br><span class="line">        <span class="keyword">if</span> bucket <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error&#x27;</span> + <span class="built_in">repr</span>(k))  <span class="comment"># 没有匹配到 k</span></span><br><span class="line">        <span class="keyword">return</span> bucket[k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_setitem</span>(<span class="params">self, j, k, v</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._table[j] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>._table[j] = UnsortedTableMap()  <span class="comment"># 用 UnsortedTableMap 实例作为新桶</span></span><br><span class="line"></span><br><span class="line">        oldsize = <span class="built_in">len</span>(<span class="variable language_">self</span>._table[j])  <span class="comment"># 记录 j 位置的原始长度</span></span><br><span class="line">        <span class="comment"># _table[j] 是 UnsortedTableMap 实例，此处调用它的 __getitem__ 方法</span></span><br><span class="line">        <span class="variable language_">self</span>._table[j][k] = v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._table[j]) &gt; oldsize:  <span class="comment"># 添加成功</span></span><br><span class="line">            <span class="variable language_">self</span>._n += <span class="number">1</span>  <span class="comment"># 键值对数目加一</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_delitem</span>(<span class="params">self, j, k</span>):</span><br><span class="line">        bucket = <span class="variable language_">self</span>._table[j]</span><br><span class="line">        <span class="keyword">if</span> bucket <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error&#x27;</span> + <span class="built_in">repr</span>(k))</span><br><span class="line">        <span class="keyword">del</span> bucket[k]  <span class="comment"># 使用 UnsortedTableMap 的 __delitem__ 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> <span class="variable language_">self</span>._table:</span><br><span class="line">            <span class="keyword">if</span> bucket <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 使用 UnsortedTableMap 的 __iter__ 方法</span></span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> bucket:</span><br><span class="line">                    <span class="keyword">yield</span> key</span><br></pre></td></tr></table></figure><p>测试：注意到，不同于 <code>UnsortedTableMap</code> 非有序列表实现的映射（使用逐个检索列表的 key 从而找到元素值）。这里的哈希表采用了先计算 hash 值，再寻找键值对的位置，所以顺序由键 <code>key</code> 和哈希函数决定。速度也非常的快，平均意义上的 <strong>O(1)</strong> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    chain_hash_map = ChainHashMap()</span><br><span class="line">    chain_hash_map[<span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    chain_hash_map[<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    chain_hash_map[<span class="string">&#x27;C&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> chain_hash_map:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key: &#123;&#125;, value: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(key, chain_hash_map[key]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># key: B, value: 2</span></span><br><span class="line"><span class="comment"># key: A, value: 1</span></span><br><span class="line"><span class="comment"># key: C, value: 3</span></span><br></pre></td></tr></table></figure><h3 id="3-3-开放寻址法的线性探测法"><a href="#3-3-开放寻址法的线性探测法" class="headerlink" title="3.3 开放寻址法的线性探测法"></a>3.3 开放寻址法的线性探测法</h3><p>使用<strong>线性探测的开放寻址</strong>实现 <code>ProbeHashMap</code> 类。为了支持删除操作，我们使用了在已被删除的表的位置上做一个特殊的标记（声明一个类级的属性 <code>_AVAIL</code> ），以此来将它和一个空 <code>None</code> 的位置区分开来。</p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProbeHashMap</span>(<span class="title class_ inherited__">HashMapBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性探测的开放寻址法实现的哈希表&quot;&quot;&quot;</span></span><br><span class="line">    _AVAIL = <span class="built_in">object</span>()  <span class="comment"># 哨兵对象，用来标记区分与空位置 None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_available</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断 j (对_table 而言的索引) 位置是否可以插入&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._table[j] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="variable language_">self</span>._table[j] <span class="keyword">is</span> ProbeHashMap._AVAIL</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find_slot</span>(<span class="params">self, j, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在桶/索引 j 中搜寻含义键 k 的元组&quot;&quot;&quot;</span></span><br><span class="line">        firstAvail = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._is_available(j):  <span class="comment"># 如果可以插入: _table[j] 是 None 或 _AVAIL</span></span><br><span class="line">                <span class="keyword">if</span> firstAvail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    firstAvail = j  <span class="comment"># 记录可以插入的桶/索引</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._table[j] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> (<span class="literal">False</span>, firstAvail)  <span class="comment"># 没有找到匹配的 k -&gt; False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> k == <span class="variable language_">self</span>._table[j]._key:  <span class="comment"># 找到匹配的 k -&gt; True</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="literal">True</span>, j)  <span class="comment"># 并且返回此处的索引</span></span><br><span class="line"></span><br><span class="line">            j = (j + <span class="number">1</span>) % <span class="built_in">len</span>(<span class="variable language_">self</span>._table)  <span class="comment"># 向后探索</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_getitem</span>(<span class="params">self, j, k</span>):</span><br><span class="line">        found, idx = <span class="variable language_">self</span>._find_slot(j, k)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:  <span class="comment"># 没找到匹配的 k</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error&#x27;</span> + <span class="built_in">repr</span>(k))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._table[idx]._value  <span class="comment"># 找到并返回 k 对应的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_setitem</span>(<span class="params">self, j, k, v</span>):</span><br><span class="line">        found, idx = <span class="variable language_">self</span>._find_slot(j, k)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:  <span class="comment"># 没找到匹配的 k 则插入新元组</span></span><br><span class="line">            <span class="variable language_">self</span>._table[idx] = <span class="variable language_">self</span>._Item(k, v)</span><br><span class="line">            <span class="variable language_">self</span>._n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则改变值 _value</span></span><br><span class="line">            <span class="variable language_">self</span>._table[idx]._value = v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bucket_delitem</span>(<span class="params">self, j, k</span>):</span><br><span class="line">        found, idx = <span class="variable language_">self</span>._find_slot(j, k)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:  <span class="comment"># 没找到匹配的 k</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Key Error&#x27;</span> + <span class="built_in">repr</span>(k))</span><br><span class="line">        <span class="variable language_">self</span>._table[idx] = ProbeHashMap._AVAIL  <span class="comment"># 删除后特殊标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>._table)):  <span class="comment"># 搜索整个存储空间 _table</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._is_available(j):</span><br><span class="line">                <span class="keyword">yield</span> <span class="variable language_">self</span>._table[j]._key</span><br></pre></td></tr></table></figure><p>测试：正如前面所分析的，平均意义下查找、插入、修改、删除均是 <strong>O(1)</strong> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    probe_hash_map = ProbeHashMap()</span><br><span class="line">    probe_hash_map[<span class="string">&#x27;Avail&#x27;</span>] = <span class="number">100</span></span><br><span class="line">    probe_hash_map[<span class="string">&#x27;Bucket&#x27;</span>] = <span class="number">200</span></span><br><span class="line">    probe_hash_map[<span class="string">&#x27;Capacity&#x27;</span>] = <span class="number">300</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> probe_hash_map:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key: &#123;&#125;, value: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(key, probe_hash_map[key]))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># key: Avail, value: 100</span></span><br><span class="line"><span class="comment"># key: Bucket, value: 200</span></span><br><span class="line"><span class="comment"># key: Capacity, value: 300</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本章介绍映射、哈希表、哈希函数、哈希码、压缩函数、冲突处理。核心问题：以最快的速度实现查找、删除、插入键值对的功能。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>统计软件 R 语言学习笔记 (8) 估计与假设检验 t.test 与 cor.test</title>
    <link href="https://blog.iskage.online/posts/45dbb3de.html"/>
    <id>https://blog.iskage.online/posts/45dbb3de.html</id>
    <published>2025-04-10T11:44:00.000Z</published>
    <updated>2025-04-17T08:09:42.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计推断：估计与假设检验-t-test-与-cor-test"><a href="#统计推断：估计与假设检验-t-test-与-cor-test" class="headerlink" title="统计推断：估计与假设检验 t.test 与 cor.test"></a>统计推断：估计与假设检验 t.test 与 cor.test</h1><p>利用观测样本对总体参数的：点估计、区间估计与假设检验。</p><p>代码和笔记存储在 <a href="https://github.com/iskage/r-notes">GitHub 库</a> <strong>【持续更新中，建议 star！】</strong></p><h2 id="1-统计推断的基本概念"><a href="#1-统计推断的基本概念" class="headerlink" title="1 统计推断的基本概念"></a>1 统计推断的基本概念</h2><h3 id="1-1-点估计"><a href="#1-1-点估计" class="headerlink" title="1.1 点估计"></a>1.1 点估计</h3><h4 id="1-1-1-估计"><a href="#1-1-1-估计" class="headerlink" title="1.1.1 估计"></a>1.1.1 估计</h4><p>用于估计的统计量称为<strong>估计量（estimator）</strong>；如果样本已经得到，把数据带入之后，估计量就有了一个数值，称为该估计量的一个<strong>实现（realization）或取值</strong>，也称为一个<strong>估计值（estimate）</strong>。</p><h4 id="1-1-2-抽样分布"><a href="#1-1-2-抽样分布" class="headerlink" title="1.1.2 抽样分布"></a>1.1.2 抽样分布</h4><p>由于一个统计量对于不同的样本取值不同。所以，估计量也是随机变量，并有其分布，称为：<strong>抽样分布（sampling distribution）</strong>—— 从总体中选取的固定样本量所对应的样本统计量（例如样本均值）的可能值的分布，该分布来源于不同的样本。</p><h4 id="1-1-3-无偏估计"><a href="#1-1-3-无偏估计" class="headerlink" title="1.1.3 无偏估计"></a>1.1.3 无偏估计</h4><p><strong>无偏估计</strong> ：来自不同样本的平均估计量等于真实参数</p><script type="math/tex; mode=display">E(\hat{\theta}) = \theta</script><p>其中 $\hat{\theta}$ 为总体参数 $\theta$ 的估计。</p><p>样本均值和样本方差的无偏性：</p><ul><li>样本均值对于总体均值是无偏的：$E(\bar{X}) = \mu$</li><li>样本方差对于总体方差是无偏的：$E(S^2) = \sigma^2,\quad S^2 = \frac{1}{n-1}\sum\limits_{i=1}^n\ (X_i - \bar{X})^2$ </li></ul><h4 id="1-1-4-标准误差"><a href="#1-1-4-标准误差" class="headerlink" title="1.1.4 标准误差"></a>1.1.4 标准误差</h4><p>点估计的标准误差：该抽样分布的标准差。</p><script type="math/tex; mode=display">SD(\hat{\theta}) = \sqrt{S^2}</script><p>样本均值的标准误差：</p><ul><li><p>它衡量了点估计量在不同样本之间的变动程度。样本均值的标准差为：$SD(\bar{X}) = \frac{\sigma}{\sqrt{n}} \approx \frac{s}{\sqrt{n}}$</p></li><li><p>样本量 n 越大，标准误差越小。这意味着增大样本量 n 可能会提高样本均值的稳定性。</p></li></ul><h3 id="1-2-区间估计"><a href="#1-2-区间估计" class="headerlink" title="1.2 区间估计"></a>1.2 区间估计</h3><h4 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h4><p>对于 $1 - \alpha$ 置信区间 $[c_1,\ c_2]$ 代表了真值 $\theta$ 落入区间的概率为 $1 - \alpha$ 。</p><p>例如常见的区间估计：对于样本均值的置信区间</p><script type="math/tex; mode=display">[\bar{x} - t_{\alpha/2}(n-1)\cdot \frac{s}{\sqrt{n}},\ \bar{x} + t_{\alpha/2}(n-1)\cdot \frac{s}{\sqrt{n}}]</script><p>其中 $t_{\alpha/2}(n-1)$ 为自由度为 n - 1 的 t 分布的 $\alpha/2$ 分位数点。</p><h4 id="1-2-2-R-语言模拟"><a href="#1-2-2-R-语言模拟" class="headerlink" title="1.2.2 R 语言模拟"></a>1.2.2 R 语言模拟</h4><p>对于一个 $95\%$ 的置信区间，代表不断重复抽取（样本量相同的）样本时，产生的大量区间估计，这些区间大约有 $95\%$ 会覆盖真正的参数。</p><p><strong>求解置信区间：</strong>求解对样本均值的区间估计的函数 <code>takeCI</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">takeCI <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> beta <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    n <span class="operator">&lt;-</span> <span class="built_in">length</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">    alpha <span class="operator">&lt;-</span> 1 <span class="operator">-</span> beta</span><br><span class="line"></span><br><span class="line">    <span class="built_in">c</span> <span class="operator">&lt;-</span> qt<span class="punctuation">(</span>p <span class="operator">=</span> alpha <span class="operator">/</span> <span class="number">2</span><span class="punctuation">,</span> lower.tail <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> df <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    xbar <span class="operator">&lt;-</span> mean<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">    l <span class="operator">&lt;-</span> <span class="built_in">c</span> <span class="operator">*</span> sd<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">/</span> <span class="built_in">sqrt</span><span class="punctuation">(</span>n<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    left <span class="operator">&lt;-</span> xbar <span class="operator">-</span> l</span><br><span class="line">    right <span class="operator">&lt;-</span> xbar <span class="operator">+</span> l</span><br><span class="line"></span><br><span class="line">    res <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>left <span class="operator">=</span> left<span class="punctuation">,</span> right <span class="operator">=</span> right<span class="punctuation">)</span></span><br><span class="line">    <span class="built_in">return</span><span class="punctuation">(</span>res<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>模拟一次：</strong>例如从标准正态中抽样，然后对均值进行区间估计</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> x <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> sd <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span>  <span class="comment"># 抽样 20 个</span></span><br><span class="line"><span class="operator">&gt;</span> takeCI<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">       left       right </span><br><span class="line"><span class="operator">-</span><span class="number">0.69806027</span>  <span class="number">0.09131091</span> </span><br></pre></td></tr></table></figure><blockquote><p>【注意】根据单独一个样本集合估计的到的区间不一定包含真实值。</p></blockquote><p><strong>模拟多次：</strong>重复模拟，并记录包含真实总体均值的频率，注意到大致等于 $95\%$</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟 N 次</span></span><br><span class="line">auc <span class="operator">&lt;-</span> 0</span><br><span class="line">N <span class="operator">&lt;-</span> 1000</span><br><span class="line">sample_size <span class="operator">&lt;-</span> 20</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>N<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    x <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n <span class="operator">=</span> sample_size<span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> sd <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">    ci <span class="operator">&lt;-</span> takeCI<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="punctuation">(</span>ci<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> ci<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">        auc <span class="operator">&lt;-</span> auc <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">coverage_rate <span class="operator">&lt;-</span> auc <span class="operator">/</span> N  <span class="comment"># 0.961</span></span><br></pre></td></tr></table></figure><h3 id="1-3-假设检验"><a href="#1-3-假设检验" class="headerlink" title="1.3 假设检验"></a>1.3 假设检验</h3><h4 id="1-3-1-概念"><a href="#1-3-1-概念" class="headerlink" title="1.3.1 概念"></a>1.3.1 概念</h4><p>对于参数 $\theta$ 的估计为 $\hat{\theta}$ 的参数空间为 $\Theta$ ，而原假设为 $\theta \in \Theta_0$ 于是假设检验为：</p><script type="math/tex; mode=display">H_0: \theta \in \Theta_0,\quad H_1: \theta \notin \Theta_0</script><p>通过检验统计量判断是否异常，若满足拒绝域，则拒绝原假设 $H_0$ 。</p><p>例如：对于样本均值的估计为 $\bar{X}$ ，原假设为认为总体均值 $\mu \geq \mu_0$ ，其中 $\mu_0$ 为常数。</p><script type="math/tex; mode=display">H_0: \mu \geq \mu_0,\quad H_1:  \mu < \mu_0</script><p>更简单的方式，直接查看 p 值，当</p><script type="math/tex; mode=display">p \leq \alpha</script><p>即 p 值小于显著性水平，则拒绝原假设。</p><h4 id="1-3-2-R-语言模拟"><a href="#1-3-2-R-语言模拟" class="headerlink" title="1.3.2 R 语言模拟"></a>1.3.2 R 语言模拟</h4><p>假设检验：</p><script type="math/tex; mode=display">H_0: \mu \geq \mu_0,\quad H_1:  \mu < \mu_0</script><p>的拒绝域为：</p><script type="math/tex; mode=display">W_c = \{ (x_1,\ x_2,\ \cdots,\ x_n): \bar{x} = \frac{1}{n}\sum\limits_{i=1}^n\ x_i \geq c \}</script><p>势函数为：</p><script type="math/tex; mode=display">G_W(F) = P\{ (X_1,\ X_2,\ \cdots,\ X_n) \in W \}</script><p>对于这个例子：</p><script type="math/tex; mode=display">G_c(\mu) = P_{\mu}\{ (X_1,\ X_2,\ \cdots,\ X_n) \in W_c \} = P_{\mu}(\bar{X}\geq c) = P_{\mu}(\frac{\bar{X} - \mu_0}{s/\sqrt{n}} \geq \frac{c - \mu_0}{s/\sqrt{n}} )</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单侧 t 检验</span></span><br><span class="line">alpha <span class="operator">&lt;-</span> 0.05</span><br><span class="line">n <span class="operator">&lt;-</span> 100</span><br><span class="line">N <span class="operator">&lt;-</span> 1000</span><br><span class="line">t_list <span class="operator">&lt;-</span> <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>N<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    y <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n<span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">    t <span class="operator">&lt;-</span> <span class="punctuation">(</span>mean<span class="punctuation">(</span>y<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span>sd<span class="punctuation">(</span>y<span class="punctuation">)</span> <span class="operator">/</span> <span class="built_in">sqrt</span><span class="punctuation">(</span>n<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># t 检验量</span></span><br><span class="line">    t_list <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>t_list<span class="punctuation">,</span> t<span class="punctuation">)</span> <span class="comment"># t 检验量加入 t_list</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="built_in">c</span> <span class="operator">&lt;-</span> qt<span class="punctuation">(</span>alpha<span class="punctuation">,</span> lower.tail <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> df <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>t_list <span class="operator">&lt;=</span> <span class="built_in">c</span><span class="punctuation">)</span> <span class="operator">/</span> N  <span class="comment"># N 个样本拒绝的次数 / 总模拟次数</span></span><br><span class="line"><span class="comment"># 0.948</span></span><br></pre></td></tr></table></figure><p>对于第 <code>I</code> 类错误，控制在 $\alpha$ 的 R 语言模拟验证：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 控制第 I 类错误：H0 对但拒绝</span></span><br><span class="line">alpha <span class="operator">&lt;-</span> 0.05</span><br><span class="line">n <span class="operator">&lt;-</span> 100</span><br><span class="line">N <span class="operator">&lt;-</span> 1000</span><br><span class="line">p_t_list <span class="operator">&lt;-</span> <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>N<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    y <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n<span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">    t <span class="operator">&lt;-</span> <span class="punctuation">(</span>mean<span class="punctuation">(</span>y<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span>sd<span class="punctuation">(</span>y<span class="punctuation">)</span> <span class="operator">/</span> <span class="built_in">sqrt</span><span class="punctuation">(</span>n<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># t 检验量</span></span><br><span class="line">    p_t <span class="operator">&lt;-</span> pt<span class="punctuation">(</span>t<span class="punctuation">,</span> df <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span> <span class="comment"># P(X &lt; t) = p_t, X ~ t(n-1) 这个问题的 p 值</span></span><br><span class="line">    p_t_list <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>p_t_list<span class="punctuation">,</span> p_t<span class="punctuation">)</span> <span class="comment"># t 检验量分位数对应的 t(n-1) 分布概率加入 t_list</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>p_t_list <span class="operator">&lt;=</span> alpha<span class="punctuation">)</span> <span class="operator">/</span> N <span class="comment"># 犯第 I 类错误</span></span><br><span class="line"><span class="comment"># 0.058</span></span><br></pre></td></tr></table></figure><blockquote><p>p 值是统计量，且满足均匀分布 $U[0,1)$ 。</p></blockquote><h2 id="2-常见的统计推断"><a href="#2-常见的统计推断" class="headerlink" title="2 常见的统计推断"></a>2 常见的统计推断</h2><h3 id="2-1-正态总体均值"><a href="#2-1-正态总体均值" class="headerlink" title="2.1 正态总体均值"></a>2.1 正态总体均值</h3><p>第一步验证模型假设，例如使用 Q-Q 图验证是否近似正态。</p><h4 id="2-1-1-t-test-检验函数"><a href="#2-1-1-t-test-检验函数" class="headerlink" title="2.1.1 t.test() 检验函数"></a>2.1.1 t.test() 检验函数</h4><p><strong>t-检验：</strong> <code>t.test()</code> 提供了正态总体均值的 t。检验方法。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t.test<span class="punctuation">(</span>x<span class="punctuation">,</span> y <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">       alternative <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;two.sided&quot;</span><span class="punctuation">,</span> <span class="string">&quot;less&quot;</span><span class="punctuation">,</span> <span class="string">&quot;greater&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       mu <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> paired <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> var.equal <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">       conf.level <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x<span class="punctuation">,</span> y<span class="operator">:</span> 可以单样本也可以两样本</span><br><span class="line">alternative<span class="operator">:</span> 方向，单侧 <span class="string">&quot;less&quot;</span><span class="punctuation">,</span> <span class="string">&quot;greater&quot;</span> 或是双侧 <span class="string">&quot;two.sided&quot;</span> 与备择假设同向</span><br><span class="line">mu <span class="operator">=</span> <span class="number">0</span><span class="operator">:</span> 检验均值的 mu_0 ，默认 <span class="number">0</span></span><br><span class="line">conf.level <span class="operator">=</span> <span class="number">0.95</span><span class="operator">:</span> 置信水平</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">159</span><span class="punctuation">,</span> <span class="number">280</span><span class="punctuation">,</span> <span class="number">101</span><span class="punctuation">,</span> <span class="number">212</span><span class="punctuation">,</span> <span class="number">224</span><span class="punctuation">,</span> <span class="number">379</span><span class="punctuation">,</span> <span class="number">179</span><span class="punctuation">,</span> <span class="number">264</span><span class="punctuation">,</span> <span class="number">222</span><span class="punctuation">,</span> <span class="number">362</span><span class="punctuation">,</span> <span class="number">168</span><span class="punctuation">,</span> <span class="number">250</span><span class="punctuation">,</span> <span class="number">149</span><span class="punctuation">,</span> <span class="number">260</span><span class="punctuation">,</span> <span class="number">485</span><span class="punctuation">,</span> <span class="number">170</span><span class="punctuation">)</span></span><br><span class="line">t.test<span class="punctuation">(</span>X<span class="punctuation">,</span> alternative <span class="operator">=</span> <span class="string">&quot;greater&quot;</span><span class="punctuation">,</span> mu <span class="operator">=</span> <span class="number">225</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        One Sample t<span class="operator">-</span>test</span><br><span class="line"></span><br><span class="line">data<span class="operator">:</span>  X</span><br><span class="line">t <span class="operator">=</span> <span class="number">0.66852</span><span class="punctuation">,</span> df <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> p<span class="operator">-</span>value <span class="operator">=</span> <span class="number">0.257</span></span><br><span class="line">alternative hypothesis<span class="operator">:</span> true mean is greater than <span class="number">225</span></span><br><span class="line"><span class="number">95</span> percent confidence interval<span class="operator">:</span></span><br><span class="line"> <span class="number">198.2321</span>      <span class="literal">Inf</span></span><br><span class="line">sample estimates<span class="operator">:</span></span><br><span class="line">mean of x </span><br><span class="line">    <span class="number">241.5</span> </span><br></pre></td></tr></table></figure><p>T 检验量的值 <code>t = 0.66852</code></p><p>df 自由度 <code>n - 1 = 15</code></p><p>p-value <code>p-value = 0.257</code> 所以拒绝 <code>true mean is greater than 225</code></p><p><code>95%</code> 置信区间 <code>[198.2321, Inf]</code></p><h4 id="2-1-2-两样本均值差的推断"><a href="#2-1-2-两样本均值差的推断" class="headerlink" title="2.1.2 两样本均值差的推断"></a>2.1.2 两样本均值差的推断</h4><p>对于两个独立同分布的样本</p><script type="math/tex; mode=display">X_1,\ X_2,\ \cdots,\ X_n \sim N(\mu_1, \sigma_1^2)</script><script type="math/tex; mode=display">Y_1,\ Y_2,\ \cdots,\ Y_n \sim N(\mu_2, \sigma_2^2)</script><p>若方差相等 $\sigma_1 = \sigma_2$ 。</p><p><strong>使用 <code>t.test()</code> 函数</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.test<span class="punctuation">(</span>formula<span class="punctuation">,</span> data<span class="punctuation">,</span> subset<span class="punctuation">,</span> na.action <span class="operator">=</span> na.pass<span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formula<span class="operator">:</span> df<span class="operator">~</span><span class="built_in">class</span> 前者 df 为定量变量，后者 <span class="built_in">class</span> 为定类变量。</span><br><span class="line">data<span class="operator">:</span> 数据框</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;./Score.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">t.test<span class="punctuation">(</span>score <span class="operator">~</span> Gender<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span> <span class="comment"># 数据库 df 的 score 列按照 Gender 分类</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        Welch Two Sample t<span class="operator">-</span>test</span><br><span class="line"></span><br><span class="line">data<span class="operator">:</span>  score by Gender</span><br><span class="line">t <span class="operator">=</span> <span class="number">1.9163</span><span class="punctuation">,</span> df <span class="operator">=</span> <span class="number">97.963</span><span class="punctuation">,</span> p<span class="operator">-</span>value <span class="operator">=</span> <span class="number">0.05824</span>  <span class="comment"># df = m + n - 2</span></span><br><span class="line">alternative hypothesis<span class="operator">:</span> true difference <span class="keyword">in</span> means between group Female and group Male is not equal to <span class="number">0</span></span><br><span class="line"><span class="number">95</span> percent confidence interval<span class="operator">:</span></span><br><span class="line"> <span class="operator">-</span><span class="number">0.1422661</span>  <span class="number">8.1422661</span></span><br><span class="line">sample estimates<span class="operator">:</span></span><br><span class="line">mean <span class="keyword">in</span> group Female   mean <span class="keyword">in</span> group Male </span><br><span class="line">               <span class="number">73.12</span>                <span class="number">69.12</span> </span><br></pre></td></tr></table></figure><p><strong>检验模型近似正态：</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> df<span class="operator">$</span>score<span class="punctuation">[</span>df<span class="operator">$</span>Gender <span class="operator">==</span> <span class="string">&quot;Female&quot;</span><span class="punctuation">]</span></span><br><span class="line">y <span class="operator">&lt;-</span> df<span class="operator">$</span>score<span class="punctuation">[</span>df<span class="operator">$</span>Gender <span class="operator">==</span> <span class="string">&quot;Male&quot;</span><span class="punctuation">]</span></span><br><span class="line">png<span class="punctuation">(</span><span class="string">&quot;./img/qq_score.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">2400</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">1200</span><span class="punctuation">,</span> res <span class="operator">=</span> <span class="number">200</span><span class="punctuation">)</span></span><br><span class="line">op <span class="operator">&lt;-</span> par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">qqnorm<span class="punctuation">(</span>x<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Female&quot;</span><span class="punctuation">)</span></span><br><span class="line">qqline<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">qqnorm<span class="punctuation">(</span>y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Male&quot;</span><span class="punctuation">)</span></span><br><span class="line">qqline<span class="punctuation">(</span>y<span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>op<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/qq_score.png" alt="qq-plot"></p><p><strong>检验方差：</strong>经验直观的方法，比较 IQR</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxplot<span class="punctuation">(</span>score <span class="operator">~</span> Gender<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>或者使用 <code>vat.test()</code> </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Default S3 method:</span></span><br><span class="line">var.test<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> ratio <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">         alternative <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;two.sided&quot;</span><span class="punctuation">,</span> <span class="string">&quot;less&quot;</span><span class="punctuation">,</span> <span class="string">&quot;greater&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         conf.level <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## S3 method for class &#x27;formula&#x27;</span></span><br><span class="line">var.test<span class="punctuation">(</span>formula<span class="punctuation">,</span> data<span class="punctuation">,</span> subset<span class="punctuation">,</span> na.action<span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.test<span class="punctuation">(</span>score <span class="operator">~</span> Gender<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="built_in">F</span> test to compare two variances</span><br><span class="line"></span><br><span class="line">data<span class="operator">:</span>  score by Gender</span><br><span class="line"><span class="built_in">F</span> <span class="operator">=</span> <span class="number">1.0397</span><span class="punctuation">,</span> num df <span class="operator">=</span> <span class="number">49</span><span class="punctuation">,</span> denom df <span class="operator">=</span> <span class="number">49</span><span class="punctuation">,</span> p<span class="operator">-</span>value <span class="operator">=</span> <span class="number">0.892</span></span><br><span class="line">alternative hypothesis<span class="operator">:</span> true ratio of variances is not equal to <span class="number">1</span></span><br><span class="line"><span class="number">95</span> percent confidence interval<span class="operator">:</span></span><br><span class="line"> <span class="number">0.5900309</span> <span class="number">1.8322278</span></span><br><span class="line">sample estimates<span class="operator">:</span></span><br><span class="line">ratio of variances </span><br><span class="line">          <span class="number">1.039746</span> </span><br></pre></td></tr></table></figure><p>注意到方差不相等，则</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.test<span class="punctuation">(</span>score <span class="operator">~</span> Gender<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">,</span> var.equal <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        Welch Two Sample t<span class="operator">-</span>test</span><br><span class="line"></span><br><span class="line">data<span class="operator">:</span>  score by Gender</span><br><span class="line">t <span class="operator">=</span> <span class="number">1.9163</span><span class="punctuation">,</span> df <span class="operator">=</span> <span class="number">97.963</span><span class="punctuation">,</span> p<span class="operator">-</span>value <span class="operator">=</span> <span class="number">0.05824</span></span><br><span class="line">alternative hypothesis<span class="operator">:</span> true difference <span class="keyword">in</span> means between group Female and group Male is not equal to <span class="number">0</span></span><br><span class="line"><span class="number">95</span> percent confidence interval<span class="operator">:</span></span><br><span class="line"> <span class="operator">-</span><span class="number">0.1422661</span>  <span class="number">8.1422661</span></span><br><span class="line">sample estimates<span class="operator">:</span></span><br><span class="line">mean <span class="keyword">in</span> group Female   mean <span class="keyword">in</span> group Male </span><br><span class="line">               <span class="number">73.12</span>                <span class="number">69.12</span> </span><br></pre></td></tr></table></figure><h4 id="2-1-3-成对正态样本均值差的检验"><a href="#2-1-3-成对正态样本均值差的检验" class="headerlink" title="2.1.3 成对正态样本均值差的检验"></a>2.1.3 成对正态样本均值差的检验</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.test<span class="punctuation">(</span>X <span class="operator">-</span> Y<span class="punctuation">)</span></span><br><span class="line">t.test<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> paired <span class="operator">=</span> TURE<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="2-1-4-正态性检验-shapiro-test"><a href="#2-1-4-正态性检验-shapiro-test" class="headerlink" title="2.1.4 正态性检验 shapiro.test()"></a>2.1.4 正态性检验 shapiro.test()</h4><p>可以采用直观的 Q-Q 图和直方图检验，更严谨地采用 <code>shapiro.test()</code> 检验。</p><ul><li>p 值小于 0.05 ，总体不是正态</li><li>p 值大于 0.05 ，仅仅不能否认“总体是正态”</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">100</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> sd <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">shapiro.test<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        Shapiro<span class="operator">-</span>Wilk normality test</span><br><span class="line"></span><br><span class="line">data<span class="operator">:</span>  x</span><br><span class="line">W <span class="operator">=</span> <span class="number">0.98887</span><span class="punctuation">,</span> p<span class="operator">-</span>value <span class="operator">=</span> <span class="number">0.5745</span>  <span class="comment"># 不能否认 x 是正态</span></span><br></pre></td></tr></table></figure><h3 id="2-2-相关系数推断-cor-test"><a href="#2-2-相关系数推断-cor-test" class="headerlink" title="2.2 相关系数推断 cor.test()"></a>2.2 相关系数推断 cor.test()</h3><p>相关系数：描述了两变量 X, Y 之间数据的相关性。</p><p>三种相关系数：<code>Pearson</code> <code>Spearman</code> <code>Kendall</code> 。使用函数 <code>cor.test()</code> 进行检验：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Default S3 method:</span></span><br><span class="line">cor.test<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span></span><br><span class="line">         alternative <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;two.sided&quot;</span><span class="punctuation">,</span> <span class="string">&quot;less&quot;</span><span class="punctuation">,</span> <span class="string">&quot;greater&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         method <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;pearson&quot;</span><span class="punctuation">,</span> <span class="string">&quot;kendall&quot;</span><span class="punctuation">,</span> <span class="string">&quot;spearman&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         exact <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> conf.level <span class="operator">=</span> <span class="number">0.95</span><span class="punctuation">,</span> continuity <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## S3 method for class &#x27;formula&#x27;</span></span><br><span class="line">cor.test<span class="punctuation">(</span>formula<span class="punctuation">,</span> data<span class="punctuation">,</span> subset<span class="punctuation">,</span> na.action<span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>alternative</code> ：单侧或是双侧</li><li><code>method</code> ：选择三个相关系数之一</li><li><code>conf.level</code> ：置信水平</li></ul><p>有关 <code>alternative</code> （与备择假设同方向）：</p><ul><li>$H_1:\rho \neq 0$  对应 <code>alternative = c(&quot;two.sided&quot;)</code></li><li>$H_1:\rho &gt; 0$ 对应 <code>alternative = c(&quot;greater&quot;)</code></li><li>$H_1:\rho &lt; 0$ 对应 <code>alternative = c(&quot;less&quot;)</code></li></ul><p>计算相关系数的函数 <code>cor()</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cor<span class="punctuation">(</span>x<span class="punctuation">,</span> y <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> use <span class="operator">=</span> <span class="string">&quot;everything&quot;</span><span class="punctuation">,</span></span><br><span class="line">    method <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;pearson&quot;</span><span class="punctuation">,</span> <span class="string">&quot;kendall&quot;</span><span class="punctuation">,</span> <span class="string">&quot;spearman&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li><code>method</code> ：选择三个相关系数之一</li><li><code>use</code> ：可选 <code>&quot;everything&quot;</code>, <code>&quot;all.obs&quot;</code>, <code>&quot;complete.obs&quot;</code>, <code>&quot;na.or.complete&quot;</code>, or <code>&quot;pairwise.complete.obs&quot;</code></li></ul><p>例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">7.7</span><span class="punctuation">,</span> <span class="number">8.2</span><span class="punctuation">,</span> <span class="number">7.8</span><span class="punctuation">,</span> <span class="number">6.9</span><span class="punctuation">,</span> <span class="number">8.4</span><span class="punctuation">,</span> <span class="number">8.1</span><span class="punctuation">,</span> <span class="number">7.1</span><span class="punctuation">,</span> <span class="number">7.5</span><span class="punctuation">,</span> <span class="number">7.6</span><span class="punctuation">,</span> <span class="number">7.6</span><span class="punctuation">,</span> <span class="number">7.9</span><span class="punctuation">,</span> <span class="number">7.6</span><span class="punctuation">,</span> <span class="number">7.5</span><span class="punctuation">,</span> <span class="number">7.6</span><span class="punctuation">,</span> <span class="number">7.6</span><span class="punctuation">)</span></span><br><span class="line">Y <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">7.2</span><span class="punctuation">,</span> <span class="number">6.7</span><span class="punctuation">,</span> <span class="number">5.7</span><span class="punctuation">,</span> <span class="number">4.0</span><span class="punctuation">,</span> <span class="number">5.7</span><span class="punctuation">,</span> <span class="number">6.4</span><span class="punctuation">,</span> <span class="number">4.5</span><span class="punctuation">,</span> <span class="number">5.5</span><span class="punctuation">,</span> <span class="literal">NA</span><span class="punctuation">,</span> <span class="number">5.4</span><span class="punctuation">,</span> <span class="number">6.1</span><span class="punctuation">,</span> <span class="number">6.9</span><span class="punctuation">,</span> <span class="number">3.9</span><span class="punctuation">,</span> <span class="number">5.7</span><span class="punctuation">,</span> <span class="number">3.7</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">cor<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> use <span class="operator">=</span> <span class="string">&quot;na.or.complete&quot;</span><span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;pearson&quot;</span><span class="punctuation">)</span>  <span class="comment"># 0.5801752</span></span><br><span class="line"></span><br><span class="line">cor.test<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;pearson&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        Pearson<span class="string">&#x27;s product-moment correlation</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:  X and Y</span></span><br><span class="line"><span class="string">t = 2.4675, df = 12, p-value = 0.02963</span></span><br><span class="line"><span class="string">alternative hypothesis: true correlation is not equal to 0</span></span><br><span class="line"><span class="string">95 percent confidence interval:</span></span><br><span class="line"><span class="string"> 0.07165242 0.84931184</span></span><br><span class="line"><span class="string">sample estimates:</span></span><br><span class="line"><span class="string">      cor </span></span><br><span class="line"><span class="string">0.5801752 </span></span><br></pre></td></tr></table></figure><blockquote><p>X, Y 存在相同数字，考虑次序的 “kendall”, “spearman” 无法给出精确值。</p></blockquote>]]></content>
    
    
    <summary type="html">利用观测样本对总体参数的：点估计、区间估计与假设检验。</summary>
    
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/categories/R-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/tags/R-%E8%AF%AD%E8%A8%80/"/>
    
    <category term="统计软件" scheme="https://blog.iskage.online/tags/%E7%BB%9F%E8%AE%A1%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="R programming" scheme="https://blog.iskage.online/tags/R-programming/"/>
    
  </entry>
  
  <entry>
    <title>SQL 自学笔记（12）约束</title>
    <link href="https://blog.iskage.online/posts/79c2b529.html"/>
    <id>https://blog.iskage.online/posts/79c2b529.html</id>
    <published>2025-04-09T23:24:00.000Z</published>
    <updated>2025-04-10T15:08:47.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>SQL 对表/列有相关的约束，分别为：NOT NULL 非空约束；UNIQUE 唯一性约束；PRIMARY KEY 主键约束；FOREIGN KEY 外键约束；AUTO_INCREMENT 自增列；CHECK 检查约束；DEFAULT 默认值约束。</p><h2 id="1-约束-constraint"><a href="#1-约束-constraint" class="headerlink" title="1 约束 constraint"></a>1 约束 constraint</h2><h3 id="1-1-对数据表约束的目的"><a href="#1-1-对数据表约束的目的" class="headerlink" title="1.1 对数据表约束的目的"></a>1.1 对数据表约束的目的</h3><p>为了保证数据的完整性，SQL 规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p><ul><li>实体完整性（Entity Integrity） ：例如，同一个表中，不能存在两条完全相同无法区分的记录。</li><li>域完整性（Domain Integrity） ：例如，年龄范围 0-120，性别范围 “男/女”。</li><li>引用完整性（Referential Integrity） ：例如，员工所在部门，在部门表中要能找到这个部门。</li><li>用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等。</li></ul><h3 id="1-2-约束"><a href="#1-2-约束" class="headerlink" title="1.2 约束"></a>1.2 约束</h3><p>约束是表级的强制规定。可以在<strong>创建表时规定约束（通过 CREATE TABLE 语句）</strong>，或者在<strong>表创建之后通过 ALTER TABLE 语句规定约束</strong>。</p><p>根据约束数据列的限制，约束可分为：</p><ul><li><p>单列约束：每个约束只约束一列</p></li><li><p>多列约束：每个约束可约束多列数据</p></li></ul><p>根据约束的作用范围，约束可分为：</p><ul><li><p>列级约束：只能作用在一个列上，跟在列的定义后面</p></li><li><p>表级约束：可以作用在多个列上，不与列一起，而是单独定义</p></li></ul><p>根据约束起的作用，约束可分为：</p><ul><li><code>NOT NULL</code> 非空约束，规定某个字段不能为空</li><li><code>UNIQUE</code> 唯一性约束，规定某个字段在整个表中是唯一的</li><li><code>PRIMARY KEY</code> 主键 (非空且唯一) 约束</li><li><code>FOREIGN KEY</code> 外键约束</li><li><code>CHECK</code> 检查约束</li><li><code>DEFAULT</code> 默认值约束</li></ul><blockquote><p>特别地，MySQL8.0 后开始支持 <code>CHECK</code> 约束。</p></blockquote><h3 id="1-3-SQL-查看表的约束情况"><a href="#1-3-SQL-查看表的约束情况" class="headerlink" title="1.3 SQL 查看表的约束情况"></a>1.3 SQL 查看表的约束情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- information_schema 数据库名（系统库）</span></span><br><span class="line"><span class="comment">-- table_constraints 表名称（专门存储各个表的约束）</span></span><br><span class="line"></span><br><span class="line">USE 数据库名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">USE atguigudb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;employees&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744108676172.png" alt="数据库 atguigudb 的表 employees 的约束信息"></p><h2 id="2-NOT-NULL-非空约束"><a href="#2-NOT-NULL-非空约束" class="headerlink" title="2 NOT NULL 非空约束"></a>2 NOT NULL 非空约束</h2><h3 id="2-1-非空约束"><a href="#2-1-非空约束" class="headerlink" title="2.1 非空约束"></a>2.1 非空约束</h3><p><code>NOT NULL</code> ：限定某个字段/某列的值不允许为空</p><ul><li>默认所有的类型的值都可以是 NULL</li><li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li><li>一个表可以有很多列都分别限定了非空</li><li>空字符串 <code>&#39;&#39;</code> 不等于 NULL ， 0 也不等于 NULL</li></ul><h3 id="2-2-具体-SQL-实现"><a href="#2-2-具体-SQL-实现" class="headerlink" title="2.2 具体 SQL 实现"></a>2.2 具体 SQL 实现</h3><h4 id="2-2-1-添加非空约束"><a href="#2-2-1-添加非空约束" class="headerlink" title="2.2.1 添加非空约束"></a>2.2.1 添加非空约束</h4><p><strong>建表时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型 <span class="keyword">NOT NULL</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>建表后</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    MODIFY 字段名 数据类型 <span class="keyword">NOT NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-删除非空约束"><a href="#2-2-2-删除非空约束" class="headerlink" title="2.2.2 删除非空约束"></a>2.2.2 删除非空约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    MODIFY 字段名 数据类型 <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    MODIFY 字段名 数据类型;</span><br></pre></td></tr></table></figure><h2 id="3-UNIQUE-唯一性约束"><a href="#3-UNIQUE-唯一性约束" class="headerlink" title="3 UNIQUE 唯一性约束"></a>3 UNIQUE 唯一性约束</h2><h3 id="3-1-唯一性约束"><a href="#3-1-唯一性约束" class="headerlink" title="3.1 唯一性约束"></a>3.1 唯一性约束</h3><p><code>UNIQUE</code> ：用来限制某个字段/某列的值不能重复。</p><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li>MySQL 会给唯一约束的列上默认创建一个唯一索引。</li></ul><h3 id="3-2-具体-SQL-实现"><a href="#3-2-具体-SQL-实现" class="headerlink" title="3.2 具体 SQL 实现"></a>3.2 具体 SQL 实现</h3><h4 id="3-2-1-添加唯一性约束"><a href="#3-2-1-添加唯一性约束" class="headerlink" title="3.2.1 添加唯一性约束"></a>3.2.1 添加唯一性约束</h4><p><strong>建表时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型 <span class="keyword">UNIQUE</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">UNIQUE</span> KEY,</span><br><span class="line">    字段名 数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">UNIQUE</span> KEY (字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：多个字段 <code>NAME</code> <code>PASSWORD</code> 均不可重复，为数据表级别的约束。单独</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">USER</span></span><br><span class="line">(</span><br><span class="line">    id       <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    NAME     <span class="type">VARCHAR</span>(<span class="number">25</span>),</span><br><span class="line">    PASSWORD <span class="type">VARCHAR</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="comment">-- 表级约束语法</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uk_name_pwd <span class="keyword">UNIQUE</span> (NAME, PASSWORD)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;user_unique&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744116873047.png" alt="约束名"></p><p><strong>建表后</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> KEY (字段名列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式 2</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    MODIFY 字段名 字段类型 <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><blockquote><p>字段名列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的。</p></blockquote><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> user_unique</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (NAME, PASSWORD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER TABLE</span> user_unique</span><br><span class="line">    <span class="keyword">ADD CONSTRAINT</span> uk_name_pwd <span class="keyword">UNIQUE</span> (NAME, PASSWORD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER TABLE</span> user_unique</span><br><span class="line">    MODIFY NAME <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-复合唯一性约束"><a href="#3-2-2-复合唯一性约束" class="headerlink" title="3.2.2 复合唯一性约束"></a>3.2.2 复合唯一性约束</h4><p>上面的 <code>UNIQUE KEY (字段名列表)</code> 多个字段名，表示复合唯一，即多个字段的组合是唯一的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY (字段名列表)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="3-2-3-删除唯一性约束"><a href="#3-2-3-删除唯一性约束" class="headerlink" title="3.2.3 删除唯一性约束"></a>3.2.3 删除唯一性约束</h4><p>添加唯一性约束的列上也会<strong>自动创建唯一索引</strong>：</p><ul><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和 <code>(字段名列表)</code> 中排在第一个的列名相同。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表的索引</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> user_unique;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744117536023.png" alt="查看表的索引"></p><p>也可以使用 <code>information_schema.table_constraints</code> 查看约束名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;user_unique&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744116873047.png" alt="约束名"></p><p><strong>删除唯一性约束</strong> ：无论如何，删除 <code>UNIQUE</code> 需要删除的是索引，索引的名称一般为约束名，用如下 SQL 语句删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名</span><br><span class="line">    <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> user_unique</span><br><span class="line">    <span class="keyword">DROP</span> INDEX uk_name_pwd;</span><br></pre></td></tr></table></figure><h2 id="4-PRIMARY-KEY-主键约束"><a href="#4-PRIMARY-KEY-主键约束" class="headerlink" title="4 PRIMARY KEY 主键约束"></a>4 PRIMARY KEY 主键约束</h2><h3 id="4-1-主键约束"><a href="#4-1-主键约束" class="headerlink" title="4.1 主键约束"></a>4.1 主键约束</h3><p><code>PRIMARY KEY</code> ：用来唯一标识表中的一行记录。</p><ul><li>主键约束相当于<strong>唯一约束 + 非空约束的组合</strong>，主键约束列不允许重复，也不允许出现空值。</li><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li><li>主键约束对应着表中的一列或者多列（复合主键）。如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li><li><p>MySQL 的主键名为 <code>PRIMARY</code> ，自定义重命名无用。</p></li><li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的<strong>主键索引</strong>。如果删除主键约束，主键约束对应的索引自动删除。</p></li></ul><blockquote><p>【注意】不要修改主键字段的值</p></blockquote><h3 id="4-2-具体-SQL-实现"><a href="#4-2-具体-SQL-实现" class="headerlink" title="4.2 具体 SQL 实现"></a>4.2 具体 SQL 实现</h3><h4 id="4-2-1-添加主键约束"><a href="#4-2-1-添加主键约束" class="headerlink" title="4.2.1 添加主键约束"></a>4.2.1 添加主键约束</h4><p><strong>建表时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- example 1</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型 <span class="keyword">PRIMARY KEY</span>, <span class="comment">-- 列级模式</span></span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- example 2</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型, </span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">PRIMARY KEY</span> (字段名列表) <span class="comment">-- 表级模式</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> temp</span><br><span class="line">(</span><br><span class="line">    id   <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> temp;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span>  <span class="comment">-- 主键 PRI</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><strong>建表后</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> (字段名列表);</span><br></pre></td></tr></table></figure><h4 id="4-2-2-复合主键约束"><a href="#4-2-2-复合主键约束" class="headerlink" title="4.2.2 复合主键约束"></a>4.2.2 复合主键约束</h4><p><code>(字段名列表)</code> 多个字段名共同构成主键：如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (字段名列表)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="4-2-3-删除主键约束"><a href="#4-2-3-删除主键约束" class="headerlink" title="4.2.3 删除主键约束"></a>4.2.3 删除主键约束</h4><p>删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空约束还存在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">PRIMARY KEY</span>;</span><br></pre></td></tr></table></figure><blockquote><p>【注意】删除时指定删除的为 <code>PRIMARY KEY</code> 不会存在歧义。即在 <code>[CONSTRAINT 约束名]</code> 自定义的约束名并不会起作用。MySQL 仍然使用 <code>PRIMARY</code> 作为主键约束的索引名和约束名：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> temp_primary</span><br><span class="line">(</span><br><span class="line">    id   <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    age  <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> temp_pri <span class="keyword">PRIMARY KEY</span> (id, name)  <span class="comment">-- 自定义约束名 temp_pri</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引名</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> temp_primary;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看约束名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;temp_primary&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744120025879.png" alt="索引名仍然为 PRIMARY 不是自定义的 temp_pri"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1744120160431.png" alt="约束名仍然为 PRIMARY 不是自定义的 temp_pri"></p><h2 id="5-FOREIGN-KEY-外键约束"><a href="#5-FOREIGN-KEY-外键约束" class="headerlink" title="5 FOREIGN KEY 外键约束"></a>5 FOREIGN KEY 外键约束</h2><h3 id="5-1-外键约束"><a href="#5-1-外键约束" class="headerlink" title="5.1 外键约束"></a>5.1 外键约束</h3><p><code>FOREIGN KEY</code> ：限定某个表的某个字段的引用完整性。比如：员工表的员工所在部门，必须在部门表能找到对应的部分。</p><ul><li>主表（父表）：被引用的表，被参考的表</li><li>从表（子表）：引用别人的表，参考别人的表</li></ul><p><strong>特点：</strong></p><ul><li>从表的外键列，必须引用主表的主键或唯一约束的列（否则无法对应）。</li><li>在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名。</li><li>若创建表时指定外键约束，要先有主表，再创建从表。</li><li>删表时，先删从表（或先删除外键约束），再删除主表。</li><li>当主表的记录被从表参照时，主表的记录将不允许删除。如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据。</li><li>从表的外键列与主表被参照的列数据类型必须一样，逻辑意义一致。</li><li>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。索引名是外键的约束名，以此提高外键查询的速度。</li><li>删除外键约束后，必须手动删除对应的索引。</li></ul><p><strong>约束关系是针对双方的：</strong></p><ul><li>添加了外键约束后，主表的修改和删除数据受约束</li><li>添加了外键约束后，从表的添加和修改数据受约束</li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><h3 id="5-2-具体-SQL-实现"><a href="#5-2-具体-SQL-实现" class="headerlink" title="5.2 具体 SQL 实现"></a>5.2 具体 SQL 实现</h3><h4 id="5-2-1-添加外键约束"><a href="#5-2-1-添加外键约束" class="headerlink" title="5.2.1 添加外键约束"></a>5.2.1 添加外键约束</h4><p><strong>建表时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 先有主表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> 主表名称</span><br><span class="line">(</span><br><span class="line">    字段<span class="number">1</span> 数据类型 <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    字段<span class="number">2</span> 数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 再指定从表外键</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> 从表名称</span><br><span class="line">(</span><br><span class="line">    字段<span class="number">1</span> 数据类型 <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    字段<span class="number">2</span> 数据类型,</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> 外键约束名] <span class="keyword">FOREIGN KEY</span> (从表的某个字段) <span class="keyword">REFERENCES</span> 主表名 (被参考字段)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 先有主表 部门表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> dept_foreign</span><br><span class="line">(</span><br><span class="line">    d_id   <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    d_name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 再指定从表外键 员工表的部门 id 指向部门表的 id</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> emp_foreign</span><br><span class="line">(</span><br><span class="line">    e_id    <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    e_name  <span class="type">VARCHAR</span>(<span class="number">5</span>),</span><br><span class="line">    dept_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (dept_id) <span class="keyword">REFERENCES</span> dept_foreign (d_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>索引名默认为列名 <code>dept_id</code> ，但约束名系统自动产生 <code>emp_foreign_ibfk_1</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> emp_foreign;  <span class="comment">-- dept_id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;emp_foreign&#x27;</span>;  <span class="comment">-- emp_foreign_ibfk_1</span></span><br></pre></td></tr></table></figure><p><strong>建表后</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 从表名</span><br><span class="line">    <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN KEY</span> (从表某一字段名) <span class="keyword">REFERENCES</span> 主表名 (主表字段名);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> emp_foreign</span><br><span class="line">    <span class="keyword">ADD CONSTRAINT</span> emp_foreign_key <span class="keyword">FOREIGN KEY</span> (dept_id) <span class="keyword">REFERENCES</span> dept_foreign (d_id);</span><br></pre></td></tr></table></figure><p>此时索引名变为自定义的约束名 <code>emp_foreign_key</code> ，但约束名除了系统自动产生的约束名 <code>emp_foreign_ibfk_1</code> 外，新增了自定义的约束名 <code>emp_foreign_key</code> 。</p><h4 id="5-2-2-约束等级"><a href="#5-2-2-约束等级" class="headerlink" title="5.2.2 约束等级"></a>5.2.2 约束等级</h4><p>父表进行数据更新/删除时，子表的不同变化：</p><ul><li><code>Cascade</code> 方式 ：在父表上 update/delete 记录时，同步 update/delete 掉子表的匹配记录。</li><li><code>Set null</code> 方式 ：在父表上 update/delete 记录时，将子表上匹配记录的列设为 null ，但是要注意子表的外键列不能有非空约束。</li><li><code>No action</code> 方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行 update/delete 操作。</li><li><code>Restrict</code> 方式 ：同 No action 方式， 都是立即检查外键约束。</li><li><code>Set default</code> 方式 ：父表有变更时，子表将外键列设置成一个默认的值。</li></ul><p>如果没有指定等级，<strong>默认 Restrict 方式</strong>。</p><p>对于<strong>外键约束，最好是采用: <code>ON UPDATE CASCADE ON DELETE RESTRICT</code> 的方式</strong>。即更新时采用 Cascade 方式，删除时采用 Restrict 方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> emp_foreign</span><br><span class="line">(</span><br><span class="line">    e_id    <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    e_name  <span class="type">VARCHAR</span>(<span class="number">5</span>),</span><br><span class="line">    dept_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (dept_id) <span class="keyword">REFERENCES</span> dept_foreign (d_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="5-2-3-删除外键约束"><a href="#5-2-3-删除外键约束" class="headerlink" title="5.2.3 删除外键约束"></a>5.2.3 删除外键约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 查看约束名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 删除外键约束</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 从表名</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> 外键约束名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看索引名</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 删除索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 从表名</span><br><span class="line">    <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 查看约束名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;emp_foreign&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 删除外键约束</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> emp_foreign</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> emp_foreign_ibfk_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看索引名</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> emp_foreign;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 删除索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> emp_foreign</span><br><span class="line">    <span class="keyword">DROP</span> INDEX dept_id;</span><br></pre></td></tr></table></figure><h2 id="6-AUTO-INCREMENT-自增列"><a href="#6-AUTO-INCREMENT-自增列" class="headerlink" title="6 AUTO_INCREMENT 自增列"></a>6 AUTO_INCREMENT 自增列</h2><h3 id="6-1-自增列概述"><a href="#6-1-自增列概述" class="headerlink" title="6.1 自增列概述"></a>6.1 自增列概述</h3><p><code>AUTO_INCREMENT</code> ：某个字段的值自增。</p><ul><li>一个表最多只能有一个自增长列。当需要产生唯一标识符或顺序值时，可设置自增长。</li><li>自增列约束的列必须是键列（主键列或唯一键列）</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和 NULL ，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li></ul><h3 id="6-2-具体-SQL-实现"><a href="#6-2-具体-SQL-实现" class="headerlink" title="6.2 具体 SQL 实现"></a>6.2 具体 SQL 实现</h3><h4 id="6-2-1-添加自增列"><a href="#6-2-1-添加自增列" class="headerlink" title="6.2.1 添加自增列"></a>6.2.1 添加自增列</h4><p><strong>建表时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 常见格式</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型 <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    字段名 数据类型 <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> 默认值</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型 <span class="keyword">DEFAULT</span> 默认值,</span><br><span class="line">    字段名 数据类型 <span class="keyword">UNIQUE</span> KEY AUTO_INCREMENT,</span><br><span class="line">    字段名 数据类型 <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> 默认值,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> emp_increment</span><br><span class="line">(</span><br><span class="line">    e_id   <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    e_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>建表后</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名</span><br><span class="line">    MODIFY 字段名 数据类型 AUTO_INCREMENT;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> emp_increment</span><br><span class="line">    MODIFY e_id <span class="type">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure><h4 id="6-2-2-删除自增列"><a href="#6-2-2-删除自增列" class="headerlink" title="6.2.2 删除自增列"></a>6.2.2 删除自增列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    MODIFY 字段名 数据类型; <span class="comment">-- 去掉 AUTO_INCREMENT 相当于删除</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> emp_increment</span><br><span class="line">    MODIFY e_id <span class="type">INT</span>;</span><br></pre></td></tr></table></figure><h2 id="7-CHECK-检查约束"><a href="#7-CHECK-检查约束" class="headerlink" title="7 CHECK 检查约束"></a>7 CHECK 检查约束</h2><h3 id="7-1-检查约束"><a href="#7-1-检查约束" class="headerlink" title="7.1 检查约束"></a>7.1 检查约束</h3><p><code>CHECK</code> ：检查某个字段的值是否符号某些要求。</p><p>例如：对于性别，只有 <code>Male</code> 和 <code>Female</code> ，可以对数据进行初步检查。</p><h3 id="7-2-具体-SQL-实现"><a href="#7-2-具体-SQL-实现" class="headerlink" title="7.2 具体 SQL 实现"></a>7.2 具体 SQL 实现</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型 <span class="keyword">CHECK</span> (约束表达式)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> emp_check</span><br><span class="line">(</span><br><span class="line">    e_id   <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    e_name <span class="type">VARCHAR</span>(<span class="number">5</span>),</span><br><span class="line">    gender <span class="type">CHAR</span> <span class="keyword">CHECK</span> (gender <span class="keyword">in</span> (<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> emp_check</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> emp_check</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">3819</span> (HY000): <span class="keyword">Check</span> <span class="keyword">constraint</span> <span class="string">&#x27;emp_check_chk_1&#x27;</span> <span class="keyword">is</span> violated.</span><br></pre></td></tr></table></figure><h2 id="8-DEFAULT-默认值约束"><a href="#8-DEFAULT-默认值约束" class="headerlink" title="8 DEFAULT 默认值约束"></a>8 DEFAULT 默认值约束</h2><h3 id="8-1-默认值约束"><a href="#8-1-默认值约束" class="headerlink" title="8.1 默认值约束"></a>8.1 默认值约束</h3><p><code>DEFAULT</code> ：给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><h3 id="8-2-具体-SQL-实现"><a href="#8-2-具体-SQL-实现" class="headerlink" title="8.2 具体 SQL 实现"></a>8.2 具体 SQL 实现</h3><h4 id="8-2-1-添加默认值约束"><a href="#8-2-1-添加默认值约束" class="headerlink" title="8.2.1 添加默认值约束"></a>8.2.1 添加默认值约束</h4><p><strong>建表时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名</span><br><span class="line">(</span><br><span class="line">    字段名 数据类型 <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    字段名 数据类型 <span class="keyword">DEFAULT</span> 默认值</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> emp_default</span><br><span class="line">(</span><br><span class="line">    e_id   <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    e_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    sal    <span class="type">FLOAT</span>                <span class="keyword">DEFAULT</span> <span class="number">0.0</span>,</span><br><span class="line">    tel    <span class="type">CHAR</span>(<span class="number">11</span>)    <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>建表后</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    MODIFY 字段名 数据类型 <span class="keyword">default</span> 默认值 [其他约束];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> emp_default</span><br><span class="line">    MODIFY sal <span class="type">FLOAT</span> <span class="keyword">DEFAULT</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-删除默认值约束"><a href="#8-2-2-删除默认值约束" class="headerlink" title="8.2.2 删除默认值约束"></a>8.2.2 删除默认值约束</h4><p>类似的，当删除某个约束时，重新写一遍约束，但删去这个约束即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名称</span><br><span class="line">    MODIFY 字段名 数据类型 [其他约束];  <span class="comment">-- 删除 DEFAULT 约束</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SQL 对表/列有相关的约束，分别为：NOT NULL 非空约束；UNIQUE 唯一性约束；PRIMARY KEY 主键约束；FOREIGN KEY 外键约束；AUTO_INCREMENT 自增列；CHECK 检查约束；DEFAULT 默认值约束。</summary>
    
    
    
    <category term="MySQL" scheme="https://blog.iskage.online/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.iskage.online/tags/MySQL/"/>
    
    <category term="SQL" scheme="https://blog.iskage.online/tags/SQL/"/>
    
    <category term="数据库" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>优先级队列 (Priority Queue) 和堆 (Heap)</title>
    <link href="https://blog.iskage.online/posts/78a0681d.html"/>
    <id>https://blog.iskage.online/posts/78a0681d.html</id>
    <published>2025-04-06T12:16:00.000Z</published>
    <updated>2025-04-10T15:13:04.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先级队列-Priority-Queue-和堆-Heap"><a href="#优先级队列-Priority-Queue-和堆-Heap" class="headerlink" title="优先级队列 (Priority Queue) 和堆 (Heap)"></a>优先级队列 (Priority Queue) 和堆 (Heap)</h1><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。【建议 star !】</p><hr><p>本章讲解优先级队列、基于堆实现的优先级队列、一些常用的排序算法（选择排序、插入排序和高级排序算法——堆排序）。特别地，堆是一种特殊的二叉树，我们基于 Python 数组实现堆；Python 实现排序算法。</p><h2 id="1-优先级队列"><a href="#1-优先级队列" class="headerlink" title="1 优先级队列"></a>1 优先级队列</h2><h3 id="1-1-优先级队列的抽象数据类型"><a href="#1-1-优先级队列的抽象数据类型" class="headerlink" title="1.1 优先级队列的抽象数据类型"></a>1.1 优先级队列的抽象数据类型</h3><h4 id="1-1-1-优先级"><a href="#1-1-1-优先级" class="headerlink" title="1.1.1 优先级"></a>1.1.1 优先级</h4><p>队列这一数据结构，遵循 <strong>FIFO（先入先出）</strong>的规则进行元素的插入和删除。然而，现实生活中有时我们需要一个除 FIFO 功能外还有额外删除功能的队列。我们引入<strong>优先级队列（Priority Queue）</strong>这一概念来描述这一类队列，其删除操作为删除具有<strong>最高优先级</strong>的元素。</p><ul><li>例如：航空公司的候补等待（standby）队列中，优先级更高的乘客即使到的更晚，也有可能更早获得候补机会。</li></ul><h4 id="1-1-2-优先级队列-ADT"><a href="#1-1-2-优先级队列-ADT" class="headerlink" title="1.1.2 优先级队列 ADT"></a>1.1.2 优先级队列 ADT</h4><p>优先级队列中存储：一个元素和其优先级，构成键-值对结构 <code>(key, value)</code> 。在优先级队列 <code>P</code> 上定义的优先级队列 ADT 支持以下方法（本章的优先级不妨设为<strong>最小值 min</strong>）：</p><ul><li><code>P.add(k, v)</code> ：向优先级队列 P 中插人一个键值对 <code>(k, v)</code> 。</li><li><code>P.min()</code> ：返回一个元组 <code>(k, v)</code> ，代表优先级队列 P 中一个键值对，该元组的键值是最小值（但是没有移除该元组）；如果队列为空，将发生错误。</li><li><code>P.remove_min()</code> ：从优先级队列 P 中移除一个拥有最小键值的元组，并且返回这个被移除的元组，<code>(k, v)</code> 代表这个被移除的元组的键和值；如果优先级队列为空，将发生错误。</li><li><code>P.is_empty()</code> ：如果优先级队列不包含任何元组，将返回 <code>True</code> 。</li><li><code>len(P)</code> ：返回优先级队列中元组的数量。</li></ul><p>下面的例子展示了这些功能的具体过程：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743831618569.png" alt="优先级队列的 ADT"></p><h3 id="1-2-优先级队列的实现"><a href="#1-2-优先级队列的实现" class="headerlink" title="1.2 优先级队列的实现"></a>1.2 优先级队列的实现</h3><h4 id="1-2-1-组合设计模式"><a href="#1-2-1-组合设计模式" class="headerlink" title="1.2.1 组合设计模式"></a>1.2.1 组合设计模式</h4><p>组合设计模式：定义一个 <code>_Item</code> 类，用它来确保在主要的数据结构中每个元组保存它相关计数值。</p><p>对于优先级队列，我们将使用组合设计模式来存储内部元组，该元组包含键 <code>k</code> 和值 <code>v</code> 构成的数值对。为后续的构建提供方便，这里构建了一个基础父类，未来的类均继承于 <code>PriorityQueueBase</code> 类，其中包含一个嵌套类 <code>_Item</code> 的定义。对于元组实例 <code>a</code> 和 <code>b</code> ，重载比较符 <code>&lt;</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueueBase</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优先级队列的抽象数据类型基础类 ADT</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- 嵌套的 _Item 类 ----------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Item</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;每一个元素的存储方式：(k, v)&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_key&#x27;</span>, <span class="string">&#x27;_value&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k, v</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;初始化键值对 (k, v)&quot;&quot;&quot;</span></span><br><span class="line">            <span class="variable language_">self</span>._key = k</span><br><span class="line">            <span class="variable language_">self</span>._value = v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;重载运算符 &lt;&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._key &lt; other._key  <span class="comment"># 根据 key 键值比较大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- 优先级队列 ADT ----------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;__len__ 方法暂时未定义，由子类定义&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的键值需要满足<strong>全序关系</strong>：</p></blockquote><p><strong>全序关系：</strong>一个集合 $A$ 上的全序关系需满足</p><ul><li>自反性</li></ul><script type="math/tex; mode=display">\forall\ x \in A,\quad x \leq x</script><ul><li>反对称性</li></ul><script type="math/tex; mode=display">\forall\ x,\ y \in A,\quad x \leq y\ \wedge\ y \leq x \quad\Rightarrow\quad x = y</script><ul><li>传递性</li></ul><script type="math/tex; mode=display">\forall\ x,\ y,\ z \in A,\quad x\leq y,\ y\leq z \quad\Rightarrow\quad x \leq z</script><ul><li>$A$ 中任意两个元素均可比较</li></ul><h4 id="1-2-2-未排序列表实现优先级队列"><a href="#1-2-2-未排序列表实现优先级队列" class="headerlink" title="1.2.2 未排序列表实现优先级队列"></a>1.2.2 未排序列表实现优先级队列</h4><p>创建未排序的列表实现优先级队列的 <code>UnsortedPriorityQueue</code> 类，它继承优先级队列 ADT <code>PriorityQueueBase</code> 类。未排序指的是，每次 <code>add</code> 增加新元素时，直接在列表后面加入；但每次查找/删除元素时 <code>min()</code> <code>remove_min()</code> 都需要遍历列表找到最小值。</p><blockquote><p>注意：这里使用了之前章节 <a href="https://zhuanlan.zhihu.com/p/29813136429">链表</a> 定义的 <code>PositionalList</code> 。也可以在我的 <a href="https://github.com/isKage/dsa-notes/blob/main/lec8_priority_queue_heap/utils/positional_list.py">Github 库</a> 中找到代码内容。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsortedPriorityQueue</span>(<span class="title class_ inherited__">PriorityQueueBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;未排序的列表实现优先级队列&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化，利用队列类 PositionalList&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._data = PositionalList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;增加元素 (key, value)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 向 PositionalList 队列类新增 _Item 类实例</span></span><br><span class="line">        <span class="variable language_">self</span>._data.add_last(<span class="variable language_">self</span>._Item(key, value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find_min</span>(<span class="params">self</span>) -&gt; PositionalList.Position:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;最小键值元素 _Item&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Priority queue is empty&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历</span></span><br><span class="line">        small = <span class="variable language_">self</span>._data.first()</span><br><span class="line">        walk = <span class="variable language_">self</span>._data.after(small)</span><br><span class="line">        <span class="keyword">while</span> walk <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 这里的 element 返回的是一个 _Item 类</span></span><br><span class="line">            <span class="keyword">if</span> walk.element() &lt; small.element():</span><br><span class="line">                small = walk  <span class="comment"># 记录最小值</span></span><br><span class="line">            walk = <span class="variable language_">self</span>._data.after(walk)  <span class="comment"># 向后更新一步</span></span><br><span class="line">        <span class="keyword">return</span> small  <span class="comment"># 遍历完后得到最小值 (返回的是 PositionalList.Position 类)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回最小 (key, value)&quot;&quot;&quot;</span></span><br><span class="line">        p = <span class="variable language_">self</span>._find_min()</span><br><span class="line">        item = p.element()  <span class="comment"># PositionalList.Position._node._element -&gt; _Item 类</span></span><br><span class="line">        <span class="keyword">return</span> (item._key, item._value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_min</span>(<span class="params">self</span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回最小 (key, value) 并删除&quot;&quot;&quot;</span></span><br><span class="line">        p = <span class="variable language_">self</span>._find_min()</span><br><span class="line">        item = <span class="variable language_">self</span>._data.delete(p)</span><br><span class="line">        <span class="keyword">return</span> (item._key, item._value)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    upq = UnsortedPriorityQueue()</span><br><span class="line">    upq.add(<span class="number">1</span>, <span class="string">&#x27;small&#x27;</span>)</span><br><span class="line">    upq.add(<span class="number">3</span>, <span class="string">&#x27;median&#x27;</span>)</span><br><span class="line">    upq.add(<span class="number">5</span>, <span class="string">&#x27;large&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The min is:&quot;</span>, upq.<span class="built_in">min</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Delete the min:&quot;</span>, upq.remove_min())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now, the min is:&quot;</span>, upq.<span class="built_in">min</span>())</span><br><span class="line"><span class="comment"># The min is: (1, &#x27;small&#x27;)</span></span><br><span class="line"><span class="comment"># Delete the min: (1, &#x27;small&#x27;)</span></span><br><span class="line"><span class="comment"># Now, the min is: (3, &#x27;median&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-排序列表实现优先级队列"><a href="#1-2-3-排序列表实现优先级队列" class="headerlink" title="1.2.3 排序列表实现优先级队列"></a>1.2.3 排序列表实现优先级队列</h4><p>创建排序的列表实现优先级队列的 <code>SortedPriorityQueue</code> 类，它继承优先级队列 ADT <code>PriorityQueueBase</code> 类。排序指的是，每次 <code>add</code> 增加新元素时，都进行比较，使得队列一直都是有序状态，例如从小到大；每次查找/删除元素时 <code>min()</code> <code>remove_min()</code> 只需要拿出队列第一个元素即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortedPriorityQueue</span>(<span class="title class_ inherited__">PriorityQueueBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;排序的列表实现优先级队列&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化，利用队列类 PositionalList&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._data = PositionalList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;增加元素 (key, value)&quot;&quot;&quot;</span></span><br><span class="line">        newest = <span class="variable language_">self</span>._Item(key, value)  <span class="comment"># 创建新的 _Item 类实例</span></span><br><span class="line">        walk = <span class="variable language_">self</span>._data.last()  <span class="comment"># 从最后开始检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到第一个比 newest 大的元素</span></span><br><span class="line">        <span class="keyword">while</span> walk <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> newest &lt; walk.element():</span><br><span class="line">            walk = <span class="variable language_">self</span>._data.before(walk)  <span class="comment"># go ahead</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向 PositionalList 队列类新增 _Item 类实例</span></span><br><span class="line">        <span class="keyword">if</span> walk <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>._data.add_first(newest)  <span class="comment"># 第一个位置插入</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>._data.add_after(walk, newest)  <span class="comment"># 在 walk 后插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回最小 (key, value)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Priority queue is empty&#x27;</span>)</span><br><span class="line">        <span class="comment"># 有序队列：第一个元素即为最小</span></span><br><span class="line">        p = <span class="variable language_">self</span>._data.first()</span><br><span class="line">        item = p.element()</span><br><span class="line">        <span class="keyword">return</span> (item._key, item._value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_min</span>(<span class="params">self</span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回最小 (key, value) 并删除&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Priority queue is empty&#x27;</span>)</span><br><span class="line">        <span class="comment"># 同理，第一个元素即为最小</span></span><br><span class="line">        item = <span class="variable language_">self</span>._data.delete(<span class="variable language_">self</span>._data.first())</span><br><span class="line">        <span class="keyword">return</span> (item._key, item._value)</span><br></pre></td></tr></table></figure><p>例如：结果相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">spq = SortedPriorityQueue()</span><br><span class="line">    spq.add(<span class="number">1</span>, <span class="string">&#x27;small&#x27;</span>)</span><br><span class="line">    spq.add(<span class="number">3</span>, <span class="string">&#x27;median&#x27;</span>)</span><br><span class="line">    spq.add(<span class="number">5</span>, <span class="string">&#x27;large&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The min is:&quot;</span>, spq.<span class="built_in">min</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Delete the min:&quot;</span>, spq.remove_min())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now, the min is:&quot;</span>, spq.<span class="built_in">min</span>())</span><br><span class="line"><span class="comment"># The min is: (1, &#x27;small&#x27;)</span></span><br><span class="line"><span class="comment"># Delete the min: (1, &#x27;small&#x27;)</span></span><br><span class="line"><span class="comment"># Now, the min is: (3, &#x27;median&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="1-2-4-算法分析-amp-比较"><a href="#1-2-4-算法分析-amp-比较" class="headerlink" title="1.2.4 算法分析&amp;比较"></a>1.2.4 算法分析&amp;比较</h4><p>排序与未排序列表实现优先级队列的主要区别在于 (1) 插入 (2) 删除/查找最小元素</p><ul><li><strong>未排序列表</strong>：每次直接在尾部插入新元素，所以复杂度为 <code>O(1)</code> ；但查找和删除最小元素却需要遍历列表寻找，复杂度为 <code>O(n)</code> 。</li><li><strong>排序列表</strong>：排序列表则相反。每次插入新元素，都需要遍历来找到最佳位置，所以复杂度为 <code>O(n)</code> ；但查找和删除最小元素只需要对队列第一个元素操作，复杂度为 <code>O(1)</code> 。</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743837646130.png" alt="排序与否的比较"></p><h2 id="2-堆"><a href="#2-堆" class="headerlink" title="2 堆"></a>2 堆</h2><p><strong>二进制堆的数据结构</strong>：一个更加有效的优先级队列的实现。这个数据结构允许我们以对数时间复杂度 <code>O(log(n))</code> 来实现插人和删除操作。</p><h3 id="2-1-堆的数据结构"><a href="#2-1-堆的数据结构" class="headerlink" title="2.1 堆的数据结构"></a>2.1 堆的数据结构</h3><p><strong>堆是一棵二叉树 T </strong>，该树的节点上存储了集合中的元组并且满足两个附加的属性：关系属性以存储键的形式在 T 中定义；结构属性以树 T 自身形状的方式定义。</p><h4 id="2-1-1-Heap-Order-属性"><a href="#2-1-1-Heap-Order-属性" class="headerlink" title="2.1.1 Heap-Order 属性"></a>2.1.1 Heap-Order 属性</h4><p><strong>在堆 T 中，对于除了根的每个位置 p ，存储在 p 中的键值大于或等于存储在 p 的父节点的键值。即 $key(p) \geq key(parent(p))$ 。</strong></p><p>作为 Heap-Order 属性的结果，T 中从根到叶子的路径上的键值是以非递减顺序排列的。也就是说，一个<strong>最小的键总是存储在 T 的根节点</strong>中。这使得调用 <code>min</code> 或 <code>remove_min</code> 时，能够比较容易地定位这样的元组，一般情况下它被认为“在堆的顶部”。</p><h4 id="2-1-2-完全二叉树属性"><a href="#2-1-2-完全二叉树属性" class="headerlink" title="2.1.2 完全二叉树属性"></a>2.1.2 完全二叉树属性</h4><p><strong>一个高度为 h 的堆 T 是一棵完全二叉树：即 T 的 $0,\ 1,\ 2,\ \cdots,\ h - 1$ 层上尽可能达到节点数的最大值 $2^i$ ，并且剩余的节点在 h 层尽可能保存在最左的位置。</strong></p><p>完全二叉树属性是为了尽可能提高遍历效率，后面我们会看到，影响高度 h 是影响堆效率的主要因素，而完全二叉树能保证在节点数固定为 n 时使得高度最小，大概为 $\log n$ 。</p><h4 id="2-1-3-堆的高度"><a href="#2-1-3-堆的高度" class="headerlink" title="2.1.3 堆的高度"></a>2.1.3 堆的高度</h4><p><strong>堆/完全二叉树的高度 $h = [\log n]$ 。其中 [] 表示取整。</strong></p><p>这是完全二叉树的性质，我们假设节点数为 n 的高度为 h ，则完全二叉树需要满足：</p><script type="math/tex; mode=display">1+ (1 + 2 + \cdots + 2^{h-1}) = 2^h \leq n \leq 2^h - 1 + 2^h = 2^{h+1} - 1</script><p>于是可以推出 $n = [\log n]$ 。</p><p>下面是一个标准的堆的例子：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743840261916.png" alt="堆的完全二叉树结构例子"></p><h3 id="2-2-使用堆实现优先级队列"><a href="#2-2-使用堆实现优先级队列" class="headerlink" title="2.2 使用堆实现优先级队列"></a>2.2 使用堆实现优先级队列</h3><p><code>min()</code> 方法的实现很简单，由于堆的 Heap-Order 属性，位于根节点的元素一定是 <code>min()</code> ，所以时间复杂度为 <code>O(1)</code> 。</p><h4 id="2-2-1-插入和向上冒泡"><a href="#2-2-1-插入和向上冒泡" class="headerlink" title="2.2.1 插入和向上冒泡"></a>2.2.1 插入和向上冒泡</h4><p>优先级队列的 <code>add(k, v)</code> 操作对应于在堆中插入一个新元组</p><p>堆中元素的插入由三个步骤组成：</p><ul><li>找到插入新节点的位置 z</li><li>将新元组放在位置 z 处</li><li>通过<strong>向上冒泡</strong>恢复堆的 Heap-Order 属性</li></ul><p>插入新元组后，堆可能变得不满足 Heap-Order 性质：</p><ul><li>通过对新节点和其父节点的键值进行比较，并在必要时交换两个节点的位置，不断重复即可恢复其Heap-Order 性质，这种操作被称为<strong>堆向上冒泡 Up-Heap Bubbling</strong> </li><li>堆向上冒泡操作在新节点成为根节点或其键值大于其父节点键值时停止</li><li>堆向上冒泡操作的时间复杂度为 <code>O(log n)</code> （即最坏情况要遍历树的每一层，而树的高度为 <code>[log n]</code> ）</li></ul><p>下面的图示，展示了一个插入和向上冒泡的过程：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743927952888.png" alt="a 为原始堆，b 在堆尾部插入元素 (2,T)"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743928016199.png" alt="c 对新元素 (2,T) 进行冒泡，因为 2 &lt; 20 ，得到 d"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743928073600.png" alt="e 同理进行父子节点比较，向上冒泡，得到 f"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743928122435.png" alt="同样操作，直到冒泡到根节点/键值关系满足 Heap-Order 属性"></p><h4 id="2-2-2-删除和向下冒泡"><a href="#2-2-2-删除和向下冒泡" class="headerlink" title="2.2.2 删除和向下冒泡"></a>2.2.2 删除和向下冒泡</h4><p>因为 Heap-Order 属性保证了根节点即为 min ，所以优先级队列的 <code>remove_min()</code> 操作对应于在堆中删除根节点。</p><p>堆中元素的删除由三个步骤组成：</p><ul><li>将<strong>根节点用最后一个节点 w 代替</strong></li><li>移除最后一个节点 w</li><li>通过<strong>向下冒泡</strong>恢复堆的 Heap-Order属性</li></ul><p>用最后一个节点将根节点替代后，堆可能变得不满足 Heap-Order 性质：</p><ul><li>通过对新的根节点和其孩子节点的键值进行比较，并在必要时交换根节点和有较小键值的孩子节点的位置，不断重复即可恢复其 Heap-Order 性质，这种操作被称为<strong>堆向下冒泡 Down-Heap Bubbling</strong></li><li>堆向下冒泡操作在最后一个节点成为叶子节点或其键值小于其所有孩子节点键值时停止</li><li>堆向下冒泡操作的时间复杂度为 <code>O(log n)</code> （即最坏情况要遍历树的每一层，而树的高度为 <code>[log n]</code> ）</li></ul><p>下面的图示，展示了一个删除和向下冒泡的过程：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743928511145.png" alt="a 将最后节点 (13,W) 替换到根节点，并删除根节点 (4,C) ，得到 b 图"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743928578370.png" alt="c 父节点 13 大于子节点最小键值 5 ，故向下冒泡，得到 d"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743928664804.png" alt="类似地，重复冒泡过程"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743928679120.png" alt="继续冒泡，直到到达叶子节点/键值均小于子节点时，恢复 Heap-Order 性质"></p><blockquote><p>【注意】每次向下冒泡，都需要找 <strong>2 个子节点最小键值</strong> 进行交换。</p></blockquote><h3 id="2-3-基于数组的堆-完全二叉树表示"><a href="#2-3-基于数组的堆-完全二叉树表示" class="headerlink" title="2.3 基于数组的堆/完全二叉树表示"></a>2.3 基于数组的堆/完全二叉树表示</h3><p>基于数组实现树，对于完全二叉树十分适用。这是因为完全二叉树尽可能的用满了每一层的空间，且剩余的叶子节点都在左侧，这非常符合数组的结构。</p><p>那么假设一个基于数组 A 的完全二叉树 T 已经实现，则对于在 A 中索引为 p 的节点，则有：</p><ul><li>若 p 为根节点，则 <code>p = 0</code></li><li>若 q 为 p 的左子节点，则 <code>q = 2 * p + 1</code></li><li>若 q 为 p 的右子节点，则 <code>q = 2 * p + 2</code></li></ul><p>下面是一个堆/完全二叉树存储在数组里的例子：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743929197105.png" alt="堆/完全二叉树"></p><p>它存储在数组里为：</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743929444547.png" alt=""></p><h3 id="2-4-Python-实现堆"><a href="#2-4-Python-实现堆" class="headerlink" title="2.4 Python 实现堆"></a>2.4 Python 实现堆</h3><h4 id="2-4-1-Python-实现"><a href="#2-4-1-Python-实现" class="headerlink" title="2.4.1 Python 实现"></a>2.4.1 Python 实现</h4><p>基于堆的优先级队列的 Python 实现。我们使用基于数组的表示，保存了元组组合表示的 Python 列表。采用递归来实现 <code>_upheap</code> 和 <code>_downheap</code> 中的重复调用。继承之前的 <code>PriorityQueueBase</code> 基础类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapPriorityQueue</span>(<span class="title class_ inherited__">PriorityQueueBase</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    堆的实现：完全二叉树，根节点为 min</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- 非公有方法：二叉树结构 ----------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_parent</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回父节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (j - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_left</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;当前位置的左子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_right</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;当前位置的右子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * j + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_has_left</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;左子节点是否存在/合法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._left(j) &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_has_right</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;右子节点是否存在/合法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._right(j) &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_swap</span>(<span class="params">self, i, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;交换 i j 位置上的元素 &lt;=&gt; 冒泡&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._data[i], <span class="variable language_">self</span>._data[j] = <span class="variable language_">self</span>._data[j], <span class="variable language_">self</span>._data[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_upheap</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向上冒泡&quot;&quot;&quot;</span></span><br><span class="line">        parent = <span class="variable language_">self</span>._parent(j)  <span class="comment"># j 的父节点</span></span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="variable language_">self</span>._data[j] &lt; <span class="variable language_">self</span>._data[parent]:  <span class="comment"># 非根节点/不满足 Heap-Order</span></span><br><span class="line">            <span class="variable language_">self</span>._swap(j, parent)  <span class="comment"># 冒泡/交换</span></span><br><span class="line">            <span class="variable language_">self</span>._upheap(parent)  <span class="comment"># 递归实现，向上 (parent) 冒泡</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_downheap</span>(<span class="params">self, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向下冒泡&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 找到最小的子节点 small_child</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._has_left(j):  <span class="comment"># 左/非叶节点</span></span><br><span class="line">            left = <span class="variable language_">self</span>._left(j)</span><br><span class="line">            small_child = left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._has_right(j):  <span class="comment"># 右/非叶节点</span></span><br><span class="line">                right = <span class="variable language_">self</span>._right(j)</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._data[right] &lt; <span class="variable language_">self</span>._data[left]:</span><br><span class="line">                    small_child = right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 不满足 Heap-Order</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._data[small_child] &lt; <span class="variable language_">self</span>._data[j]:</span><br><span class="line">                <span class="variable language_">self</span>._swap(small_child, j)  <span class="comment"># 冒泡/交换</span></span><br><span class="line">                <span class="variable language_">self</span>._downheap(small_child)  <span class="comment"># 递归实现，向下 (small_child) 冒泡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- 公有方法：堆结构 ----------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;列表用来存储完全二叉树&quot;&quot;&quot;</span>  <span class="comment"># 可优化，见后</span></span><br><span class="line">        <span class="variable language_">self</span>._data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;重载 len()&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;增加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._data.append(<span class="variable language_">self</span>._Item(key, value))  <span class="comment"># 尾部新增</span></span><br><span class="line">        <span class="variable language_">self</span>._upheap(<span class="built_in">len</span>(<span class="variable language_">self</span>._data) - <span class="number">1</span>)  <span class="comment"># 从最后一个向上冒泡</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看 min 不删除&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Priority queue is empty&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        item = <span class="variable language_">self</span>._data[<span class="number">0</span>]  <span class="comment"># 由 Heap-Order 性质，第一个元素为 min</span></span><br><span class="line">        <span class="keyword">return</span> (item._key, item._value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除 min&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Empty(<span class="string">&#x27;Priority queue is empty&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._swap(<span class="number">0</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>._data) - <span class="number">1</span>)  <span class="comment"># 交换最后一个元素和根节点</span></span><br><span class="line">        item = <span class="variable language_">self</span>._data.pop()  <span class="comment"># 删除最后一个元素，即交换来的根节点/min</span></span><br><span class="line">        <span class="variable language_">self</span>._downheap(<span class="number">0</span>)  <span class="comment"># 从根/第一个开始向下冒泡</span></span><br><span class="line">        <span class="keyword">return</span> (item._key, item._value)</span><br></pre></td></tr></table></figure><h4 id="2-4-2-基于堆的优先级队列的算法分析"><a href="#2-4-2-基于堆的优先级队列的算法分析" class="headerlink" title="2.4.2 基于堆的优先级队列的算法分析"></a>2.4.2 基于堆的优先级队列的算法分析</h4><p>注意到，基于堆的优先级队列，在 <code>min()</code> 操作时，由于 Heap-Order 性质，可以在 <code>O(1)</code> 内完成。而在新增元素和删除/查看最小元素时，最坏的情况都是遍历每一层，而不是每一个节点，这使得对于 n 个节点完全二叉树/堆，其高度/层数仅 <code>log n</code> 级别，故复杂度也只有 <code>O(log n)</code> ，这明显是大大提高了效率。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743931198577.png" alt="算法复杂度分析"></p><p><strong>结论</strong>：堆数据结构都是优先级队列非常有效的实现方式。与基于未排序或已排序列表的实现不同，基于堆的实现在插人和移除操作中均能快速地获得运行结果。</p><h4 id="2-4-3-自底向上构建堆"><a href="#2-4-3-自底向上构建堆" class="headerlink" title="2.4.3 自底向上构建堆"></a>2.4.3 自底向上构建堆</h4><p>在初始化构建堆时，从一个空堆开始连续调用 n 次 <code>add()</code> 操作的时间复杂度为 <code>O(n log n)</code> （因为每次新增元素在最坏的情况下都是 <code>O(log n)</code> 级别的复杂度，调用 n 次则为 <code>O(n log n)</code> 这是不高效的）。</p><p><strong>自底向上构建堆</strong>可将此操作的时间复杂度降为 <code>O(n)</code> 。初始化的是非空的堆，堆中元素由 n 个。为了叙述简单，我们设：</p><script type="math/tex; mode=display">n = 2^{h+1} - 1</script><p>即这个初始的堆为一个满二叉树（即每一次都满了，每层 $2^i$ 个节点）。那么，自底向上构建堆进行如下操作：</p><ul><li>第 1 步，任意取 <code>(n + 1)/2</code> 个节点最为最底部的叶子节点；</li><li>第 2 步，再任意取 <code>(n + 1)/4</code> 个节点，作为最后 1 层的父节点，同时对倒数第 2 层每个节点进行一次<strong>向下冒泡</strong>，使得满足 Heap-Order 属性；</li><li>······</li><li>第 i 步，再任意取 <code>(n+1)/2^i</code> 个节点，作为倒数第 i+1 层的父节点，同时对本层（倒数第 i 层）每个节点进行向下冒泡，使得满足 Heap-Order 属性；</li><li>······</li><li>第 h + 1 = log(n + 1) 步，按照同样的方式，此次创建的是根节点，仍然进行最后 1 次向下冒泡，最终得到初始堆。</li></ul><p>例如：如下图，15 = 2^4 - 1 个节点的堆，任意取 8 个元素构成最底部的节点；然后任意取 4 个构成倒数第二层节点，进行向下冒泡，使得满足 Heap-Order 性质；如此重复得到初始化后的堆。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743933519764.png" alt="15 个节点的堆"></p><p><strong>Python 实现</strong>：修改之前的 <code>HeapPriorityQueue</code> 的 <code>__init__()</code> 方法，使得可以根据 <code>contents</code> 序列类快速初始化，复杂度为 <code>O(n)</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapPriorityQueue</span>(<span class="title class_ inherited__">PriorityQueueBase</span>):</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment"># ---------- 公有方法：堆结构 ----------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, contents=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;列表用来存储完全二叉树，可根据 contents 自底向上初始化&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(contents[<span class="number">0</span>], <span class="built_in">tuple</span>): <span class="comment"># 若 contents 元素不是元组</span></span><br><span class="line">            <span class="comment"># 则键值对存储 (e, e) for e in contents</span></span><br><span class="line">            <span class="variable language_">self</span>._data = [<span class="variable language_">self</span>._Item(e, e) <span class="keyword">for</span> e <span class="keyword">in</span> contents]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 为元组就可以正常按照 (k, v) 存储</span></span><br><span class="line">            <span class="variable language_">self</span>._data = [<span class="variable language_">self</span>._Item(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> contents]  </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._data) &gt; <span class="number">1</span>:  <span class="comment"># 确实需要初始化，若为空或只有 1 个则不需要冒泡</span></span><br><span class="line">            <span class="variable language_">self</span>._heapify()  <span class="comment"># 自底向上，逐个冒泡，使得满足 Heap-Order</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_heapify</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从底向上初始化堆的冒泡过程&quot;&quot;&quot;</span></span><br><span class="line">        start = <span class="variable language_">self</span>._parent(<span class="built_in">len</span>(<span class="variable language_">self</span>) - <span class="number">1</span>)  <span class="comment"># 从最后一个节点的父节点开始向下冒泡</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 从后向前，一直到根节点</span></span><br><span class="line">            <span class="variable language_">self</span>._downheap(j)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如此可以一开始指定初始化的堆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># a example</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Heap Priority Queue by Array&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    l = [(<span class="number">1</span>, <span class="string">&#x27;small&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;median&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;large&#x27;</span>)]</span><br><span class="line">    hpq = HeapPriorityQueue(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The min is:&quot;</span>, hpq.<span class="built_in">min</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Delete the min:&quot;</span>, hpq.remove_min())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now, the min is:&quot;</span>, hpq.<span class="built_in">min</span>())</span><br><span class="line">    </span><br><span class="line"><span class="comment"># =============== Heap Priority Queue by Array ===============</span></span><br><span class="line"><span class="comment"># The min is: (1, &#x27;small&#x27;)</span></span><br><span class="line"><span class="comment"># Delete the min: (1, &#x27;small&#x27;)</span></span><br><span class="line"><span class="comment"># Now, the min is: (2, &#x27;median&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>时间复杂度为 <code>O(n)</code> 的证明：</strong></p><p>在最坏的情况下，如何进行冒泡，即冒泡的路径，并不影响复杂度。所以我们不妨假设每个节点处的堆向下泡冒路径均先向右走，然后一直向左走，直到堆底部。</p><p>每个节点最多被两条路径经过，因此所有路径经过的边数总和为 <code>O(n)</code> 。因此，自底向上构建堆的时间为 <code>O(n)</code> 。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743934486425.png" alt="可视化证明图示"></p><h4 id="2-4-4-heapq-模块"><a href="#2-4-4-heapq-模块" class="headerlink" title="2.4.4 heapq 模块"></a>2.4.4 heapq 模块</h4><p>Python 的标准分布包含一个 <code>heapq</code> 模块，该模块提供对基于堆的优先级队列的支持。该模块不提供任何优先级队列类，而是提供一些函数，<strong>这些函数把标准 Python 列表作为堆进行管理</strong>。</p><p><strong>heapq</strong> 的一些常见函数，针对列表类 L 操作（假设 L <strong>已经满足</strong> Heap-Order 属性）：</p><ul><li><p><code>heappush(L, e)</code>：将元素 e 存入列表 L ，并重新调整列表以满足 heap-order 属性。该函数执行的时间复杂度为 <code>O(log n)</code> 。</p></li><li><p><code>heappop(L)</code> ：取出并返回列表 L 中拥有最小值的元素，并且重新调整存储以满足 heap-order 属性。该函数执行的时间复杂度为 <code>O(log n)</code> 。</p></li><li><p><code>heappushpop(L, e)</code> ：将元素 e 存人列表 L 中，同时取出和返回最小的元组。该函数执行的时间复杂度为 <code>O(log n)</code> ，但是它较分别调用 push 和 pop 方法的效率稍微高一些。因为如果最新被插入列表的元素值是最小的，那么该函数立刻返回；否则，即为常见的 push + pop 操作。</p></li><li><p><code>heapreplace(L, e)</code> ：与 heappushpop 方法类似。</p></li></ul><p><strong>heapq</strong> 的一些常见函数，针对列表类 L 操作（假设 L <strong>不满足</strong> Heap-Order 属性）：</p><ul><li><code>heapify(L)</code> ：改变未排序的列表，使其满足 heap-order 属性。这个函数使用自底向上的堆构造算法，时间复杂度为 <code>O(n)</code> 。</li><li><code>nlargest(k, iterable)</code>：从一个给定的迭代 <code>iterable</code> 中生成含有 k 个最大值的列表。执行该函数的时间复杂度为 <code>O(n + k log n)</code> 。</li><li><code>nsmallest(k, iterable)</code> ：从一个给定的选代 <code>iterable</code> 中生成含有 k 个最小值的列表。该函数使用与 nlargest 相同的技术，其时间复杂度为 <code>O(n + k log n)</code> 。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">L = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>]  <span class="comment"># 不满足 Heap-Order</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 自底向上构建堆</span></span><br><span class="line">heapq.heapify(L)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7, 10, 9, 8]</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2 3</span></span><br><span class="line"><span class="string">4 5 6 7</span></span><br><span class="line"><span class="string">10 9 8</span></span><br><span class="line"><span class="string">满足 Heap-Order</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 返回最大最小的 2 个</span></span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">2</span>, L))</span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">2</span>, L))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[10, 9]</span></span><br><span class="line"><span class="string">[1, 2]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 去除最小</span></span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(L))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[2, 4, 3, 8, 5, 6, 7, 10, 9]</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">4 3</span></span><br><span class="line"><span class="string">8 5 6 7</span></span><br><span class="line"><span class="string">10 9</span></span><br><span class="line"><span class="string">满足 Heap-Order</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3 排序"></a>3 排序</h2><h3 id="3-1-使用优先级队列进行排序"><a href="#3-1-使用优先级队列进行排序" class="headerlink" title="3.1 使用优先级队列进行排序"></a>3.1 使用优先级队列进行排序</h3><p>我们可以使用优先级队列对一个可比较元素集合进行排序：</p><ul><li>首先使用 <code>add</code> 操作将集合中的元素一个接一个地插入到优先级队列中</li><li>再使用 <code>remove_min</code> 操作将元素以某种顺序从优先级队列中移出</li></ul><p>此算法的运行时间取决于优先级队列的具体实现方式。</p><p>通用伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pq_sort</span>(<span class="params">C, pq</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;伪代码：对 C 排序，借用 pq 优先级队列类&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line">    P = pq()  <span class="comment"># 辅助优先级队列</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        element = C.delete(C.first())  <span class="comment"># 拿出 C 的元素</span></span><br><span class="line">        P.add(element, element)  <span class="comment"># 存储 (e, e)</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        (k, v) = P.remove_min()  <span class="comment"># 取出最小的 e</span></span><br><span class="line">        C.add_last(v)  <span class="comment"># 放回原来的 C</span></span><br></pre></td></tr></table></figure><h3 id="3-2-选择排序和插入排序"><a href="#3-2-选择排序和插入排序" class="headerlink" title="3.2 选择排序和插入排序"></a>3.2 选择排序和插入排序</h3><h4 id="3-2-1-选择排序"><a href="#3-2-1-选择排序" class="headerlink" title="3.2.1 选择排序"></a>3.2.1 选择排序</h4><p>当使用<strong>未排序列表</strong>实现优先级队列时，PQ-sort 即为<strong>选择排序</strong>。</p><p><strong>选择排序的复杂度：<code>O(n^2)</code></strong></p><ul><li>将所有元素使用 <code>add</code> 操作插入优先级队列需要 n 次操作，运行时间为 <code>O(n)</code> 。</li><li>将元素按顺序移出长为 n 的优先级队列需要每次使用 <code>remove_min</code> 操作选择优先级最高的元素，其运行时间正比于：</li></ul><script type="math/tex; mode=display">n + (n-1) + (n-2) + \cdots + 1 = O(n^2)</script><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743941045902.png" alt="选择排序示例" style="zoom:50%;" /></p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> UnsortedPriorityQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">C</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line">    P = UnsortedPriorityQueue()  <span class="comment"># 见之前定义的 UnsortedPriorityQueue 类</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        element = C.pop()</span><br><span class="line">        P.add(element, element)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        (k, v) = P.remove_min()</span><br><span class="line">        C.append(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Selection Sort&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    l = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Initial list:&quot;</span>, l)</span><br><span class="line">    selection_sort(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort:&quot;</span>, l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== Selection Sort ===============</span></span><br><span class="line"><span class="comment"># Initial list: [7, 4, 8, 2, 5, 3]</span></span><br><span class="line"><span class="comment"># After sort: [2, 3, 4, 5, 7, 8]</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-插入排序"><a href="#3-2-2-插入排序" class="headerlink" title="3.2.2 插入排序"></a>3.2.2 插入排序</h4><p>当使用<strong>排序列表</strong>实现优先级队列时，PQ-sort 即为<strong>插入排序</strong>。</p><p><strong>插入排序的复杂度：<code>O(n^2)</code></strong></p><ul><li>将所有元素使用 <code>add</code> 操作插入优先级队列的运行时间正比于：</li></ul><script type="math/tex; mode=display">1 + 2 +3 + \cdots + n = O(n^2)</script><ul><li>将排好序的元素使用 <code>remove_min</code> 操作从优先级队列中移出需要 n 次操作，运行时间为 <code>O(n)</code></li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743941482500.png" alt="插入排序示例" style="zoom:50%;" /></p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> UnsortedPriorityQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">C</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line">    P = SortedPriorityQueue()  <span class="comment"># 见之前定义的 UnsortedPriorityQueue 类</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        element = C.pop()</span><br><span class="line">        P.add(element, element)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        (k, v) = P.remove_min()</span><br><span class="line">        C.append(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Insertion Sort&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    l = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Initial list:&quot;</span>, l)</span><br><span class="line">    insertion_sort(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort:&quot;</span>, l)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># =============== Insertion Sort ===============</span></span><br><span class="line"><span class="comment"># Initial list: [7, 4, 8, 2, 5, 3]</span></span><br><span class="line"><span class="comment"># After sort: [2, 3, 4, 5, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="3-3-堆排序"><a href="#3-3-堆排序" class="headerlink" title="3.3 堆排序"></a>3.3 堆排序</h3><p>正如前面所说，使用优先级队列进行排序，其效率完全取决于优先级队列的实现方式；更具体一点，效率取决于优先级序列 <code>add</code> 和 <code>remove_min</code> 操作的复杂度。而对于堆，其插入和删除的复杂度均为 <code>O(log n)</code> 相对于 <code>O(n)</code> 复杂度高效的多。</p><ul><li>add 阶段：由于第 i 次 add 操作完成后堆有 i 个元组，所以第 i 次 add操作的时间复杂度 <code>O(log i)</code> 。因此，这一阶段整体的时间复杂度 <code>O(n log n)</code> ，但通过<strong>自底向上的构建堆</strong>，时间复杂度能够被提升到 <code>O(n)</code> 。</li><li>remove_min 阶段：第 j 次 remove_min 操作执行时堆中有 <code>(n - j + 1)</code> 个元组，因此第 j 次 remove_min 操作的时间复杂度为 <code>O(log (n - j + 1))</code> 。将所有这些 remove_min 操作累加起来，这一阶段的时间复杂度 <code>O(n log n)</code> 。</li></ul><p><strong>结论：当使用堆来实现优先级队列时，整个优先级队列排序算法的时间复杂度为 <code>O(n log n)</code> 。这个排序算法就称为堆排序。</strong></p><h4 id="3-3-1-简单实现堆排序"><a href="#3-3-1-简单实现堆排序" class="headerlink" title="3.3.1 简单实现堆排序"></a>3.3.1 简单实现堆排序</h4><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utiles <span class="keyword">import</span> HeapPriorityQueue</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">C</span>):</span><br><span class="line">    <span class="comment"># 特别地，利用了自底向上构建堆的初始化方法 O(n)</span></span><br><span class="line">    P = HeapPriorityQueue(C)  <span class="comment"># 见之前定义的 HeapPriorityQueue 类</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(C)):  <span class="comment"># O(n log n)</span></span><br><span class="line">        C[j] = P.remove_min()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;Heap Sort&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    l = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Initial list:&quot;</span>, l)</span><br><span class="line">    heap_sort(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort:&quot;</span>, l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== Heap Sort ===============</span></span><br><span class="line"><span class="comment"># Initial list: [7, 4, 8, 2, 5, 3]</span></span><br><span class="line"><span class="comment"># After sort: [2, 3, 4, 5, 7, 8]</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-原地堆排序"><a href="#3-3-2-原地堆排序" class="headerlink" title="3.3.2 原地堆排序"></a>3.3.2 原地堆排序</h4><p>更进一步，如果需要排序的对象也是用数组存储的，例如上面的例子。则可以原地进行堆排序，如此可以节省空间，也节省了申请一个新空间和摊销的时间成本：</p><ul><li>重新定义堆的操作，使其成为最大堆（maximum-oriented heap）（并不重要，仅仅影响是升序还是降序），即父节点键值不小于孩子节点；算法执行过程中，始终使用<strong>列表的左半部分表示堆，右半部分表示序列</strong>。</li><li>add 阶段：我们从一个空堆开始，从左向右移动堆与序列之间的边界，一次一步；每一步将序列中的下一个元素追加到堆中。</li><li>remove_add 阶段：我们从一个空的序列开始，从右向左移动堆与序列之间的边界，一次一步；每一步将最大值元素从堆中移除并存储到当前序列的最前方。</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743944140925.png" alt="原地堆排序图示" style="zoom: 45%;" /></p><p><strong>代码实现</strong>：同时实现了升序和降序，只需指定 <code>descend=False</code> 则为升序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapsort</span>(<span class="params">arr, descend=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;原地堆排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">downheap</span>(<span class="params">start, end</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从 start 开始向下冒泡，堆的范围是 [0, end)&quot;&quot;&quot;</span></span><br><span class="line">        parent = start</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        left = <span class="number">2</span> * parent + <span class="number">1</span></span><br><span class="line">        right = <span class="number">2</span> * parent + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> descend:</span><br><span class="line">            <span class="comment"># 从小到大，堆的根节点为 max</span></span><br><span class="line">            largest_child = parent</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt; end <span class="keyword">and</span> arr[left] &gt; arr[largest_child]:</span><br><span class="line">                largest_child = left</span><br><span class="line">            <span class="keyword">if</span> right &lt; end <span class="keyword">and</span> arr[right] &gt; arr[largest_child]:</span><br><span class="line">                largest_child = right</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> largest_child == parent:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 如果父节点已经是最大的，停止</span></span><br><span class="line"></span><br><span class="line">            arr[parent], arr[largest_child] = arr[largest_child], arr[parent]</span><br><span class="line">            downheap(largest_child, end)  <span class="comment"># 继续向下冒泡</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 从大到小，堆的根节点为 min</span></span><br><span class="line">            smallest_child = parent</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt; end <span class="keyword">and</span> arr[left] &lt; arr[smallest_child]:</span><br><span class="line">                smallest_child = left</span><br><span class="line">            <span class="keyword">if</span> right &lt; end <span class="keyword">and</span> arr[right] &lt; arr[smallest_child]:</span><br><span class="line">                smallest_child = right</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> smallest_child == parent:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 如果父节点已经是最小的，停止</span></span><br><span class="line"></span><br><span class="line">            arr[parent], arr[smallest_child] = arr[smallest_child], arr[parent]</span><br><span class="line">            downheap(smallest_child, end)  <span class="comment"># 继续向下冒泡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 构建最大堆（从最后一个非叶子节点开始）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n // <span class="number">2</span>) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># &lt;=&gt; 整个序列为一个暂未满足 heap-order 的堆，进行冒泡调整</span></span><br><span class="line">        downheap(i, n)  <span class="comment"># 自底向上的构建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 排序阶段：每次将堆顶（最大值）交换到末尾，并向下冒泡</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]  <span class="comment"># 交换堆顶和当前末尾</span></span><br><span class="line">        downheap(<span class="number">0</span>, i)  <span class="comment"># 向下冒泡</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">15</span>, <span class="string">&quot;The Best! - In-place Heap Sort&quot;</span>, <span class="string">&quot;=&quot;</span> * <span class="number">15</span>)</span><br><span class="line">    l = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Initial list:&quot;</span>, l)</span><br><span class="line"></span><br><span class="line">    heapsort(l, descend=<span class="literal">False</span>)  <span class="comment"># 从小到大</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sort not descend:&quot;</span>, l)</span><br><span class="line"></span><br><span class="line">    heapsort(l, descend=<span class="literal">True</span>)  <span class="comment"># 从大到小</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sort descend:&quot;</span>, l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =============== The Best! - In-place Heap Sort ===============</span></span><br><span class="line"><span class="comment"># Initial list: [7, 4, 8, 2, 5, 3]</span></span><br><span class="line"><span class="comment"># sort not descend: [2, 3, 4, 5, 7, 8]</span></span><br><span class="line"><span class="comment"># sort descend: [8, 7, 5, 4, 3, 2]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">优先级队列、基于堆实现的优先级队列、一些常用的排序算法（选择排序、插入排序）、高级排序算法——堆排序）。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>统计软件 R 语言学习笔记 (7) 统计量</title>
    <link href="https://blog.iskage.online/posts/46a852b4.html"/>
    <id>https://blog.iskage.online/posts/46a852b4.html</id>
    <published>2025-04-04T01:44:00.000Z</published>
    <updated>2025-04-17T08:09:46.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述统计：统计量"><a href="#描述统计：统计量" class="headerlink" title="描述统计：统计量"></a>描述统计：统计量</h1><p>在描述行统计中，除了统计图表，统计量可以定量的描述数据。本章介绍常见的统计量：均值、方差、标准差、中位数、四分位数、变异系数、IQR、极差、偏度、峰度、Q-Q 图。以及分类汇总函数 aggregate 。</p><p>代码和笔记存储在 <a href="https://github.com/iskage/r-notes">GitHub 库</a> <strong>【持续更新中，建议 star！】</strong></p><h2 id="1-描述统计：统计量"><a href="#1-描述统计：统计量" class="headerlink" title="1 描述统计：统计量"></a>1 描述统计：统计量</h2><p><strong>定性变量</strong>：频数、比例</p><p><strong>定量变量</strong>：集中信息、波动信息、形状信息</p><h3 id="1-1-集中信息"><a href="#1-1-集中信息" class="headerlink" title="1.1 集中信息"></a>1.1 集中信息</h3><h4 id="1-1-1-样本均值"><a href="#1-1-1-样本均值" class="headerlink" title="1.1.1 样本均值"></a>1.1.1 样本均值</h4><p>对于数据 $x_1,\ x_2,\ \cdots,\ x_n$ 的<strong>样本均值</strong>为：</p><script type="math/tex; mode=display">\bar{x} = \frac{x_1 + x_2 + \cdots + x_n}{n} = \frac{1}{n}\sum\limits_{i = 1}^n\ x_i</script><p>缺点：均值容易受到极端值影响。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="1-1-2-中位数"><a href="#1-1-2-中位数" class="headerlink" title="1.1.2 中位数"></a>1.1.2 中位数</h4><p><strong>样本中位数</strong>是对原始数据排序，位于数据中心的数据。</p><script type="math/tex; mode=display">x_{MED} = x_{(\frac{n+1}{2})}\quad or\quad (x_{(\frac{n}{2})} + x_{(\frac{n}{2} + 1)})/2</script><p>假设有定量数据 $x<em>1,\ x_2,\ \cdots,\ x_n$ ，定义排序后的数据 $x</em>{(1)} \leq x<em>{(2)} \leq \cdots \leq x</em>{(n)}$ 。</p><p>优点：稳健，不容易受到极端值影响。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-示例"><a href="#1-1-3-示例" class="headerlink" title="1.1.3 示例"></a>1.1.3 示例</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">finalgrades <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;finalgrades.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line">mydata <span class="operator">&lt;-</span> finalgrades<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">6</span><span class="operator">:</span><span class="number">9</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 均值</span></span><br><span class="line">grade.mean <span class="operator">&lt;-</span> apply<span class="punctuation">(</span>mydata<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> mean<span class="punctuation">)</span></span><br><span class="line">grade.mean</span><br><span class="line"><span class="comment">#     政治     语文     数学     物理 </span></span><br><span class="line"><span class="comment"># 50.31056 81.64907 41.29503 24.76708 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 中位数</span></span><br><span class="line">grade.median <span class="operator">&lt;-</span> apply<span class="punctuation">(</span>mydata<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> median<span class="punctuation">)</span></span><br><span class="line">grade.median</span><br><span class="line"><span class="comment"># 政治 语文 数学 物理 </span></span><br><span class="line"><span class="comment">#   51   84   40   24 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 左偏/右偏</span></span><br><span class="line">grade.mean <span class="operator">&gt;</span> grade.median</span><br><span class="line"><span class="comment">#  政治  语文  数学  物理 </span></span><br><span class="line"><span class="comment"># FALSE FALSE  TRUE  TRUE </span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/grades.png" alt=""></p><h3 id="1-2-波动信息"><a href="#1-2-波动信息" class="headerlink" title="1.2 波动信息"></a>1.2 波动信息</h3><h4 id="1-2-1-方差-标准差"><a href="#1-2-1-方差-标准差" class="headerlink" title="1.2.1 方差/标准差"></a>1.2.1 方差/标准差</h4><p><strong>样本方差</strong>：反映了所有数据离中心的平均的平方距离</p><script type="math/tex; mode=display">s^2 = \frac{1}{n-1}\sum\limits_{i=1}^n\ (x_i - \bar{x})^2</script><p><strong>样本标准差</strong>：近似反映了所有数据离中心的平均距离</p><script type="math/tex; mode=display">s = \sqrt{s^2} = \sqrt{\frac{1}{n-1}\sum\limits_{i=1}^n\ (x_i - \bar{x})^2}</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sd<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-变异系数"><a href="#1-2-2-变异系数" class="headerlink" title="1.2.2 变异系数"></a>1.2.2 变异系数</h4><p><strong>变异系数 Coefficient of Variation</strong> ($CV$) ：比较不同单位的数据的离散程度；比较单位相同而平均数相差较大的数据组资料的差异程度。</p><script type="math/tex; mode=display">CV = \frac{s}{\bar{x}} \times 100</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> <span class="operator">*</span> sd<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">/</span> mean<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-四分位间距-极差"><a href="#1-2-3-四分位间距-极差" class="headerlink" title="1.2.3 四分位间距/极差"></a>1.2.3 四分位间距/极差</h4><p><strong>四分位差</strong> (Inter - Quartile Range, $IQR$) ：中间 $50\%$ 数据的范围。</p><script type="math/tex; mode=display">IQP = Q_3 - Q_1</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IQR<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><strong>极差</strong> ：所有数据的范围</p><script type="math/tex; mode=display">range = x_{(n)} - x_{(1)}</script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="1-3-形状信息"><a href="#1-3-形状信息" class="headerlink" title="1.3 形状信息"></a>1.3 形状信息</h3><h4 id="1-3-1-偏度"><a href="#1-3-1-偏度" class="headerlink" title="1.3.1 偏度"></a>1.3.1 偏度</h4><p><strong>总体偏度</strong>的定义</p><script type="math/tex; mode=display">Skewness = E\ (\frac{X - \mu}{\sigma})^3</script><p><strong>样本偏度</strong>的定义</p><script type="math/tex; mode=display">g_1 = \frac{n}{(n-1)(n-2)\cdot s^3} \sum\limits_{i=1}^n\ (x_i - \bar{x})^3</script><p>偏度判断：</p><ul><li>对称：Skewness = 0</li><li>右偏：Skewness &gt; 0</li><li>左偏：Skewness &lt; 0</li></ul><h4 id="1-3-2-峰度"><a href="#1-3-2-峰度" class="headerlink" title="1.3.2 峰度"></a>1.3.2 峰度</h4><p><strong>峰度</strong>反应了峰部的尖度，总体峰度的定义：</p><script type="math/tex; mode=display">Kurtosis = E\ (\frac{X - \mu}{\sigma})^4 - 3</script><p><strong>样本峰度</strong>：</p><script type="math/tex; mode=display">g_2 = \frac{n(n+1)}{(n-1)(n-2)(n-3)\cdot s^4}\sum\limits_{i=1}^n\ (x_i - \bar{x})^4 - 3\cdot \frac{(n-1)^2}{(n-2)(n-3)}</script><p>峰度判断：</p><ul><li>正态分布：Kurtosis = 0</li><li><p>峰度越大，高峰分布：两端数据多（厚尾），中间数据少，且集中在均值附近。</p></li><li><p>Kurtosis &gt; 0 ，与正态分布相比是高峰</p></li></ul><h4 id="1-3-3-R-语言实现"><a href="#1-3-3-R-语言实现" class="headerlink" title="1.3.3 R 语言实现"></a>1.3.3 R 语言实现</h4><p>调用 <code>moments</code> 包：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;moments&quot;</span><span class="punctuation">)</span></span><br><span class="line">grade.skewness <span class="operator">&lt;-</span> apply<span class="punctuation">(</span>mydata<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> skewness<span class="punctuation">)</span></span><br><span class="line">grade.kurtosis <span class="operator">&lt;-</span> apply<span class="punctuation">(</span>mydata<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> kurtosis<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">grade.skewness</span><br><span class="line"><span class="comment">#       政治       语文       数学       物理 </span></span><br><span class="line"><span class="comment"># -0.3105433 -0.6525492  0.5757198  0.5463615 </span></span><br><span class="line"></span><br><span class="line">grade.kurtosis  <span class="comment"># 没有减 3</span></span><br><span class="line"><span class="comment">#     政治     语文     数学     物理 </span></span><br><span class="line"><span class="comment"># 2.832892 3.416347 3.539414 3.308497 </span></span><br><span class="line"></span><br><span class="line">grade.kurtosis <span class="operator">&lt;-</span> apply<span class="punctuation">(</span>mydata<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> kurtosis<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">3</span></span><br><span class="line">grade.kurtosis</span><br><span class="line"><span class="comment">#       政治       语文       数学       物理 </span></span><br><span class="line"><span class="comment"># -0.1671077  0.4163471  0.5394144  0.3084971 </span></span><br></pre></td></tr></table></figure><blockquote><p>【注意】：R 语言的 <code>kurtosis()</code> 函数没有进行 <code>- 3</code> 操作。</p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kurtosis<span class="punctuation">(</span>rnorm<span class="punctuation">(</span><span class="number">10000</span><span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment"># 没有减 3</span></span><br><span class="line"><span class="comment"># [1] 2.999622</span></span><br></pre></td></tr></table></figure><h4 id="1-3-4-Q-Q-图"><a href="#1-3-4-Q-Q-图" class="headerlink" title="1.3.4 Q-Q 图"></a>1.3.4 Q-Q 图</h4><p><strong>Q-Q Plot</strong> ：对于观测数据 $x<em>1,\ x_2,\ \cdots,\ x_n$ 对其排序后得到 $x</em>{(1)} \leq x<em>{(2)} \leq \cdots \leq x</em>{(n)}$ ，它们的概率为：</p><script type="math/tex; mode=display">P(X \leq x_{(j)}) = \frac{j}{n} \approx \frac{j - 0.375}{n + 0.25}</script><p>然后取出标准正态分布的分位数点 $F^{-1}(\frac{j - 0.375}{n + 0.25})$ 。绘制散点图：</p><script type="math/tex; mode=display">(F^{-1}(\frac{j - 0.375}{n + 0.25}),\ x_{(j)})</script><p>若大致为线性关系/直线，则可以认为 $x_i$ 满足近似正态。</p><p><strong>R 语言实现</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> mydata<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">qqnorm<span class="punctuation">(</span>x<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Q-Q Plot&quot;</span><span class="punctuation">)</span></span><br><span class="line">qqline<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/qq.png" style="zoom:25%;" /></p><p>对于非正态的 Q-Q 图，有如下的例子：左边为右偏，右边为左偏</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743665372563.png" alt=""></p><h3 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fivenum<span class="punctuation">(</span>x<span class="punctuation">)</span>  <span class="comment"># 5 个分位数 min, q1, median, q3, max</span></span><br><span class="line">summary<span class="punctuation">(</span>x<span class="punctuation">)</span>  <span class="comment"># 5 个分位数 + mean</span></span><br><span class="line">quantile<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="comment"># 5 个分位数 0%  25%  50%  75% 100%</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> fivenum<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">14</span> <span class="number">42</span> <span class="number">51</span> <span class="number">59</span> <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">   Min. <span class="number">1</span>st Qu.  Median    Mean <span class="number">3</span>rd Qu.    Max. </span><br><span class="line">  <span class="number">14.00</span>   <span class="number">42.00</span>   <span class="number">51.00</span>   <span class="number">50.31</span>   <span class="number">59.00</span>   <span class="number">79.00</span> </span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> quantile<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">  <span class="number">0</span><span class="operator">%  25%</span>  <span class="number">50</span><span class="operator">%  75%</span> <span class="number">100</span>% </span><br><span class="line">  <span class="number">14</span>   <span class="number">42</span>   <span class="number">51</span>   <span class="number">59</span>   <span class="number">79</span> </span><br></pre></td></tr></table></figure><h2 id="2-描述统计：分类汇总"><a href="#2-描述统计：分类汇总" class="headerlink" title="2 描述统计：分类汇总"></a>2 描述统计：分类汇总</h2><h3 id="2-1-aggregate-函数"><a href="#2-1-aggregate-函数" class="headerlink" title="2.1 aggregate 函数"></a>2.1 aggregate 函数</h3><p><strong>格式</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aggregate<span class="punctuation">(</span>x <span class="operator">~</span> by<span class="punctuation">,</span> FUN<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> data<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x<span class="operator">:</span> 列名，或是列序号，多个使用 cbind<span class="punctuation">(</span><span class="punctuation">)</span> 组合</span><br><span class="line">by<span class="operator">:</span> 分类依据的列名，多个使用 <span class="operator">+</span> 组合</span><br><span class="line">FUN<span class="operator">:</span> 表示整合的方式，传入函数</span><br><span class="line">na.rm<span class="operator">:</span> 如果为 <span class="literal">NA</span> 则直接删去行数据</span><br><span class="line">data<span class="operator">:</span> 操作的数据框</span><br></pre></td></tr></table></figure><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>例：按照 <code>city</code> 和 <code>R</code> 计算 <code>minimumpay, maximumpay, logmeanpay</code> 列的均值</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydata <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;jobinfor201xE.csv&quot;</span><span class="punctuation">,</span> encoding <span class="operator">=</span> <span class="string">&quot;utf-8&quot;</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>mydata<span class="punctuation">)</span></span><br><span class="line">str<span class="punctuation">(</span>mydata<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">aggregate<span class="punctuation">(</span>cbind<span class="punctuation">(</span>minimumpay<span class="punctuation">,</span> maximumpay<span class="punctuation">,</span> logmeanpay<span class="punctuation">)</span> <span class="operator">~</span> city <span class="operator">+</span> R<span class="punctuation">,</span> FUN <span class="operator">=</span> mean<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> data <span class="operator">=</span> mydata<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   city R minimumpay maximumpay logmeanpay</span><br><span class="line"><span class="number">1</span>  北京 <span class="number">0</span>   <span class="number">8245.586</span>  <span class="number">12548.425</span>   <span class="number">9.035330</span></span><br><span class="line"><span class="number">2</span>  河北 <span class="number">0</span>   <span class="number">4536.095</span>   <span class="number">6748.496</span>   <span class="number">8.521607</span></span><br><span class="line"><span class="number">3</span>  山西 <span class="number">0</span>   <span class="number">6045.913</span>   <span class="number">8798.888</span>   <span class="number">8.678785</span></span><br><span class="line"><span class="number">4</span>  陕西 <span class="number">0</span>   <span class="number">5225.994</span>   <span class="number">7964.530</span>   <span class="number">8.610160</span></span><br><span class="line"><span class="number">5</span>  上海 <span class="number">0</span>   <span class="number">7733.406</span>  <span class="number">11325.135</span>   <span class="number">9.018670</span></span><br><span class="line"><span class="number">6</span>  深圳 <span class="number">0</span>   <span class="number">7430.474</span>  <span class="number">11419.152</span>   <span class="number">9.001751</span></span><br><span class="line"><span class="number">7</span>  北京 <span class="number">1</span>   <span class="number">9533.537</span>  <span class="number">14261.561</span>   <span class="number">9.245172</span></span><br><span class="line"><span class="number">8</span>  河北 <span class="number">1</span>   <span class="number">4500.000</span>   <span class="number">5999.000</span>   <span class="number">8.565888</span></span><br><span class="line"><span class="number">9</span>  山西 <span class="number">1</span>   <span class="number">3500.000</span>   <span class="number">5499.500</span>   <span class="number">8.301702</span></span><br><span class="line"><span class="number">10</span> 陕西 <span class="number">1</span>   <span class="number">8318.182</span>  <span class="number">11226.455</span>   <span class="number">9.007055</span></span><br><span class="line"><span class="number">11</span> 上海 <span class="number">1</span>  <span class="number">10665.874</span>  <span class="number">16020.449</span>   <span class="number">9.388033</span></span><br><span class="line"><span class="number">12</span> 深圳 <span class="number">1</span>  <span class="number">10682.540</span>  <span class="number">16854.706</span>   <span class="number">9.418756</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在描述行统计中，除了统计图表，统计量可以定量的描述数据。本章介绍常见的统计量：均值、方差、标准差、中位数、四分位数、变异系数、IQR、极差、偏度、峰度、Q-Q 图。以及分类汇总函数 aggregate 。</summary>
    
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/categories/R-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/tags/R-%E8%AF%AD%E8%A8%80/"/>
    
    <category term="统计软件" scheme="https://blog.iskage.online/tags/%E7%BB%9F%E8%AE%A1%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="R programming" scheme="https://blog.iskage.online/tags/R-programming/"/>
    
  </entry>
  
  <entry>
    <title>树的遍历算法</title>
    <link href="https://blog.iskage.online/posts/cb9a2247.html"/>
    <id>https://blog.iskage.online/posts/cb9a2247.html</id>
    <published>2025-04-03T07:16:00.000Z</published>
    <updated>2025-04-10T15:13:06.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的遍历算法"><a href="#树的遍历算法" class="headerlink" title="树的遍历算法"></a>树的遍历算法</h1><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。【建议 star !】</p><hr><p><strong>树的遍历</strong>常见方案：前序遍历 (preorder traversal) ，后序遍历 (postorder traversal) ，二叉树的中序遍历 (inorder traversal) ，层序遍历/广度优先遍历 (level order traversal/breadth-first traversal) 。</p><h2 id="1-树的遍历算法"><a href="#1-树的遍历算法" class="headerlink" title="1 树的遍历算法"></a>1 树的遍历算法</h2><p>树的遍历（traversal）：按某种规则不重复地访问树的所有节点</p><ul><li>前序遍历（preorder traversal）：先访问根，再递归访问子树。如树有序，则按顺序访问子树。</li><li>后序遍历（postorder traversal） ：先递归访问子树，再访问根。如树有序，则按顺序访问子树</li><li>二叉树的中序遍历（inorder traversal）：先递归访问左孩子，再访问根节点，再递归访问右孩子。</li><li>层序遍历/广度优先遍历（level order traversal/breadth-first traversal）：按层为顺序遍历，每一层从左到右遍历。</li></ul><p>以二叉树的遍历算法为例，可直观的理解为：设二叉树由根𝐷 、左子树𝐿和右子树𝑅构成</p><ul><li>前序遍历：<code>D -&gt; L -&gt; R</code></li><li>后序遍历：<code>L -&gt; R -&gt; D</code></li><li>中序遍历：<code>L -&gt; D -&gt; R</code></li><li>层序遍历：从低到高逐层，从左到右遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    D --&gt; L</span><br><span class="line">    D --&gt; R</span><br></pre></td></tr></table></figure><h3 id="1-1-深度优先"><a href="#1-1-深度优先" class="headerlink" title="1.1 深度优先"></a>1.1 深度优先</h3><h4 id="1-1-1-前序遍历"><a href="#1-1-1-前序遍历" class="headerlink" title="1.1.1 前序遍历"></a>1.1.1 前序遍历</h4><p>在树 T 的<strong>前序遍历</strong>中，首先访问 T 的根，然后递归地访问子树的根。如果这棵树是有序的，则根据孩子的顺序遍历子树。伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Algorithm preOrder(T, p):</span><br><span class="line">visit(p)</span><br><span class="line"><span class="keyword">for</span> each child c <span class="keyword">in</span> T.children(p) do</span><br><span class="line">preOrder(T, c)</span><br></pre></td></tr></table></figure><p>可以递归理解：对每一个节点，逐步进行如下操作</p><ol><li>访问根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><p>例如：在打印章节时，按照章节顺序打印</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743585357300.png" alt="前序遍历"></p><h4 id="1-1-2-后序遍历"><a href="#1-1-2-后序遍历" class="headerlink" title="1.1.2 后序遍历"></a>1.1.2 后序遍历</h4><p><strong>后序遍历</strong>可以看作相反的前序遍历，它优先遍历子树的根，即首先从孩子的根开始，然后访问根（因此叫作后序）。伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Algorithm postOrder(T, p):</span><br><span class="line"><span class="keyword">for</span> each child c <span class="keyword">in</span> T.children(p) do</span><br><span class="line">postOrder(T, c)</span><br><span class="line">visit(p)</span><br></pre></td></tr></table></figure><p>可以递归理解：对每一个节点，逐步进行如下操作</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ol><p>例如：反向打印章节</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743585587312.png" alt="后序遍历"></p><h4 id="1-1-3-二叉树的中序遍历"><a href="#1-1-3-二叉树的中序遍历" class="headerlink" title="1.1.3 二叉树的中序遍历"></a>1.1.3 二叉树的中序遍历</h4><p>在<strong>中序遍历</strong>中，我们通过递归遍历左右子树后再访问根节点。伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Algorithm inOrder(T, p):</span><br><span class="line"><span class="keyword">if</span> p has a left child lc then</span><br><span class="line">inOrder(T, lc)</span><br><span class="line">visit(p)</span><br><span class="line"><span class="keyword">if</span> p has a right child rc then</span><br><span class="line">inOrder(T, rc)</span><br></pre></td></tr></table></figure><p>可以递归理解：对每一个节点，逐步进行如下操作</p><ol><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ol><p>例如：表达式树</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743586675803.png" alt="中序遍历" style="zoom:50%;" /></p><h4 id="1-1-4-算法分析"><a href="#1-1-4-算法分析" class="headerlink" title="1.1.4 算法分析"></a>1.1.4 算法分析</h4><p>前/中/后序遍历均为<strong>深度优先</strong>遍历算法，可用递归实现，也可用模拟递归栈的方式进行非递归实现。</p><p>递归栈的最大深度和树的深度保持一致：</p><ul><li>最好情况，空间复杂度 <code>O(log n)</code> 。</li><li>最坏情况，空间复杂度 <code>O(n)</code> 。</li></ul><p>因为是遍历，所以时间复杂度为 <code>O(n)</code> 。</p><h3 id="1-2-广度优先：层序遍历"><a href="#1-2-广度优先：层序遍历" class="headerlink" title="1.2 广度优先：层序遍历"></a>1.2 广度优先：层序遍历</h3><p>用<strong>广度优先</strong>遍历算法，即<strong>层序遍历</strong>算法。在访问深度 d 的位置之前先访问深度 d+1 的位置。按照层次自低向高，每层从左向右访问。伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Algorithm breadthfirst(T):</span><br><span class="line">    Initialize queue Q to contain T.root()</span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">not</span> empty do</span><br><span class="line">        p = Q.dequeue()</span><br><span class="line">        visit(p)</span><br><span class="line">        <span class="keyword">for</span> each child c <span class="keyword">in</span> T.children(p) do</span><br><span class="line">        Q.enqueue(c)</span><br></pre></td></tr></table></figure><p>无法用递归实现，借助队列理解：</p><ul><li>先将根节点入队</li><li>每出队一个节点，将其孩子节点依次放入队列</li></ul><p>例如：下面实现了对一个树的逐步层序遍历。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743587103579.png" alt="层序遍历" style="zoom:50%;" /></p><h2 id="2-Python-实现树遍历"><a href="#2-Python-实现树遍历" class="headerlink" title="2 Python 实现树遍历"></a>2 Python 实现树遍历</h2><p>首先，继续上一章 <a href="https://blog.iskage.online/posts/7542010b.html#1-5-树的基类-Python-实现">树与二叉树</a> 定义的 <code>Tree</code> 类进行补充。先定义 <code>__iter__</code> 方法，产生迭代器，其中的 <code>positions()</code> 方法就可以用于指代不同的遍历方式。这个迭代器只是可以使用 <code>for i in obj</code> 的方式直接获取 <code>element</code> 值，而非 <code>Position</code> 节点类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义迭代器：遍历方式可选&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>.positions():  <span class="comment"># positions() 可选不同的遍历方式</span></span><br><span class="line">        <span class="keyword">yield</span> p.element()</span><br></pre></td></tr></table></figure><h3 id="2-1-前序遍历"><a href="#2-1-前序遍历" class="headerlink" title="2.1 前序遍历"></a>2.1 前序遍历</h3><p>在 <code>Tree</code> 类后继续补充 <code>preorder</code> 方法和 <code>_subtree_preorder</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_preorder(<span class="variable language_">self</span>.root()):  <span class="comment"># 递归实现</span></span><br><span class="line">            <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_subtree_preorder</span>(<span class="params">self, p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前序遍历子树&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> p  <span class="comment"># 访问根节点</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.children(p):  <span class="comment"># 遍历子树</span></span><br><span class="line">        <span class="keyword">for</span> other <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_preorder(c):</span><br><span class="line">            <span class="keyword">yield</span> other</span><br></pre></td></tr></table></figure><p>然后知道 <code>positions()</code> 方法为 <code>preorder()</code> 前序遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">positions</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;指定遍历方法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.preorder()</span><br></pre></td></tr></table></figure><p>或者直接继承 <code>Tree</code> 父类，覆写子类 <code>PreorderTree</code> 类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PreorderTree</span>(<span class="title class_ inherited__">Tree</span>):</span><br><span class="line">    <span class="comment"># ---------------- 遍历算法 ----------------</span></span><br><span class="line">    <span class="comment"># 迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;定义迭代器：遍历方式可选&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>.positions():  <span class="comment"># positions() 可选不同的遍历方式</span></span><br><span class="line">            <span class="keyword">yield</span> p.element()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_preorder(<span class="variable language_">self</span>.root()):  <span class="comment"># 递归实现</span></span><br><span class="line">                <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_subtree_preorder</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前序遍历子树&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> p  <span class="comment"># 访问根节点</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.children(p):  <span class="comment"># 遍历子树</span></span><br><span class="line">            <span class="keyword">for</span> other <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_preorder(c):</span><br><span class="line">                <span class="keyword">yield</span> other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">positions</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定遍历方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.preorder()</span><br></pre></td></tr></table></figure><h3 id="2-2-后序遍历"><a href="#2-2-后序遍历" class="headerlink" title="2.2 后序遍历"></a>2.2 后序遍历</h3><p>同理，为清晰展示，后面采用继承的方法，子类覆写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostorderTree</span>(<span class="title class_ inherited__">Tree</span>):</span><br><span class="line">    <span class="comment"># ---------------- 遍历算法 ----------------</span></span><br><span class="line">    <span class="comment"># 迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;定义迭代器：遍历方式可选&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>.positions():  <span class="comment"># positions() 可选不同的遍历方式</span></span><br><span class="line">            <span class="keyword">yield</span> p.element()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 后序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;后序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_postorder(<span class="variable language_">self</span>.root()):  <span class="comment"># 开始递归</span></span><br><span class="line">                <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_subtree_postorder</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;后序遍历子树&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.children(p):  <span class="comment"># 后序遍历子树</span></span><br><span class="line">            <span class="keyword">for</span> other <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_postorder(c):</span><br><span class="line">                <span class="keyword">yield</span> other</span><br><span class="line">        <span class="keyword">yield</span> p  <span class="comment"># 访问根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">positions</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定遍历方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.postorder()</span><br></pre></td></tr></table></figure><h3 id="2-3-二叉树的中序遍历"><a href="#2-3-二叉树的中序遍历" class="headerlink" title="2.3 二叉树的中序遍历"></a>2.3 二叉树的中序遍历</h3><p>此处是在二叉树类 <code>BinaryTree</code> 类中实现，见  <a href="https://blog.iskage.online/posts/7542010b.html#2-6-二叉树新增方法的-Python-实现">树与二叉树</a> 。为简单起见，也采用继承 <code>BinaryTree</code> 的方式定义一个新的类 <code>InorderTree</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InorderTree</span>(<span class="title class_ inherited__">BinaryTree</span>):</span><br><span class="line">    <span class="comment"># ---------------- 遍历算法 ----------------</span></span><br><span class="line">    <span class="comment"># 迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;定义迭代器：遍历方式可选&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>.positions():  <span class="comment"># positions() 可选不同的遍历方式</span></span><br><span class="line">            <span class="keyword">yield</span> p.element()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_inorder(<span class="variable language_">self</span>.root()):  <span class="comment"># 递归实现</span></span><br><span class="line">                <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_subtree_inorder</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历子树&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.left(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 遍历左子树</span></span><br><span class="line">            <span class="keyword">for</span> other <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_inorder(<span class="variable language_">self</span>.left(p)):</span><br><span class="line">                <span class="keyword">yield</span> other</span><br><span class="line">        <span class="keyword">yield</span> p  <span class="comment"># 访问根节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.right(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 遍历右子树</span></span><br><span class="line">            <span class="keyword">for</span> other <span class="keyword">in</span> <span class="variable language_">self</span>._subtree_inorder(<span class="variable language_">self</span>.right(p)):</span><br><span class="line">                <span class="keyword">yield</span> other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">positions</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定遍历方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.inorder()</span><br></pre></td></tr></table></figure><h3 id="2-4-广度优先：层序遍历"><a href="#2-4-广度优先：层序遍历" class="headerlink" title="2.4 广度优先：层序遍历"></a>2.4 广度优先：层序遍历</h3><p>为简单起见，直接在 <code>Tree</code> 基础类中加入新方法 <code>breadthfirst</code> 。其中 <code>LinkedQueue</code> 类是用链表实现的队列结构，具体可见 <a href="https://blog.iskage.online/posts/583f8c56.html#4-基于单向链表的队列实现">队列 Queue</a> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">breadthfirst</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;广度优先：层序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">        fringe = LinkedQueue()  <span class="comment"># 队列实现</span></span><br><span class="line">        fringe.enqueue(<span class="variable language_">self</span>.root())  <span class="comment"># 根节点入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> fringe.is_empty():</span><br><span class="line">            p = fringe.dequeue()  <span class="comment"># 取出头部</span></span><br><span class="line">            <span class="keyword">yield</span> p  <span class="comment"># 生成</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.children(p):  <span class="comment"># 将子节点入队</span></span><br><span class="line">                fringe.enqueue(c)</span><br></pre></td></tr></table></figure><h2 id="3-树的遍历的应用"><a href="#3-树的遍历的应用" class="headerlink" title="3 树的遍历的应用"></a>3 树的遍历的应用</h2><h3 id="3-1-前序遍历：目录表"><a href="#3-1-前序遍历：目录表" class="headerlink" title="3.1 前序遍历：目录表"></a>3.1 前序遍历：目录表</h3><p>树的前序遍历可以自然地被用于产生文档或书籍的目录表：</p><ul><li>如不需要缩进，则可直接使用<strong>前序遍历</strong>打印目录表</li><li>如需要缩进，则需要定义一个特殊的前序遍历函数</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743596275805.png" alt="通过前序遍历打印目录表" style="zoom:45%;" /></p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder_indent</span>(<span class="params">T, p, d</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前序遍历：打印目录</span></span><br><span class="line"><span class="string">    :param T: 目录树</span></span><br><span class="line"><span class="string">    :param p: 当前节点</span></span><br><span class="line"><span class="string">    :param d: 记录深度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span> * d * <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(p.element()))  <span class="comment"># 记录深度</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> T.children(p):</span><br><span class="line">        preorder_indent(T, c, d + <span class="number">1</span>)  <span class="comment"># 递归打印子树</span></span><br></pre></td></tr></table></figure><h3 id="3-2-后序遍历：计算磁盘空间"><a href="#3-2-后序遍历：计算磁盘空间" class="headerlink" title="3.2 后序遍历：计算磁盘空间"></a>3.2 后序遍历：计算磁盘空间</h3><p>计算磁盘空间：</p><ul><li>计算磁盘空间需要将文件系统表示为树后，使用<strong>后序遍历</strong></li><li>需要定义一个特殊的后序遍历函数记录当前占有的存储空间</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743597039347.png" alt="后序遍历计算磁盘空间"></p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">disk_space</span>(<span class="params">T, p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算文件系统树，p 节点后的总磁盘空间</span></span><br><span class="line"><span class="string">    :param T: 文件系统树</span></span><br><span class="line"><span class="string">    :param p: 当前节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    subtotal = p.element().space()  <span class="comment"># 节点 p 占有的空间</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> T.children(p):  <span class="comment"># 计算 p 的子树总空间</span></span><br><span class="line">        subtotal += disk_space(T, c)  <span class="comment"># 递归计算子树空间</span></span><br><span class="line">    <span class="keyword">return</span> subtotal</span><br></pre></td></tr></table></figure><h3 id="3-3-中序遍历：打印表达式"><a href="#3-3-中序遍历：打印表达式" class="headerlink" title="3.3 中序遍历：打印表达式"></a>3.3 中序遍历：打印表达式</h3><p>表达式树是一棵<strong>二叉树</strong>，使用表达式树输出表达式需要一种特殊的<strong>中序遍历</strong>算法：</p><ul><li>访问节点时输出节点存储的值或运算符</li><li>遍历左子树前输出 <code>(</code></li><li>遍历右子树后输出 <code>)</code></li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743586675803.png" alt="中序遍历打印表达式" style="zoom:50%;" /></p><p><strong>伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Algorithm printExpression(v)：</span><br><span class="line">    <span class="keyword">if</span> v has a left child</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">        printExpression(left(v))</span><br><span class="line">    <span class="built_in">print</span>(v.element())</span><br><span class="line">    <span class="keyword">if</span> v has a right child</span><br><span class="line">        printExpression(right(v))</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-4-后序遍历：计算表达式"><a href="#3-4-后序遍历：计算表达式" class="headerlink" title="3.4 后序遍历：计算表达式"></a>3.4 后序遍历：计算表达式</h3><p>使用表达式树计算表达式的值需要一种特殊的<strong>后序遍历</strong>：</p><ul><li>使用递归返回子树的值</li><li>访问内部节点时，使用内部节点的运算符对左、右子树的值做运算</li></ul><p><strong>伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Algorithm evalExpr(v):</span><br><span class="line">    <span class="keyword">if</span> is_leaf (v)</span><br><span class="line">    <span class="keyword">return</span> v.element()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = evalExpr(left(v))</span><br><span class="line">        y = evalExpr(right(v))</span><br><span class="line">        op = operator stored at v</span><br><span class="line">    <span class="keyword">return</span> x  y</span><br></pre></td></tr></table></figure><h3 id="3-5-后序遍历：剪去值为-0-的子树"><a href="#3-5-后序遍历：剪去值为-0-的子树" class="headerlink" title="3.5 后序遍历：剪去值为 0 的子树"></a>3.5 后序遍历：剪去值为 0 的子树</h3><p>给定一棵二叉树，假设其根节点为 <code>root</code> ，此二叉树的所有节点为 <code>0</code> 或 <code>1</code> 。请剪除该二叉树中所有节点的值均为 <code>0</code> 的子树。即若对于 p 节点，它的子节点 q 和以 q 为根节点的子树的值均为 0 ，则删去 q 子树。</p><p><strong>后序遍历</strong>：先对子树进行剪枝、再对当前节点进行剪枝。</p><p>例如：原始左边的树被剪为右边的树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span><span class="number">1</span></span><br><span class="line">   / \ \</span><br><span class="line">  <span class="number">0</span>   <span class="number">1</span>        -&gt;         <span class="number">1</span></span><br><span class="line"> / \ / \   \</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span> <span class="number">0</span>  <span class="number">1</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>代码实现</p><p>为简单起见，先定义节点类（右视图同样沿用这个定义）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">1</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_left</span>(<span class="params">self, val</span>):</span><br><span class="line">        new = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.left = new</span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_right</span>(<span class="params">self, val</span>):</span><br><span class="line">        new = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.right = new</span><br><span class="line">        <span class="keyword">return</span> new</span><br></pre></td></tr></table></figure><p>剪枝函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pruneTree</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">should_prune</span>(<span class="params">node: TreeNode</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理左子树</span></span><br><span class="line">        left_prune = should_prune(node.left)  <span class="comment"># 递归查看是否能剪枝</span></span><br><span class="line">        <span class="keyword">if</span> left_prune:</span><br><span class="line">            node.left = <span class="literal">None</span>  <span class="comment"># 剪去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理右子树</span></span><br><span class="line">        right_prune = should_prune(node.right)  <span class="comment"># 递归查看是否能剪枝</span></span><br><span class="line">        <span class="keyword">if</span> right_prune:</span><br><span class="line">            node.right = <span class="literal">None</span>  <span class="comment"># 剪去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前节点是否可以被剪掉</span></span><br><span class="line">        <span class="keyword">return</span> node.val == <span class="number">0</span> <span class="keyword">and</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> should_prune(root):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># root 也被剪去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=============== Before Prune ===============</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">=============== After pruning ===============</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3-6-树的右视图：深度-广度优先"><a href="#3-6-树的右视图：深度-广度优先" class="headerlink" title="3.6 树的右视图：深度/广度优先"></a>3.6 树的右视图：深度/广度优先</h3><p>给定一棵<strong>二叉树</strong>，假设其根节点为 <code>root</code> 。想象站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值（即二叉树的“右视图”）。</p><p><strong>思路 1：深度优先搜索</strong></p><ul><li>﻿﻿使用特殊的<strong>前序遍历</strong>：先访问右子树、再访问左子树</li><li>﻿﻿遍历时，同时记录当前节点深度，以及一个记录在不同深度碰到的第一个节点的数组</li><li>﻿﻿遍历结束后，数组中的结果即为树的“右视图”</li></ul><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS_rightSideView</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">    result = []  <span class="comment"># 存放右视图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, depth</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> depth == <span class="built_in">len</span>(result):</span><br><span class="line">            result.append(node.val)  <span class="comment"># 最右一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        dfs(node.right, depth + <span class="number">1</span>)</span><br><span class="line">        dfs(node.left, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    dfs(root, <span class="number">0</span>)  <span class="comment"># 初始 root 根节点</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=============== Initial Tree ===============</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">=============== Right Side View ===============</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>思路 2：广度优先搜索</strong></p><ul><li>﻿﻿使用特殊的<strong>层序遍历</strong>，每一层最后一个访问的节点即为树“右视图”中能看到的该层节点</li><li>使用队列作为辅助结构，可以同时记录下当前深度，或用不同队列记录不同层的遍历结果</li></ul><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS_rightSideView</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    result = []  <span class="comment"># 存放右视图</span></span><br><span class="line">    queue = [root]  <span class="comment"># 辅助队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:  <span class="comment"># 队列非空</span></span><br><span class="line">        size = <span class="built_in">len</span>(queue)  <span class="comment"># 树这一层的节点数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)  <span class="comment"># 头部出队</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == size - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 最后一个节点：进入右视图结果列表 result</span></span><br><span class="line">                result.append(node.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 否则子树进队</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=============== Initial Tree ===============</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">=============== Right Side View ===============</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">树的遍历常见方案：前序遍历 (preorder traversal) ，后序遍历 (postorder traversal) ，二叉树的中序遍历 (inorder traversal) ，层序遍历/广度优先遍历 (level order traversal/breadth-first traversal) 。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>SQL 自学笔记（11）MySQL 数据类型</title>
    <link href="https://blog.iskage.online/posts/42004b0.html"/>
    <id>https://blog.iskage.online/posts/42004b0.html</id>
    <published>2025-04-01T13:24:00.000Z</published>
    <updated>2025-04-01T13:25:48.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h1><p>本章详细的介绍了 MySQL 中主要的数据类型，包括：整数类型、浮点类型、定点数类型、位类型、日期时间类型、文本字符串类型、枚举类型、集合类型、二进制字符串类型、JSON 类型。并详细介绍了它们的使用和区别，以及实际中的选择。</p><h2 id="1-MySQL-的数据类型"><a href="#1-MySQL-的数据类型" class="headerlink" title="1 MySQL 的数据类型"></a>1 MySQL 的数据类型</h2><h3 id="1-1-常见的数据类型"><a href="#1-1-常见的数据类型" class="headerlink" title="1.1 常见的数据类型"></a>1.1 常见的数据类型</h3><p>对于任何一个数据表，每一行的每一列对应的元素都是下列数据类型的一种。</p><div class="table-container"><table><thead><tr><th>类型</th><th>关键字</th></tr></thead><tbody><tr><td>整数类型</td><td><code>TINYINT</code> <code>SMALLINT</code> <code>MEDIUMINT</code> <code>INT</code> (<code>INTEGER</code>) <code>BIGINT</code></td></tr><tr><td>浮点类型</td><td><code>FLOAT</code> <code>DOUBLE</code></td></tr><tr><td>定点数类型</td><td><code>DECIMAL</code></td></tr><tr><td>位类型</td><td><code>BIT</code></td></tr><tr><td>日期时间类型</td><td><code>YEAR</code> <code>TIME</code> <code>DATE</code> <code>DATETIME</code> <code>TIMESTAMP</code></td></tr><tr><td>文本字符串类型</td><td><code>CHAR</code> <code>VARCHAR</code> <code>TINYTEXT</code> <code>TEXT</code> <code>MEDIUMTEXT</code> <code>LONGTEXT</code></td></tr><tr><td>枚举类型</td><td><code>ENUM</code></td></tr><tr><td>集合类型</td><td><code>SET</code></td></tr><tr><td>二进制字符串类型</td><td><code>BINARY</code> <code>VARBINARY</code> <code>TINYBLOB</code> <code>BLOB</code> <code>MEDIUMBLOB</code> <code>LONGBLOB</code></td></tr><tr><td>JSON 类型</td><td><code>JSON对象</code> <code>JSON 数组</code></td></tr><tr><td>空间数据类型 (单值类型)</td><td><code>GEOMETRY</code> <code>POINT</code> <code>LINESTRING</code> <code>POLYGON</code></td></tr><tr><td>空间数据类型 (集合类型)</td><td><code>MULTIPOINT</code> <code>MULTILINESTRING</code> <code>MULTIPOLYGON</code> <code>GEOMETRYCOLLECTION</code></td></tr></tbody></table></div><h3 id="1-2-常见数据类型的属性"><a href="#1-2-常见数据类型的属性" class="headerlink" title="1.2 常见数据类型的属性"></a>1.2 常见数据类型的属性</h3><p>在常见数据表时，除了可以指定列的数据类型，还可以指定列的属性。</p><div class="table-container"><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td><code>NULL</code></td><td>数据列可包含 NULL 值</td></tr><tr><td><code>NOT NULL</code></td><td>数据列不允许包含 NULL 值</td></tr><tr><td><code>DEFAULT</code></td><td>默认值</td></tr><tr><td><code>PRIMARY KEY</code></td><td>主键</td></tr><tr><td><code>AUTO_INCREMENT</code></td><td>自动递增，适用于整数类型</td></tr><tr><td><code>UNSIGNED</code></td><td>无符号</td></tr><tr><td><code>CHARACTER SET name</code></td><td>指定一个字符集</td></tr></tbody></table></div><p><strong>下面分门别类的介绍这些数据类型：</strong></p><h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2 整数类型"></a>2 整数类型</h2><p><strong>整数类型</strong>一共有 5 种，分别是：<code>TINYINT</code> <code>SMALLINT</code> <code>MEDIUMINT</code> <code>INT</code> (<code>INTEGER</code>) <code>BIGINT</code> 。下面的表展示了他们的区别和特征。</p><h3 id="2-1-整数类型概述"><a href="#2-1-整数类型概述" class="headerlink" title="2.1 整数类型概述"></a>2.1 整数类型概述</h3><div class="table-container"><table><thead><tr><th>整数类型</th><th>字节</th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td><code>1</code></td><td>$-2^7 \sim 2^7$</td><td>$0 \sim 2^8$</td></tr><tr><td><code>SMALLINT</code></td><td><code>2</code></td><td>$-2^{15} \sim 2^{15}$</td><td>$0 \sim 2^{16}$</td></tr><tr><td><code>MEDIUMINT</code></td><td><code>3</code></td><td>$-2^{23} \sim 2^{23}$</td><td>$0 \sim 2^{24}$</td></tr><tr><td><code>INT</code></td><td><code>4</code></td><td>$-2^{31} \sim 2^{31}$</td><td>$0 \sim 2^{32}$</td></tr><tr><td><code>BIGINT</code></td><td><code>8</code></td><td>$-2^{63} \sim 2^{63}$</td><td>$0 \sim 2^{64}$</td></tr></tbody></table></div><h3 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a>2.2 可选属性</h3><p>整数类型有 3 个可选属性：<code>M</code> <code>UNSIGNED</code> <code>ZEROFILL</code></p><h4 id="2-2-1-M-显示宽度"><a href="#2-2-1-M-显示宽度" class="headerlink" title="2.2.1 M 显示宽度"></a>2.2.1 M 显示宽度</h4><p><code>M</code> : 表示显示宽度，取值范围是 <code>(0, 255)</code> 。例如，<code>int(5)</code> 表示当数据宽度小于 5 位的时候在数字前面需要用字符填满宽度。必须配合 <code>ZEROFILL</code> 表示用 <code>0</code> 填充，否则指定显示宽度无效。</p><blockquote><p>如果数据宽度超过显示宽度限制，不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存。</p></blockquote><p>不过，对于 <code>MySQL8.0</code> ，整数数据类型【不推荐】使用显示宽度属性。如果不指定，则系统为每一种类型指定默认的宽度值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_int1</span><br><span class="line">(</span><br><span class="line">    x TINYINT,</span><br><span class="line">    y <span class="type">SMALLINT</span>,</span><br><span class="line">    z MEDIUMINT,</span><br><span class="line">    m <span class="type">INT</span>,</span><br><span class="line">    n <span class="type">BIGINT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> test_int1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type      <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> x     <span class="operator">|</span> tinyint   <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> y     <span class="operator">|</span> <span class="type">smallint</span>  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> z     <span class="operator">|</span> mediumint <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> m     <span class="operator">|</span> <span class="type">int</span>       <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> n     <span class="operator">|</span> <span class="type">bigint</span>    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>在 MySQL 8.0 中，不再推荐显式的使用 <code>M</code> 显示宽度属性。</p><h4 id="2-2-2-UNSIGNED-无符号类型-非负"><a href="#2-2-2-UNSIGNED-无符号类型-非负" class="headerlink" title="2.2.2 UNSIGNED 无符号类型 (非负)"></a>2.2.2 UNSIGNED 无符号类型 (非负)</h4><p><code>UNSIGNED</code> ：无符号类型（非负），无符号整数类型的最小取值为 <code>0</code> 。所以，如果需要保存非负整数值时，可以将整数类型设置为无符号类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_int3</span><br><span class="line">(</span><br><span class="line">    f1 <span class="type">INT</span> UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> test_int3;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> f1    <span class="operator">|</span> <span class="type">int</span> unsigned <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h4 id="2-2-3-ZEROFILL-0-填充"><a href="#2-2-3-ZEROFILL-0-填充" class="headerlink" title="2.2.3 ZEROFILL 0 填充"></a>2.2.3 ZEROFILL 0 填充</h4><p><code>ZEROFILL</code> ：0填充，（如果某列设置了 ZEROFILL 属性，那么 MySQL 会自动为当前列添加 UNSIGNED 属性），ZEROFILL 只是表示不够 M 位时，用 0 在左边填充。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_int2</span><br><span class="line">(</span><br><span class="line">    f1 <span class="type">INT</span>,</span><br><span class="line">    f2 <span class="type">INT</span>(<span class="number">5</span>),</span><br><span class="line">    f3 <span class="type">INT</span>(<span class="number">5</span>) ZEROFILL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_int2(f1, f2, f3)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">123</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_int2(f1, f2)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">123456</span>, <span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_int2(f1, f2, f3)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">123456</span>, <span class="number">123456</span>, <span class="number">123456</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_int2;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> f1     <span class="operator">|</span> f2     <span class="operator">|</span> f3     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">123</span> <span class="operator">|</span>  <span class="number">00123</span> <span class="operator">|</span>  <span class="comment">-- 填充 0</span></span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span> <span class="operator">|</span> <span class="number">123456</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span> <span class="operator">|</span> <span class="number">123456</span> <span class="operator">|</span> <span class="number">123456</span> <span class="operator">|</span>  <span class="comment">-- 超过显示宽度不影响</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3 浮点类型"></a>3 浮点类型</h2><p>浮点数和定点数类型的都可以处理<strong>小数</strong>。MySQL 支持的浮点数类型，分别是 <code>FLOAT</code> <code>DOUBLE</code> <code>REAL</code> 。</p><h3 id="3-1-浮点类型概述"><a href="#3-1-浮点类型概述" class="headerlink" title="3.1 浮点类型概述"></a>3.1 浮点类型概述</h3><ul><li><p><code>FLOAT</code> 表示单精度浮点数；</p></li><li><p><code>DOUBLE</code> 表示双精度浮点数；</p></li><li><p><code>REAL</code> 默认就是 <code>DOUBLE</code> 。</p></li></ul><blockquote><p> 若启用 <code>REAL_AS_FLOAT</code> 则 MySQL 就认为 <code>REAL</code> 是 <code>FLOAT</code> 。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> &quot;REAL_AS_FLOAT&quot;;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>类型</th><th>占有字节数</th></tr></thead><tbody><tr><td><code>FLOAT</code></td><td><code>4</code></td></tr><tr><td><code>DOUBLE</code></td><td><code>8</code></td></tr></tbody></table></div><h3 id="3-2-数据精度【不推荐使用】"><a href="#3-2-数据精度【不推荐使用】" class="headerlink" title="3.2 数据精度【不推荐使用】"></a>3.2 数据精度【不推荐使用】</h3><p>使用 <code>FLOAT(M, D)</code> 或 <code>DOUBLE(M, D)</code> 可以指定浮点数的精度：<code>M</code> 代表<strong>整数位+小数位</strong>，<code>D</code>  代表<strong>小数位</strong>。</p><ul><li>如果存储时，整数部分超出了范围，MySQL 就会报错，不允许存这样的值</li><li>如果存储时，小数点部分若超出范围，则观察四舍五路后是否满足</li></ul><blockquote><p>从 MySQL 8 开始，<code>FLOAT(M, D)</code> 和 <code>DOUBLE(M, D)</code> 用法在官方文档中已经明确【不推荐使用】。另外，关于浮点型的 <code>UNSIGNED</code> 也【不推荐使用】。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_double1</span><br><span class="line">(</span><br><span class="line">    f1 <span class="type">FLOAT</span>,</span><br><span class="line">    f2 <span class="type">FLOAT</span>(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">    f3 <span class="keyword">DOUBLE</span>,</span><br><span class="line">    f4 <span class="keyword">DOUBLE</span>(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> test_double1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> f1    <span class="operator">|</span> <span class="type">float</span>       <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> f2    <span class="operator">|</span> <span class="type">float</span>(<span class="number">5</span>,<span class="number">2</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> f3    <span class="operator">|</span> <span class="keyword">double</span>      <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> f4    <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>存储报错/警告情况：超出范围</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> test_double1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span> (<span class="number">123.456</span>, <span class="number">1234.456</span>, <span class="number">123.4567</span>, <span class="number">123.45</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;f2&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>正常插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_double1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">123.456</span>, <span class="number">123.456</span>, <span class="number">123.4567</span>, <span class="number">123.45</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> test_double1;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> f1      <span class="operator">|</span> f2     <span class="operator">|</span> f3       <span class="operator">|</span> f4     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">123.456</span> <span class="operator">|</span> <span class="number">123.46</span> <span class="operator">|</span> <span class="number">123.4567</span> <span class="operator">|</span> <span class="number">123.45</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+----------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="3-3-精度误差"><a href="#3-3-精度误差" class="headerlink" title="3.3 精度误差"></a>3.3 精度误差</h3><p>采用浮点数存储小数会出现明显的精度误差，因为浮点数采用二进制的方式存储小数。以 $9.625$ 为例，其在 MySQL 的浮点数的存储方式为 $1001.101$ 即 $1.001101 \times 2^3$ 。此时如果结尾不是 $0,\ 5$ ，则无法用二进制精确表达。</p><p>因此，如果用到浮点数，由于浮点数是不准确的，所以避免使用 <code>==</code> 判断两个浮点数是否相等。在一些对精确度要求较高的项目中，不要使用浮点数。</p><p>使用 MySQL 中精准的数据类型：<strong>定点数类型</strong> <code>DECIMAL</code> 。</p><h2 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4 定点数类型"></a>4 定点数类型</h2><h3 id="4-1-定点数概述"><a href="#4-1-定点数概述" class="headerlink" title="4.1 定点数概述"></a>4.1 定点数概述</h3><p>使用 <code>DECIMAL(M, D)</code> 的方式表示<strong>高精度小数</strong>。其中，<code>M</code> 被称为精度，<code>D</code> 被称为标度。其中范围为 <code>0 &lt;= M &lt;= 65</code>  <code>0 &lt;= D &lt;= 30</code> <code>D &lt; M</code> 。例如， <code>DECIMAL(5, 2)</code> 表示该列取值范围是 <code>-999.99~999.99</code> 。</p><div class="table-container"><table><thead><tr><th>类型</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td><code>DECIMAL(M, D)</code></td><td><code>M+2</code> 字节</td><td>有效范围由 <code>M</code> 和 <code>D</code> 决定</td></tr></tbody></table></div><h3 id="4-2-精度"><a href="#4-2-精度" class="headerlink" title="4.2 精度"></a>4.2 精度</h3><p><code>DECIMAL(M, D)</code> 的最大取值范围与 <code>DOUBLE</code> 类型一样，但是有效的数据范围是由 <code>M</code> 和 <code>D</code> 决定的</p><ul><li><code>DECIMAL</code> 的存储空间并不是固定的，由精度值 <code>M</code> 决定，总共占用的存储空间为 <code>M+2</code> 个字节。</li><li>定点数在 MySQL 内部以 <code>字符串</code> 的形式进行存储，这就决定了它一定是精准的。</li><li>当 <code>DECIMAL</code> 类型不指定精度和标度时，其默认为 <code>DECIMAL(10, 0)</code> 。当数据的精度超出了定点数类型的精度范围时，同样会进行四舍五入处理。</li></ul><p>浮点数 vs 定点数</p><ul><li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景。</li><li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_decimal1</span><br><span class="line">(</span><br><span class="line">    f1 <span class="type">DECIMAL</span>,</span><br><span class="line">    f2 <span class="type">DECIMAL</span>(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> test_decimal1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type          <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> f1    <span class="operator">|</span> <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> f2    <span class="operator">|</span> <span class="type">decimal</span>(<span class="number">5</span>,<span class="number">2</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h2 id="5-位类型"><a href="#5-位类型" class="headerlink" title="5 位类型"></a>5 位类型</h2><p><code>BIT</code> 类型中存储的是<strong>二进制值</strong>。</p><h3 id="5-1-位类型概述"><a href="#5-1-位类型概述" class="headerlink" title="5.1 位类型概述"></a>5.1 位类型概述</h3><div class="table-container"><table><thead><tr><th>类型</th><th>长度</th><th>长度范围</th><th>占有空间</th></tr></thead><tbody><tr><td><code>BIT(M)</code></td><td><code>M</code></td><td><code>1 &lt;= M &lt;= 64</code></td><td>约 <code>(M + 7) / 8</code> 个字节</td></tr></tbody></table></div><p>位数 <code>M</code> 的含义：</p><ul><li><p><code>BIT</code> 类型，如果没有指定 <code>M</code> ，默认是 <code>1</code> 位，表示只能存 <code>1</code> 位的二进制值。</p></li><li><p><code>M</code> 是表示二进制的位数，位数最小值为 <code>1</code> ，最大值为 <code>64</code> 。</p></li></ul><h3 id="5-2-实际使用"><a href="#5-2-实际使用" class="headerlink" title="5.2 实际使用"></a>5.2 实际使用</h3><p>创建表并指定属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_bit1</span><br><span class="line">(</span><br><span class="line">    f1 BIT,</span><br><span class="line">    f2 BIT(<span class="number">5</span>),</span><br><span class="line">    f3 BIT(<span class="number">64</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> test_bit1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type    <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> f1    <span class="operator">|</span> bit(<span class="number">1</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> f2    <span class="operator">|</span> bit(<span class="number">5</span>)  <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> f3    <span class="operator">|</span> bit(<span class="number">64</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>在向 <code>BIT</code> 类型的字段中插入数据时，一定要确保插入的数据在 <code>BIT</code> 类型支持的范围内，即位数不可超过 <code>M</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> test_bit1(f1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span> (<span class="number">2</span>);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;f1&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>SELECT</code> 命令查询位字段时，可以用 <code>BIN()</code> 或 <code>HEX()</code> 或 <code>+ 0</code> 的方法进行读取</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_bit1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> f1         <span class="operator">|</span> f2         <span class="operator">|</span> f3         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0x01</span>       <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="number">0x17</span>       <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0x01</span>       <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> BIN(f2), HEX(f2), f2 <span class="operator">+</span> <span class="number">0</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> test_bit1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> BIN(f2) <span class="operator">|</span> HEX(f2) <span class="operator">|</span> f2 <span class="operator">+</span> <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10111</span>   <span class="operator">|</span> <span class="number">17</span>      <span class="operator">|</span>     <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p><code>BIN()</code> 查看二进制；<code>HEX()</code> 查看十六进制；<code>+ 0</code> 间接转换为十进制。</p></blockquote><h2 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6 日期与时间类型"></a>6 日期与时间类型</h2><p><strong>日期和时间类型</strong>主要有：<code>YEAR</code> <code>TIME</code> <code>DATE</code> <code>DATETIME</code> <code>TIMESTAMP</code></p><ul><li><code>YEAR</code> 类型通常用来表示 年</li><li><code>DATE</code> 类型通常用来表示 年、月、日</li><li><code>TIME</code> 类型通常用来表示 时、分、秒</li><li><code>DATETIME</code> 类型通常用来表示 年、月、日、时、分、秒</li><li><code>TIMESTAMP</code> 类型通常用来表示 带时区的年、月、日、时、分、秒</li></ul><h3 id="6-1-日期与时间类型概述"><a href="#6-1-日期与时间类型概述" class="headerlink" title="6.1 日期与时间类型概述"></a>6.1 日期与时间类型概述</h3><div class="table-container"><table><thead><tr><th>类型</th><th>字节</th><th>日期格式</th><th>最小值</th></tr></thead><tbody><tr><td><code>YEAR</code></td><td><code>1</code></td><td><code>YYYY</code> <code>YY</code></td><td><code>1901</code> - <code>2155</code></td></tr><tr><td><code>TIME</code></td><td><code>3</code></td><td><code>HH:MM:SS</code></td><td><code>-838:59:59</code>- <code>838:59:59</code></td></tr><tr><td><code>DATE</code></td><td><code>3</code></td><td><code>YYYY-MM-DD</code></td><td><code>1000-01-01</code> - <code>9999-12-03</code></td></tr><tr><td><code>DATETIME</code></td><td><code>8</code></td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td><code>1000-01-01 00:00:00</code> - <code>9999-12-31 23:59:59</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>4</code></td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td><code>1970-01-01 00:00:00 UTC</code> - <code>2038-01-19 03:14:07 UTC</code></td></tr></tbody></table></div><blockquote><p><code>TIME</code> 的范围是因为可以用来表示时间间隔。</p></blockquote><h3 id="6-2-各种类型"><a href="#6-2-各种类型" class="headerlink" title="6.2 各种类型"></a>6.2 各种类型</h3><h4 id="6-2-1-YEAR-类型"><a href="#6-2-1-YEAR-类型" class="headerlink" title="6.2.1 YEAR 类型"></a>6.2.1 YEAR 类型</h4><p><code>YEAR</code> 类型用来表示年份，只需要 <code>1</code> 个字节的存储空间。</p><p>以 4 位字符串或数字格式表示 YEAR 类型，其格式为 <code>YYYY</code> ，最小值为 1901 ，最大值为 2155 。以 2 位字符串格式表示 YEAR 类型，最小值为 00 ，最大值为 99 ：</p><ul><li><p>当取值为 <code>01</code> 到 <code>69</code> 时，表示 2001 到 2069 </p></li><li><p>当取值为 <code>70</code> 到 <code>99</code> 时，表示 1970 到 1999 </p></li><li>当取值为整数的 <code>0</code> 或 <code>00</code> 添加时，表示 0000 年</li><li>当取值为日期/字符串的 <code>&#39;0&#39;</code> 添加时，表示 2000 年</li></ul><blockquote><p>【不推荐】使用 2 位格式。默认 <code>YEAR</code> 就是 <code>YEAR(4)</code> 即为 4 位。同时，也【不推荐】指定显示宽度 <code>(M)</code> 。最好直接使用 <code>YEAR</code> 。</p></blockquote><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_year</span><br><span class="line">(</span><br><span class="line">    f1 <span class="keyword">YEAR</span>,  <span class="comment">-- 推荐</span></span><br><span class="line">    f2 <span class="keyword">YEAR</span>(<span class="number">4</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_year</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>);  <span class="comment">-- 推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_year</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;71&#x27;</span>);  <span class="comment">-- 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_year</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="string">&#x27;0&#x27;</span>);  <span class="comment">-- 0 和 &#x27;0&#x27; 对应 0000 年和 2000 年</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_year;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> f1   <span class="operator">|</span> f2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2020</span> <span class="operator">|</span> <span class="number">2021</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2045</span> <span class="operator">|</span> <span class="number">1971</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0000</span> <span class="operator">|</span> <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="6-2-2-DATE-类型"><a href="#6-2-2-DATE-类型" class="headerlink" title="6.2.2 DATE 类型"></a>6.2.2 DATE 类型</h4><p><code>DATE</code> 类型表示日期，格式为 <code>YYYY-MM-DD</code> ，其中，YYYY 表示年份，MM 表示月份，DD 表示日期。需要 3 个字节的存储空间。</p><p>在向 DATE 类型的字段插入数据时：</p><ul><li>以 <code>YYYY-MM-DD</code> 格式或者 <code>YYYYMMDD</code> 格式表示的字符串日期（<code>YYYYMMDD</code> 格式会被转化为<code>YYYY-MM-DD</code> 格式）</li><li>以 <code>YY-MM-DD</code> 格式或者 <code>YYMMDD</code> 格式表示的字符串日期</li><li>使用 <code>CURRENT_DATE()</code> 或者 <code>NOW()</code> 函数，会插入当前系统的日期</li></ul><blockquote><p>仍然【不推荐】使用 2 位表达年。</p></blockquote><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_date1</span><br><span class="line">(</span><br><span class="line">    f1 <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据：字符串/整型/<code>CURRENT_DATE()</code> <code>NOW()</code> 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_date1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2024-04-01&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;20240401&#x27;</span>),</span><br><span class="line">       (<span class="number">20201001</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_date1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="built_in">CURRENT_DATE</span>()),</span><br><span class="line">       (NOW());</span><br></pre></td></tr></table></figure><h4 id="6-2-3-TIME-类型"><a href="#6-2-3-TIME-类型" class="headerlink" title="6.2.3 TIME 类型"></a>6.2.3 TIME 类型</h4><p><code>TIME</code> 类型用来表示时间。需要 3 个字节的存储空间，格式为 <code>HH:MM:SS</code> 其中，<code>HH</code> 表示小时，<code>MM</code> 表示分钟，<code>SS</code> 表示秒。</p><p>在向 TIME 类型的字段插入数据时： </p><ul><li>可以使用带有冒号的字符串，格式为 <code>&#39;D HH:MM:SS&#39;</code> <code>&#39;HH:MM:SS&#39;</code> <code>&#39;HH:MM&#39;</code> <code>&#39;D HH:MM&#39;</code> <code>&#39;D HH&#39;</code>  <code>&#39;SS&#39;</code> 。其中 <code>D</code> 表示天，其最小值为 <code>0</code> ，最大值为 <code>34</code> ，D 会被转化为小时，<code>D * 24 + HH</code></li><li>可以使用不带有冒号的字符串或者数字，格式为 <code>&#39;HHMMSS&#39;</code> <code>HHMMSS</code> 。特别地，<code>1210</code> 表示 <code>00:12:10</code> </li><li>使用 <code>CURRENT_TIME()</code> <code>NOW()</code> 插入当前系统的时间</li></ul><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_time1</span><br><span class="line">(</span><br><span class="line">    f1 <span class="type">TIME</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_time1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2 12:30:29&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;12:35:29&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_time1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;123520&#x27;</span>),</span><br><span class="line">       (<span class="number">124011</span>),</span><br><span class="line">       (<span class="number">1210</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_time1</span><br><span class="line"><span class="keyword">VALUES</span> (NOW()),</span><br><span class="line">       (<span class="built_in">CURRENT_TIME</span>());</span><br></pre></td></tr></table></figure><h4 id="6-2-4-DATETIME-类型"><a href="#6-2-4-DATETIME-类型" class="headerlink" title="6.2.4 DATETIME 类型"></a>6.2.4 DATETIME 类型</h4><p><code>DATETIME</code> 总共需要 8 个字节的存储空间。在格式上为 DATE 类型和 TIME 类型的组合，可以表示为 <code>YYYY-MM-DD HH:MM:SS</code> ，其中 YYYY 表示年份，MM 表示月份，DD 表示日期，HH 表示小时，MM 表示分钟，SS 表示秒。</p><p>在向 DATETIME 类型的字段插入数据时： </p><ul><li>以 <code>&#39;YYYY-MM-DD HH:MM:SS&#39;</code> 格式或者 <code>&#39;YYYYMMDDHHMMSS&#39;</code> 格式的字符串插入，被转化为 <code>YYYY-MM-DD HH:MM:SS</code> 格式</li><li>【不推荐】以 <code>&#39;YY-MM-DD HH:MM:SS&#39;</code> 格式或者 <code>&#39;YYMMDDHHMMSS&#39;</code> 格式的字符串插入，被转化为 <code>YYYY-MM-DD HH:MM:SS</code> 格式</li><li>使用 <code>CURRENT_TIME()</code> <code>NOW()</code> 插入当前系统的时间</li></ul><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_datetime1</span><br><span class="line">(</span><br><span class="line">    dt DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_datetime1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2024-04-01 06:50:30&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;20240401065030&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_datetime1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">20240402065030</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_datetime1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="built_in">CURRENT_TIMESTAMP</span>()),</span><br><span class="line">       (NOW());</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_datetime1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> dt                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2024</span><span class="number">-04</span><span class="number">-01</span> <span class="number">06</span>:<span class="number">50</span>:<span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2024</span><span class="number">-04</span><span class="number">-01</span> <span class="number">06</span>:<span class="number">50</span>:<span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2024</span><span class="number">-04</span><span class="number">-02</span> <span class="number">06</span>:<span class="number">50</span>:<span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2025</span><span class="number">-04</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">56</span>:<span class="number">03</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2025</span><span class="number">-04</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">56</span>:<span class="number">03</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="6-2-5-TIMESTAMP-类型"><a href="#6-2-5-TIMESTAMP-类型" class="headerlink" title="6.2.5 TIMESTAMP 类型"></a>6.2.5 TIMESTAMP 类型</h4><p><code>TIMESTAMP</code> 显示格式与 DATETIME 类型相同，都是 <code>YYYY-MM-DD HH:MM:SS</code> ，需要 4 个字节的存储空间。但是 TIMESTAMP 存储的时间范围比 DATETIME 要小很多，只能存储 <code>&#39;1970-01-01 00:00:01 UTC&#39;</code> 到 <code>&#39;2038-01-19 03:14:07 UTC&#39;</code> 之间的时间。其中，UTC 表示世界统一时间，也叫作世界标准时间。</p><ul><li>TIMESTAMP 会对当前时间所在的时区进行转换。因此，使用 TIMESTAMP 存储的同一个时间值，在不同的时区查询时会显示不同的时间。</li><li>插入的时间超出了 TIMESTAMP 类型的范围，则报错。</li></ul><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_timestamp1</span><br><span class="line">(</span><br><span class="line">    ts <span class="type">TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_timestamp1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1970-01-02 03:04:50&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;19700102030405&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_timestamp1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="built_in">CURRENT_TIMESTAMP</span>()),</span><br><span class="line">       (NOW());</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_timestamp1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> ts                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-02</span> <span class="number">03</span>:<span class="number">04</span>:<span class="number">50</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-02</span> <span class="number">03</span>:<span class="number">04</span>:<span class="number">05</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2025</span><span class="number">-04</span><span class="number">-01</span> <span class="number">20</span>:<span class="number">02</span>:<span class="number">42</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2025</span><span class="number">-04</span><span class="number">-01</span> <span class="number">20</span>:<span class="number">02</span>:<span class="number">42</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>超出范围</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> test_timestamp1</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span> (<span class="string">&#x27;2038-01-20 03:14:07&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1292</span> (<span class="number">22007</span>): Incorrect datetime <span class="keyword">value</span>: <span class="string">&#x27;2038-01-20 03:14:07&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;ts&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>修改时区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> time_zone <span class="operator">=</span> <span class="string">&#x27;+9:00&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>TIMESTAMP</code> 底层存储的是距离 <code>1970-1-1 0:0:0</code> 0 毫秒的毫秒值。</p></blockquote><h2 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7 文本字符串类型"></a>7 文本字符串类型</h2><p><strong>文本字符串</strong>分为： <code>CHAR</code> <code>VARCHAR</code> <code>TINYTEXT</code> <code>TEXT</code> <code>MEDIUMTEXT</code> <code>LONGTEXT</code> <code>ENUM</code> <code>SET</code>类型。除了传统的 <code>CHAR</code> <code>VARCHAR</code> <code>TINYTEXT</code> <code>TEXT</code> <code>MEDIUMTEXT</code> <code>LONGTEXT</code> 类型，<code>ENUM</code> 类型也被称为枚举类型，<code>SET</code> 类型被称为集合类型。</p><h3 id="7-1-CHAR-与-VARCHAR-类型"><a href="#7-1-CHAR-与-VARCHAR-类型" class="headerlink" title="7.1 CHAR 与 VARCHAR 类型"></a>7.1 CHAR 与 VARCHAR 类型</h3><p><code>CHAR</code> 和 <code>VARCHAR</code> 类型可以存储比较短的字符串。</p><div class="table-container"><table><thead><tr><th>类型</th><th>特点</th><th>长度范围</th><th>占有存储空间</th></tr></thead><tbody><tr><td><code>CHAR(M)</code></td><td>固定长度</td><td><code>0 &lt;= M &lt;= 255</code></td><td>M 个字节</td></tr><tr><td><code>VARCHAR(M)</code></td><td>可变长度</td><td><code>0 &lt;= M &lt;= 65535</code></td><td>(实际长度 + 1) 个字节</td></tr></tbody></table></div><h4 id="7-1-1-CHAR-类型"><a href="#7-1-1-CHAR-类型" class="headerlink" title="7.1.1 CHAR 类型"></a>7.1.1 CHAR 类型</h4><p><strong>CHAR 类型：</strong></p><ul><li><code>CHAR(M)</code> 需要预先定义字符串长度。如果不指定，则长度默认是 <code>1</code> 个字符。</li><li>如果数据的实际长度比 CHAR 类型声明的长度小，则会在<strong>右侧填充</strong>空格以达到指定的长度。</li><li>当检索 CHAR 类型的数据时，会<strong>去除尾部的空格</strong>。</li><li>定义 CHAR 类型字段时，声明的 <code>M</code> 即为 CHAR 类型字段所占的存储空间的字节数。</li></ul><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_char1</span><br><span class="line">(</span><br><span class="line">    c1 <span class="type">CHAR</span>,</span><br><span class="line">    c2 <span class="type">CHAR</span>(<span class="number">5</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_char1</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_char1(c2)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;a  &#x27;</span>);</span><br></pre></td></tr></table></figure><p>检索数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(c2)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> test_char1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">CHAR_LENGTH</span>(c2) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span>               <span class="number">4</span> <span class="operator">|</span>  <span class="comment">-- &#x27;test&#x27; 4 个字符</span></span><br><span class="line"><span class="operator">|</span>               <span class="number">1</span> <span class="operator">|</span>  <span class="comment">-- &#x27;a  &#x27;  1 个字符，说明删去了右边的空格</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="7-1-2-VARCHAR-类型"><a href="#7-1-2-VARCHAR-类型" class="headerlink" title="7.1.2 VARCHAR 类型"></a>7.1.2 VARCHAR 类型</h4><p><strong>VARCHAR 类型：</strong></p><ul><li><code>VARCHAR(M)</code> 必须指定长度 <code>M</code> ，否则报错。</li><li>MySQL 5.0 以上，<code>VARCHAR(M)</code> 指的是 M 个字符，不是 M 个字节。</li><li>检索 VARCHAR 类型的字段数据时，会<strong>保留数据尾部的空格</strong>。</li><li>VARCHAR 类型的字段所占用的存储空间为<strong>字符串实际长度加1个字节</strong>。</li></ul><p>创建、插入、检索方法与 <code>CHAR</code> 相同，只是检索 VARCHAR 类型的字段数据时，会保留数据尾部的空格，且二者的存储方式不同。</p><blockquote><p><code>CHAR</code> 和 <code>VARCHAR</code> 比较：存储很短的信息、固定长度信息、以及需要频繁修改数据时，都推荐使用 <code>CHAR</code> 。（最后一个是因为，VARCHAR 是可变的，其存储长度需要计算实际字符串长度，频繁修改会增加计算负担）</p></blockquote><h3 id="7-2-TEXT-类型"><a href="#7-2-TEXT-类型" class="headerlink" title="7.2 TEXT 类型"></a>7.2 TEXT 类型</h3><p><code>TEXT</code> 用来保存文本类型的字符串，总共包含 4 种类型，分别为 <code>TINYTEXT</code> <code>TEXT</code> <code>MEDIUMTEXT</code> <code>LONGTEXT</code> 。保存和查询数据时，自动按照实际长度存储，不需要预先定义长度。</p><ul><li>由于实际存储的长度不确定，<strong>TEXT 类型的字段不能作主键</strong>。</li><li>存储和查询时，都<strong>不删除右边的空格</strong>。</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743513462778.png" alt=""></p><p>创建、插入和检索</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_text</span><br><span class="line">(</span><br><span class="line">    tx TEXT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_text</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;With space on the right.    &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(tx)</span><br><span class="line"><span class="keyword">FROM</span> test_text;  </span><br><span class="line"># <span class="number">28</span> 没有删除右边的空格</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_text;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br><span class="line"><span class="operator">|</span> tx                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">With</span> space <span class="keyword">on</span> the right.     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>TEXT 文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用 CHAR、VARCHAR 来代替。</p><p>TEXT 和 BLOB 类型的数据是大文件，删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含 TEXT 类型字段，建议单独用一个表。</p></blockquote><h3 id="7-3-ENUM-类型"><a href="#7-3-ENUM-类型" class="headerlink" title="7.3 ENUM 类型"></a>7.3 ENUM 类型</h3><p><code>ENUM</code> 类型（枚举类型），取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。其所需要的存储空间由定义 ENUM 类型时指定的成员个数决定：</p><ul><li>当 ENUM 类型包含 1 ~ 255 个成员时，需要 1 个字节的存储空间</li><li>当 ENUM 类型包含 256 ~ 65535 个成员时，需要 2 个字节的存储空间</li><li>ENUM 类型的成员个数的上限为 65535 个</li></ul><p>下面使用例子说明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_enum</span><br><span class="line">(</span><br><span class="line">    season ENUM (<span class="string">&#x27;春&#x27;</span>, <span class="string">&#x27;夏&#x27;</span>, <span class="string">&#x27;秋&#x27;</span>, <span class="string">&#x27;冬&#x27;</span>, <span class="string">&#x27;unknown&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 按照值插入</span><br><span class="line"><span class="keyword">INSERT INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;春&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;秋&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;unknown&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 允许按照数字索引的方式获取指定位置的枚举值</span><br><span class="line"><span class="keyword">INSERT INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">       (<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 报错：未知数字索引</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_enum;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> season  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> 春      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 秋      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="literal">unknown</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 春      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 秋      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="7-4-SET-类型"><a href="#7-4-SET-类型" class="headerlink" title="7.4 SET 类型"></a>7.4 SET 类型</h3><p><code>SET</code> 表示一个字符串对象，可以包含 0 个或多个成员，但成员个数的上限为 64 。当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的。</p><blockquote><p>【注意】<code>SET</code> 类型在选取成员时，可以<strong>一次选择多个成员</strong>，这一点与 <code>ENUM</code> 类型不同。</p></blockquote><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_set</span><br><span class="line">(</span><br><span class="line">    s <span class="keyword">SET</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_set (s)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>),</span><br><span class="line">       (<span class="string">&#x27;A,B&#x27;</span>);  <span class="comment">-- 插入多个成员 &#x27;A&#x27; 和 &#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"># 插入重复的 <span class="keyword">SET</span> 类型成员时，自动删除重复的成员</span><br><span class="line"><span class="keyword">INSERT INTO</span> test_set (s)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 报错：插入 SET 成员中不存在的值</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_set (s)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;A, B, C, D&#x27;</span>);</span><br></pre></td></tr></table></figure><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_set;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> s     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> A     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> A,B   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> A,B,C <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="8-二进制字符串类型"><a href="#8-二进制字符串类型" class="headerlink" title="8 二进制字符串类型"></a>8 二进制字符串类型</h2><p>MySQL 中的二进制字符串类型主要存储一些二进制数据，比如可以存储<strong>图片、音频和视频</strong>等二进制数据。MySQL 中支持的二进制字符串类型主要包括 <code>BINARY</code> <code>VARBINARY</code> <code>TINYBLOB</code> <code>BLOB</code> <code>MEDIUMBLOB</code> <code>LONGBLOB</code> 。</p><h3 id="8-1-BINARY-与-VARBINARY-类型"><a href="#8-1-BINARY-与-VARBINARY-类型" class="headerlink" title="8.1 BINARY 与 VARBINARY 类型"></a>8.1 BINARY 与 VARBINARY 类型</h3><p><code>BINARY(M)</code> 为固定长度的二进制字符串，<code>M</code> 表示最多能存储的字节数，取值范围是 <code>0~255</code> 。如果未指定 M ，表示只能存储 1 个字节。如果字段值不足 M 个字节，将<strong>在右边填充 <code>&#39;\0&#39;</code> 以补齐</strong>指定长度。</p><p><code>VARBINARY(M)</code> 为可变长度的二进制字符串，<code>M</code> 表示最多能存储的字节数。VARBINARY 类型的数据除了存储数据本身外，还需要 1 或 2 个字节来存储数据的字节数。VARBINARY类型<strong>必须指定 M </strong>，否则报错。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743513410216.png" alt=""></p><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_binary1</span><br><span class="line">(</span><br><span class="line">    f1 <span class="type">BINARY</span>,</span><br><span class="line">    f2 <span class="type">BINARY</span>(<span class="number">3</span>),</span><br><span class="line">    f3 <span class="type">VARBINARY</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_binary1(f1, f2)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_binary1(f1, f2)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;256&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_binary1(f2, f3)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;中文&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> test_binary1(f2, f3)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_binary1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> f1         <span class="operator">|</span> f2         <span class="operator">|</span> f3             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0x61</span>       <span class="operator">|</span> <span class="number">0x610000</span>   <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0x32</span>       <span class="operator">|</span> <span class="number">0x323536</span>   <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="number">0x380000</span>   <span class="operator">|</span> <span class="number">0xE4B8ADE69687</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="number">0x380000</span>   <span class="operator">|</span> <span class="number">0x31303234</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+----------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="8-2-BLOB-类型"><a href="#8-2-BLOB-类型" class="headerlink" title="8.2 BLOB 类型"></a>8.2 BLOB 类型</h3><p><code>BLOB</code> 是一个<strong>二进制大对象</strong>，可以容纳可变数量的数据。BLOB 包括 <code>TINYBLOB</code> <code>BLOB</code> <code>MEDIUMBLOB</code> <code>LONGBLOB</code> ，它们可容纳值的最大长度不同。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743513381573.png" alt=""></p><blockquote><p>实际上，往往不会在 MySQL 数据库中使用 BLOB 类型存储大对象数据，通常会将图片、音频和视频文件存储到服务器的磁盘上，并将图片、音频和视频的访问路径存储到 MySQL 中。</p></blockquote><p>创建的例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_blob1</span><br><span class="line">(</span><br><span class="line">    id  <span class="type">INT</span>,</span><br><span class="line">    img MEDIUMBLOB</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="9-JSON-类型"><a href="#9-JSON-类型" class="headerlink" title="9 JSON 类型"></a>9 JSON 类型</h2><p><code>JSON (JavaScript Object Notation)</code> 是一种<strong>轻量级的数据交换格式</strong>。</p><p>举例说明：创建数据表，表中包含一个 <code>JSON</code> 类型的字段 <code>js</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test_json</span><br><span class="line">(</span><br><span class="line">    js JSON</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>向表中插入 JSON 数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> test_json (js)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;name&quot;: &quot;Mike&quot;,</span></span><br><span class="line"><span class="string">  &quot;age&quot;: 21,</span></span><br><span class="line"><span class="string">  &quot;contact&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;tel&quot;: &quot;123456789&quot;,</span></span><br><span class="line"><span class="string">    &quot;email&quot;: &quot;123@work.com&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>查询数据</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743513181515.png" alt=""></p><p><strong>当需要检索 JSON 类型的字段中数据的具体值时，可以使用 <code>-&gt;</code> 或 <code>-&gt;&gt;</code> </strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span>          <span class="keyword">AS</span> name,</span><br><span class="line">       js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.age&#x27;</span>           <span class="keyword">AS</span> age,</span><br><span class="line">       js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.contact.tel&#x27;</span></span><br><span class="line">                               <span class="keyword">AS</span> tel,</span><br><span class="line">       js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.contact.email&#x27;</span> <span class="keyword">AS</span> email</span><br><span class="line"><span class="keyword">FROM</span> test_json;</span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743513350224.png" alt=""></p>]]></content>
    
    
    <summary type="html">本章详细的介绍了 MySQL 中主要的数据类型，包括：整数类型、浮点类型、定点数类型、位类型、日期时间类型、文本字符串类型、枚举类型、集合类型、二进制字符串类型、JSON 类型。</summary>
    
    
    
    <category term="MySQL" scheme="https://blog.iskage.online/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.iskage.online/tags/MySQL/"/>
    
    <category term="SQL" scheme="https://blog.iskage.online/tags/SQL/"/>
    
    <category term="数据库" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>树 Tree &amp; 二叉树 Binary Tree</title>
    <link href="https://blog.iskage.online/posts/7542010b.html"/>
    <id>https://blog.iskage.online/posts/7542010b.html</id>
    <published>2025-03-27T07:16:00.000Z</published>
    <updated>2025-04-10T15:13:10.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树-Tree-amp-二叉树-Binary-Tree"><a href="#树-Tree-amp-二叉树-Binary-Tree" class="headerlink" title="树 Tree &amp; 二叉树 Binary Tree"></a>树 Tree &amp; 二叉树 Binary Tree</h1><p>根据教材 <a href="https://book.douban.com/subject/30323938/">《数据结构与算法 Python 实现》</a> 整理，代码和笔记可前往我的 Github 库下载 <a href="https://github.com/isKage/dsa-notes">isKage/dsa-notes</a> 。【建议 star !】</p><hr><p>本章介绍了重要的数据结构：树。并详细讲解了二叉树。包括：树的定义、树的图论性质。并通过 Python 实现了树（基于链表 vs 基于数组），同时分析了时间复杂度。</p><h2 id="1-树-Tree"><a href="#1-树-Tree" class="headerlink" title="1 树 Tree"></a>1 树 Tree</h2><h3 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h3><p><strong>树 Tree</strong>是一种将元素分层次存储的抽象数据类型。除了最顶部的元素，每个元素在树中都有一个 <em>双亲节点</em> 和零个或者多个 <em>孩子节点</em> 。</p><p><strong>正式定义</strong>：通常我们将树 T 定义为存储一系列元素的有限节点集合，这些节点具有 parent-children 关系并且满足如下属性：</p><ul><li>如果树 T 不为空，则它一定具有一个称为 <em>根节点</em> root 的特殊节点，并且该节点没有父节点。</li><li>每个非根节点 v 都具有唯一的父节点 w ，每个具有父节点 w 的节点都是节点 w 的一个孩子。</li></ul><h3 id="1-2-相关术语"><a href="#1-2-相关术语" class="headerlink" title="1.2 相关术语"></a>1.2 相关术语</h3><p><strong>根节点</strong> <code>root</code> ：只有直接后继，没有先驱节点</p><p><strong>节点</strong> <code>node</code> ：树的基本组成单位，包含一个数据元素和指向子树的分支</p><p><strong>节点的度</strong> <code>degree</code> ：每个节点拥有的子树的数目</p><p><strong>叶子节点</strong> <code>leaf</code> ：度为 0 的节点，也称为<strong>外部节点</strong> <code>external node</code></p><p><strong>分支节点</strong> ：度不为 0 的节点，也称为<strong>内部节点</strong> <code>internal node</code></p><p><strong>孩子节点</strong> <code>child</code> ：某个节点的直接后继</p><p><strong>父节点</strong> <code>parent</code> ：一个节点是其孩子节点的父节点，也称为双亲节点</p><p><strong>兄弟节点</strong> <code>sibling</code> ：具有相同父节点的节点</p><p><strong>边</strong> <code>edge</code> ：一对节点 <code>(u, v)</code>，u 是 v 的父节点或反之</p><p><strong>路径</strong> <code>path</code> ：一条从 <code>ni</code> 到 <code>nj</code> 的路径，其中任意两个相邻的节点前者是后者的父节点</p><p><strong>祖先节点</strong> <code>ancestor</code> ：根节点到某节点的路径上所有的节点都是该节点的祖先节点</p><p><strong>子孙节点</strong> <code>descendant</code> ：某节点的所有子树上的节点都是其子孙节点</p><p><strong>树的度</strong> ：树中节点度的最大值</p><p><strong>节点的深度</strong> <code>depth</code> ：节点的祖先节点的个数，也称为<strong>层次</strong> <code>level</code></p><p><strong>节点的高度</strong> <code>height</code> ：节点的高度是连接它与它的子孙节点中叶子节点的最长路径的长度</p><p><strong>树的高度</strong> ：根节点的高度为树的高度</p><p><strong>有序树/无序树</strong> ：树中节点的子树从左到右安排有序/无序，各子树位置不能/可以交换</p><p><strong>森林</strong> <code>forest</code> ：数棵互不相交的树的集合</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742982398986.png" alt="树的例子：文件系统"></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742982331017.png" alt="树的例子：有序树"></p><h3 id="1-3-树的图论性质"><a href="#1-3-树的图论性质" class="headerlink" title="1.3 树的图论性质"></a>1.3 树的图论性质</h3><h4 id="1-3-1-节点数与度"><a href="#1-3-1-节点数与度" class="headerlink" title="1.3.1 节点数与度"></a>1.3.1 节点数与度</h4><p><strong>树的节点数等于所有节点度的总和加 $1$</strong></p><script type="math/tex; mode=display">\sum\limits_{i=1}^n\ d_i = n - 1</script><p><strong>证明</strong> 每个节点的度等于后继节点（子节点）的数量；而除了根节点外，每个节点都有一个分支指向它；总的分支数目等于除根节点外所有节点的数目，即 $n - 1$ 。 $\square$</p><h4 id="1-3-2-树的第-i-层的节点数"><a href="#1-3-2-树的第-i-层的节点数" class="headerlink" title="1.3.2 树的第 i 层的节点数"></a>1.3.2 树的第 i 层的节点数</h4><p><strong>节点度为 $k$ 的树，第 $i$ 层至多有 $𝑘^i$ 个节点</strong></p><script type="math/tex; mode=display">n_i \leq k^i</script><p>其中 $n_i$ 表示第 $i$ 层层的节点数。</p><p><strong>证明</strong> 第 0 层仅有根节点， $k_0 = 1$ ；假设结论对第 $i - 1$ 层成立，即该层最多有 $k^{i-1}$ 个节点；而根据定义，树的度为节点度的最大值，即第 $i-1$ 层每个节点最多有 $k$ 个后继节点，因此第 $i$ 层至多有 $k \times k^{i-1} = k^i$ 个节点。由归纳法，证毕。 $\square$</p><h4 id="1-3-3-树的最大节点数"><a href="#1-3-3-树的最大节点数" class="headerlink" title="1.3.3 树的最大节点数"></a>1.3.3 树的最大节点数</h4><p><strong>度为 $k$ 且高度为 $h$ 的树，至多有 $\dfrac{k^{h+1} - 1}{k - 1}$ 个节点</strong></p><script type="math/tex; mode=display">n \leq \dfrac{k^{h+1} - 1}{k - 1}</script><p><strong>证明</strong> 由 <a href="####1.3.2 树的度与第 i 层的节点数">性质 1.3.2</a> 可知，第 $i$ 层最多有 $k^i$ 个节点。则总共节点数不得超过 $\sum\limits_{i=0}^{h}\ k^i = \dfrac{k^{h+1} - 1}{k - 1}$ 。证明完毕。 $\square$</p><h4 id="1-3-4-树的最小高度"><a href="#1-3-4-树的最小高度" class="headerlink" title="1.3.4 树的最小高度"></a>1.3.4 树的最小高度</h4><p><strong>节点数为 $n$ 度为 $k$ 的树的高度至少为 $[\log_k\ (n(k-1)+1)] -1$</strong></p><script type="math/tex; mode=display">h \leq [\log_k\ (n(k-1)+1)] -1</script><p><strong>证明</strong> 要想达到最小高度，则第 $0,\ 1,\ \cdots,\ h - 1$ 层均需尽可能多地存储节点；由 <a href="####1.3.3 树的最大节点数">性质 1.3.3</a> 可知</p><script type="math/tex; mode=display">\dfrac{k^{h} - 1}{k - 1}< n \leq \dfrac{k^{h+1} - 1}{k - 1}</script><p>变换可得 $h \leq [\log_k\ (n(k-1)+1)] -1$ 。证毕。 $\square$</p><h3 id="1-4-树的抽象数据类型-ADT"><a href="#1-4-树的抽象数据类型-ADT" class="headerlink" title="1.4 树的抽象数据类型 ADT"></a>1.4 树的抽象数据类型 ADT</h3><p>树中的节点 ADT 仅支持一个方法：</p><ul><li><code>p.element()</code> : 返回存储在节点p处的元素</li></ul><p>树的基础抽象数据类型 ADT：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ADT Tree &#123;</span><br><span class="line">数据对象: T</span><br><span class="line">基本操作</span><br><span class="line">        T.root(): 返回树 T 的根节点，如 T 为空则返回 <span class="literal">None</span></span><br><span class="line">        T.parent(p): 返回 p 的父节点，如 p 为根节点则返回 <span class="literal">None</span></span><br><span class="line">        T.children(p): 产生 p 的孩子节点的迭代器</span><br><span class="line">        T.num_children(p): 返回 p 的孩子节点的数目</span><br><span class="line">        T.is_root(p): 如 p 为 T 的根，则返回 <span class="literal">True</span></span><br><span class="line">        T.is_leaf(p): 如 p 为树 T 的叶子节点，则返回 <span class="literal">True</span></span><br><span class="line">        T.depth(p): 返回树 T 中 p 节点的深度</span><br><span class="line">        T.height(p): 返回树 T 中 p 节点的高度</span><br><span class="line">        T.is_empty(): 如 T 为空树则返回 <span class="literal">True</span></span><br><span class="line">        <span class="built_in">len</span>(T): 返回树 T 中元素（节点）个数</span><br><span class="line">        T.nodes(): 生成树 T 所有节点的迭代器</span><br><span class="line">        <span class="built_in">iter</span>(T): 生成树 T 中存储的所有元素的迭代</span><br><span class="line">&#125; ADT Tree</span><br></pre></td></tr></table></figure><h3 id="1-5-树的基类-Python-实现"><a href="#1-5-树的基类-Python-实现" class="headerlink" title="1.5 树的基类 Python 实现"></a>1.5 树的基类 Python 实现</h3><h4 id="1-5-1-抽象类的实现"><a href="#1-5-1-抽象类的实现" class="headerlink" title="1.5.1 抽象类的实现"></a>1.5.1 抽象类的实现</h4><p>下面实现树的基础抽象类：其中内嵌了节点类 <code>Position</code> 。同时，此处只定义了方法名，并没有具体定义，具体定义需要子类继承时具体定义（针对不同类型的树，子类定义方式不同）。</p><p>特别地，基于暂时没有具体定义的抽象方法，具体定义了一些树的通用方法 <code>is_root()</code> <code>is_leaf()</code> <code>is_empty()</code> <code>depth()</code> <code>height()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;树的抽象基础类，基础方法需要子类定义&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 抽象方法: 节点类 具体实现由子类实现 ----------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Position</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;每个元素的位置/节点类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">element</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 由子类定义</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;比较节点是否相同&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 由子类定义</span></span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;比较节点是否不同&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> (<span class="variable language_">self</span> == other)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 抽象方法: 树的抽象基础类 具体实现由子类实现 ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">root</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回父节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num_children</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回节点 p 下的子节点数目&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">children</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器方式返回 p 节点的子类&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;树的所有节点数目&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 具体方法: 如果抽象方法被子类定义后 ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_root</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断 p 节点是否为根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.root() == p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断 p 节点是否为叶子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.num_children(p) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断树是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算深度算法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">depth</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回节点 p 的深度，即到根节点的路径距离&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_root(p):</span><br><span class="line">            <span class="comment"># 根节点深度为 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 递归：当前节点的深度 = 父节点的深度 + 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="variable language_">self</span>.depth(<span class="variable language_">self</span>.parent(p))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算高度算法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回节点 p 的高度，即距离其最远叶子节点的路径长&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_root(p):</span><br><span class="line">            <span class="comment"># 叶子节点高度为 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当前节点的高度 = 所有子节点高度最大值 + 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="variable language_">self</span>.height(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.children(p))</span><br></pre></td></tr></table></figure><h4 id="1-5-2-递归计算深度和高度"><a href="#1-5-2-递归计算深度和高度" class="headerlink" title="1.5.2 递归计算深度和高度"></a>1.5.2 递归计算深度和高度</h4><p><strong>计算深度</strong>：根据树中节点的深度的定义，节点的祖先节点的个数即为深度，故可以使用<strong>递归</strong>的方式计算深度：</p><ul><li>如果 <code>p</code> 为根节点，则其深度为 <code>0</code></li><li>否则，<code>p</code> 的深度为其父节点的深度加 <code>1</code></li></ul><p><strong>时间复杂度</strong>：对于位置 <code>p</code> ，计算深度的复杂度为 $O(d_p + 1)$ ，其中 $d_p$ 指的是节点 <code>p</code> 的深度，因为该算法对于p的每个祖先节点执行的时间是常数。最坏的情况下运行时间为 $O(n)$ 。其中n是树中节点的总个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算深度算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">depth</span>(<span class="params">self, p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回节点 p 的深度，即到根节点的路径距离&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.is_root(p):</span><br><span class="line">        <span class="comment"># 根节点深度为 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 递归：当前节点的深度 = 父节点的深度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="variable language_">self</span>.depth(<span class="variable language_">self</span>.parent(p))</span><br></pre></td></tr></table></figure><p><strong>计算高度</strong>：根据树中节点的高度的定义，连接它与它的子孙节点中叶子节点的最长路径的长度即为高度，故可以使用<strong>递归</strong>的方式计算高度：</p><ul><li>如果 <code>p</code> 为叶子节点，则其高度为 <code>0</code></li><li>否则，<code>p</code> 的高度为其孩子节点中最大的高度加 <code>1</code></li></ul><p><strong>时间复杂度</strong>：如以 <code>p</code> 为根节点的子树有 $n_p$ 个节点，则时间复杂度为 $O(n_p)$ 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算高度算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回节点 p 的高度，即距离其最远叶子节点的路径长&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.is_root(p):</span><br><span class="line">        <span class="comment"># 叶子节点高度为 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 当前节点的高度 = 所有子节点高度最大值 + 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="variable language_">self</span>.height(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable language_">self</span>.children(p))</span><br></pre></td></tr></table></figure><h2 id="2-二叉树-Binary-Tree"><a href="#2-二叉树-Binary-Tree" class="headerlink" title="2 二叉树 Binary Tree"></a>2 二叉树 Binary Tree</h2><h3 id="2-1-二叉树的定义"><a href="#2-1-二叉树的定义" class="headerlink" title="2.1 二叉树的定义"></a>2.1 二叉树的定义</h3><p><strong>二叉树</strong>：是具有以下属性的有序树</p><ul><li>每个节点最多有两个孩子节点。</li><li>每个孩子节点被命名为左孩子或右孩子。</li><li>对于每个节点的孩子节点，在顺序上，左孩子先于右孩子。</li></ul><p><strong>二叉树的递归定义</strong>：二叉树或为空树，或满足以下<strong>任一条件</strong>：</p><ul><li>为一个单独的节点</li><li>根节点有至多两个有序的孩子节点，且根节点的子树也为二叉树</li></ul><h3 id="2-2-二叉树的例子"><a href="#2-2-二叉树的例子" class="headerlink" title="2.2 二叉树的例子"></a>2.2 二叉树的例子</h3><p><strong>算式表达树</strong></p><p>二叉树能用于表示算术表达式</p><ul><li>内部节点：存储操作符</li><li>叶子节点：存储变量或常数</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742994629723.png" alt="算式表达树" style="zoom:50%;" /></p><p><strong>决策树</strong></p><p>二叉树可以用来描述决策过程</p><ul><li>内部节点：存储一个回答为“是”或“否”的问题</li><li>叶子节点：存储决策</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742994742939.png" alt="提供投资决策的决策树" style="zoom:50%;" /></p><p><strong>搜索树</strong></p><p>二叉树可存储有序序列，并使用此二叉树进行搜索</p><ul><li>节点：存储元素</li><li>节点左子树（右子树）的元素均小于（大于）节点存储的元素</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742994851160.png" alt="实线为搜索36（成功），虚线为搜索70（不成功）"></p><h3 id="2-3-二叉树的图论性质"><a href="#2-3-二叉树的图论性质" class="headerlink" title="2.3 二叉树的图论性质"></a>2.3 二叉树的图论性质</h3><p>记 $n$ 表示二叉树的节点总数； $n_E$ 表示二叉树的叶子节点数目； $n_I$ 表示二叉树的内部节点数目； $h$ 表示二叉树的高度。</p><h4 id="2-3-1-基于树的性质"><a href="#2-3-1-基于树的性质" class="headerlink" title="2.3.1 基于树的性质"></a>2.3.1 基于树的性质</h4><p>因为二叉树的每个节点的度最多为 2 ，所以基于树的性质可以推出：</p><p><strong>第 $i$ 层至多有 $2^i$ 个节点</strong></p><p><strong>二叉树的节点总数满足 $h + 1 \leq n \leq 2^{h+1} - 1$</strong> </p><p><strong>二叉树的高度满足 $h \leq [\log_k\ (n+1)] -1$</strong></p><p><strong>二叉树叶子节点数目满足 $1 \leq n_E \leq 2^h$</strong> ：叶子节点最少，当整个二叉树为链式结构时成立，此时只有最后一个叶子节点；叶子节点最多，则对于高度 $h$ 的二叉树，每一个节点都是度为 2 ，最后有 $2^h$ 个叶子节点。</p><p><strong>二叉树内部节点数目满足 $h \leq n_I \leq 2^h - 1$</strong> ：内部节点最少，当整个二叉树为链式结构时成立，此时内部节点即为链长 $h$ ；内部节点最多，与叶子节点最多情况相同，排除根节点，所以为 $2^h - 1$ 个。</p><h4 id="2-3-2-二叉树独有性质"><a href="#2-3-2-二叉树独有性质" class="headerlink" title="2.3.2 二叉树独有性质"></a>2.3.2 二叉树独有性质</h4><p><strong>对任何非空二叉树，设叶子节点数为 $n_0$，度为 2 的节点数为 $n_2$ ，则有：$n_0 = n_2 + 1$</strong></p><p><strong>证法1</strong> 设二叉树中度为 1 度节点个数为 $n_1$ ，则有 $n = n_0 + n_1 + n+2$ 。</p><p>根据树的 <a href="####1.3.1 节点数与度">性质 1.3.1</a> ，有 $n = 0 \times n_0 + 1 \times n_1 + 2 \times n_2 = n_1 + 2n_2$ 。</p><p>比较以上两式，可得 $n_0 = n_2 + 1$ 。证明完毕 $\square$</p><p><strong>证法2</strong> 我们从树中取下一个（任意的）外部节点 w 和其父节点 v ，v 为内部节点。若 v 有父节点 u ，则将 u 与 w 之前的兄弟节点 z 连接起来，如图所示。</p><p>重复上述操作，我们最后将会得到仅有一个节点（根节点）的最终树。</p><p>每次操作，叶子节点数目减一；度为 2 的节点数目减一。最后剩下根节点一个孤点（可视作叶子节点），所以 $n_0 = n_2 + 1$ 。证明完毕 $\square$</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742998908752.png" alt="归纳过程的变换"></p><h3 id="2-4-二叉树的类别"><a href="#2-4-二叉树的类别" class="headerlink" title="2.4 二叉树的类别"></a>2.4 二叉树的类别</h3><p><strong>完美二叉树 Perfect Binary Tree</strong> ：高度为 $h$ 且有恰好有 $2^{h+1}-1$ 个节点的二叉树，称为完美二叉树或满二叉树。</p><p><strong>完全二叉树 Complete Binary Tree</strong> ：高度为 $h$ 的完全二叉树，除第 $h$ 层外其他各层结点数均达到最大值 $2^i$ ；第 $h$ 层元素尽可能存放在左侧的节点中，使得若某节点右子树高度为 $l$ ，则其左子树高度为 $l$ 或 $l+1$ 。</p><p><strong>完满二叉树 Full Binary Tree</strong> ：也称为 Proper Binary Tree，所有内部节点度均为 2（均有两个孩子）的二叉树。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/tree.png" alt="三种二叉树"></p><h3 id="2-5-二叉树的抽象数据类型-ADT"><a href="#2-5-二叉树的抽象数据类型-ADT" class="headerlink" title="2.5 二叉树的抽象数据类型 ADT"></a>2.5 二叉树的抽象数据类型 ADT</h3><p>二叉树的 ADT 是对树的 ADT 的拓展，它<strong>继承了树的 ADT 的所有基本操作</strong>，并附加了以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T.left(p): 返回 p 的左孩子节点，若没有则返回 <span class="literal">None</span></span><br><span class="line">T.right(p): 返回 p 的右孩子节点，若没有则返回 <span class="literal">None</span></span><br><span class="line">T.sibling(p): 返回 p 的兄弟节点，若没有则返回 <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="2-6-二叉树新增方法的-Python-实现"><a href="#2-6-二叉树新增方法的-Python-实现" class="headerlink" title="2.6 二叉树新增方法的 Python 实现"></a>2.6 二叉树新增方法的 Python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .basic_tree <span class="keyword">import</span> Tree</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> basic_tree <span class="keyword">import</span> Tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>(<span class="title class_ inherited__">Tree</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二叉树的抽象基类，继承 Tree，一些方法暂不定义&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 新增的抽象方法: 具体实现由子类实现 ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回当前节点 p 的左孩子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回当前节点 p 的右孩子节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;must be implemented by subclass&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 具体方法: 如果抽象方法被子类定义后 ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sibling</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回当前节点 p 的兄弟节点&quot;&quot;&quot;</span></span><br><span class="line">        parent = <span class="variable language_">self</span>.parent(p)  <span class="comment"># 获取父节点</span></span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 根节点无兄弟节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 非左即右</span></span><br><span class="line">            <span class="keyword">if</span> p == <span class="variable language_">self</span>.left(parent):</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.right(parent)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.left(parent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">children</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;以迭代器的方式返回子节点（先左后右）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.left(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="variable language_">self</span>.left(p)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.right(p) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="variable language_">self</span>.right(p)</span><br></pre></td></tr></table></figure><h2 id="3-树的实际实现"><a href="#3-树的实际实现" class="headerlink" title="3 树的实际实现"></a>3 树的实际实现</h2><p>之前定义的 <code>Tree</code> 和 <code>BinaryTree</code> 类都只是形式上的抽象基类。尽管给出了许多支持操作，但它们都不能直接被实例化。</p><p>特别地，具体实现树要能提供 <code>Root</code>、<code>parent</code>、<code>num_children</code>、<code>children</code> 和 <code>__len__</code> 这些方法，对于 Binary Tree 类，还要提供 <code>left</code> 和 <code>right</code> 方法。</p><p>我们可以采用<strong>链式结构</strong>存储树，也可采用<strong>数组</strong>存储树。下面基于二叉树的实现介绍：</p><h3 id="3-1-基于链表：链式存储结构"><a href="#3-1-基于链表：链式存储结构" class="headerlink" title="3.1 基于链表：链式存储结构"></a>3.1 基于链表：链式存储结构</h3><p>目标：定义 <code>BinaryTree</code> 类的一个具体子类 <code>LinkedBinaryTree</code> ，该类能够实现二叉树 ADT。</p><h4 id="3-1-1-思路"><a href="#3-1-1-思路" class="headerlink" title="3.1.1 思路"></a>3.1.1 思路</h4><p>定义一个简单、非公开的 <code>_Node</code> 类表示一个节点，再定义一个公开的 <code>Position</code> 类用于封装节点。</p><p>一个节点存储以下信息：</p><ul><li>元素值</li><li>指向父节点的指针</li><li>指向左孩子的指针</li><li>指向右孩子的指针</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743054428079.png" alt="二叉树链式结构的图示"></p><h4 id="3-1-2-Python-实现"><a href="#3-1-2-Python-实现" class="headerlink" title="3.1.2 Python 实现"></a>3.1.2 Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .binary_tree <span class="keyword">import</span> BinaryTree</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> binary_tree <span class="keyword">import</span> BinaryTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedBinaryTree</span>(<span class="title class_ inherited__">BinaryTree</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;链式结构的二叉树&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 非公开节点类 ----------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Node</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;非公开节点类&quot;&quot;&quot;</span></span><br><span class="line">        __slots__ = <span class="string">&#x27;_element&#x27;</span>, <span class="string">&#x27;_parent&#x27;</span>, <span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, element, parent=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">            <span class="variable language_">self</span>._element = element</span><br><span class="line">            <span class="variable language_">self</span>._parent = parent</span><br><span class="line">            <span class="variable language_">self</span>._left = left</span><br><span class="line">            <span class="variable language_">self</span>._right = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 公有的节点类 ----------------</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Position</span>(BinaryTree.Position):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;覆写父类 BinaryTree 的显式节点类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, container, node</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;具体初始化&quot;&quot;&quot;</span></span><br><span class="line">            <span class="variable language_">self</span>._container = container  <span class="comment"># 标记属于的树</span></span><br><span class="line">            <span class="variable language_">self</span>._node = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">element</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;具体实现返回元素值&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._node._element</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;具体实现 ==&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>(other) <span class="keyword">is</span> <span class="built_in">type</span>(<span class="variable language_">self</span>) <span class="keyword">and</span> other._node <span class="keyword">is</span> <span class="variable language_">self</span>._node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 封装公有节点类 Position ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_validate</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在封装 Position 类前判断节点 p 是否合法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(p, <span class="variable language_">self</span>.Position):</span><br><span class="line">            <span class="comment"># 不是合法的节点类</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;p must be proper Position type&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> p._container <span class="keyword">is</span> <span class="keyword">not</span> <span class="variable language_">self</span>:</span><br><span class="line">            <span class="comment"># 不属于当前树</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;p does not belong to this container&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> p._node._parent <span class="keyword">is</span> p._node:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;p is no longer valid&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> p._node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make_position</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据接受的节点类 _Node 封装为一个 Position 类&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.Position(<span class="variable language_">self</span>, node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 二叉树具体实现 ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化一个空的二叉树&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._root = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>._size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 二叉树公有方法具体实现：覆写父类方法 ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回树的节点总数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">root</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回根节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._make_position(<span class="variable language_">self</span>._root)  <span class="comment"># 返回 self.Position 类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回父节点&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)  <span class="comment"># 判断合法并返回合法对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._make_position(node._parent)  <span class="comment"># 封装为 Position 返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回左子节点&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._make_position(node._left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回右子节点&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._make_position(node._right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num_children</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回孩子节点数目&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node._left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> node._right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------- 二叉树非公有方法具体实现：一些对树的操作 ----------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_add_root</span>(<span class="params">self, e</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;填入根元素，并返回封装后的 Position 类&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Root exists&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._size = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>._root = <span class="variable language_">self</span>._Node(e)  <span class="comment"># 创建节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._make_position(<span class="variable language_">self</span>._root)  <span class="comment"># 封装返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_add_left</span>(<span class="params">self, p, e</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在节点 p 下加左子节点，并返回封装后的类&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)  <span class="comment"># 判断是否合法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node._left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Left node exists&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._size += <span class="number">1</span></span><br><span class="line">        node._left = <span class="variable language_">self</span>._Node(e, parent=node)  <span class="comment"># 父节点为 node</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._make_position(node._left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_add_right</span>(<span class="params">self, p, e</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在节点 p 下加右子节点，并返回封装后的类&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        <span class="keyword">if</span> node._right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Right node exists&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._size += <span class="number">1</span></span><br><span class="line">        node._right = <span class="variable language_">self</span>._Node(e, parent=node)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._make_position(node._right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_replace</span>(<span class="params">self, p, e</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;替换节点 p 的元素值，并返回旧元素&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        old = node._element</span><br><span class="line">        node._element = e</span><br><span class="line">        <span class="keyword">return</span> old</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_delete</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除节点 p 用其孩子替代。当 p 非法或有两个孩子则报错&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)  <span class="comment"># p 非法与否</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.num_children(p) == <span class="number">2</span>:  <span class="comment"># p 有 2 个孩子</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;p has two children&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取 p 的孩子节点</span></span><br><span class="line">        child = node._left <span class="keyword">if</span> node._left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> node._right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 子节点连接父节点的父节点</span></span><br><span class="line">            child._parent = node._parent</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="variable language_">self</span>._root:</span><br><span class="line">            <span class="comment"># 父节点为根节点则子节点成为新根节点</span></span><br><span class="line">            <span class="variable language_">self</span>._root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 更新父节点的父节点的孩子节点</span></span><br><span class="line">            parent = node._parent</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> parent._left:</span><br><span class="line">                parent._left = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                parent._right = child</span><br><span class="line">        <span class="variable language_">self</span>._size -= <span class="number">1</span>  <span class="comment"># 节点数减一</span></span><br><span class="line">        node._parent = node  <span class="comment"># 惯例：self.parent -&gt; self</span></span><br><span class="line">        <span class="keyword">return</span> node._element</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_attach</span>(<span class="params">self, p, t1, t2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将子树 t1, t2 作为 p 的左右子节点连入树&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._validate(p)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_leaf(p):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;position must be leaf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(<span class="variable language_">self</span>) <span class="keyword">is</span> <span class="built_in">type</span>(t1) <span class="keyword">is</span> <span class="built_in">type</span>(t2):  <span class="comment"># 三个树类型必须相同</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Tree types must match&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._size += <span class="built_in">len</span>(t1) + <span class="built_in">len</span>(t2)  <span class="comment"># 更新节点数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1.is_empty():</span><br><span class="line">            t1._root._parent = node</span><br><span class="line">            node._left = t1._root</span><br><span class="line">            t1._root = <span class="literal">None</span></span><br><span class="line">            t1._size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2.is_empty():</span><br><span class="line">            t2._root._parent = node</span><br><span class="line">            node._right = t2._root</span><br><span class="line">            t2._root = <span class="literal">None</span></span><br><span class="line">            t2._size = <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-算法分析"><a href="#3-1-3-算法分析" class="headerlink" title="3.1.3 算法分析"></a>3.1.3 算法分析</h4><ul><li><p><code>len</code> 方法：在 LinkedBinaryTree 内部实现，使用一个实例变量 <code>self._size</code> 存储T的节点数，花费 <code>O(1)</code> 的时间。</p></li><li><p><code>is_empty</code> 方法：继承自 Tree 类，对 <code>len</code> 方法进行一次调用，因此需要花费 <code>O(1)</code> 的时间。</p></li><li><p>访问方法 <code>root</code>、<code>left</code>、<code>right</code>、<code>parent</code> 和 <code>num_children</code> ：直接在 LinkedBinaryTree 中执行，花费 <code>O(1)</code> 的时间。</p></li><li><code>sibling</code> 和 <code>children</code> 方法：从 BinaryTree 类派生，对其他访问方法做固定次的调用，因此，它们的运行时间也是 <code>O(1)</code> 。</li><li>Tree 类的 <code>is_ root</code> 和 <code>is_leaf</code> 方法：都运行 <code>O(1)</code> 的时间，因为 <code>is_root</code> 调用 <code>root</code> 方法，之后判定两者的位置是否相等；而 <code>is_leaf</code> 调用 <code>left</code> 和 <code>right</code> 方法，并验证二者是否返回 <code>None</code> 。</li><li><code>depth</code> 和 <code>height</code> 方法：见 <a href="####1.5.2 递归计算深度和高度">1.5.2 递归计算深度和高度</a> 。</li><li>各种更新方法 <code>add_root</code>、<code>add_left</code>、<code>add_right</code>、<code>replace</code>、<code>delete</code> 和 <code>attach</code> ：都运行 <code>O(1)</code> 的时间，因为它们每次操作都仅仅重新链接到固定的节点数。</li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743059677999.png" alt="链式结构的二叉树时间复杂度"></p><h3 id="3-2-基于数组：数组实现二叉树"><a href="#3-2-基于数组：数组实现二叉树" class="headerlink" title="3.2 基于数组：数组实现二叉树"></a>3.2 基于数组：数组实现二叉树</h3><p>二叉树 T 的一种可供选择的表示法是对 T 的位置进行编号。对于 T 的每个位置 p ，设 f(p) 为整数且定义如下：</p><ul><li>若 p 是 T 的根节点，则 <code>f(p) = 0</code></li><li>若 p 是位置 q 的左孩子，则 <code>f(p) = 2 * f(q) + 1</code></li><li>若 p 是位置 q 的右孩子，则 <code>f(p) = 2 * f(q) + 2</code></li><li>而 p 的父节点的编号为 <code>(f(p) - 1) / 2</code></li></ul><p>编号函数 <code>f</code> 被称二叉树 T 的位置的<strong>层编号</strong>，因为它将 T 每一层的位置从左往右按递增顺序编号。</p><h4 id="3-2-1-思路"><a href="#3-2-1-思路" class="headerlink" title="3.2.1 思路"></a>3.2.1 思路</h4><p>层编号函数 <code>f</code> 是一种二叉树 T 依据基于数组结构 A（例如，Python 列表）的表示方法，<strong>T 的 p 位置元素存储在数组下标为 <code>f(p)</code> 的内存中</strong>。</p><p>注意，层编号是基于树内的潜在位置，而不是所给树的实际位置，因此编号不一定是连续的。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743060184180.png" alt="数组存储树的示例" style="zoom:67%;" /></p><h4 id="3-2-2-算法分析-缺点"><a href="#3-2-2-算法分析-缺点" class="headerlink" title="3.2.2 算法分析/缺点"></a>3.2.2 算法分析/缺点</h4><ul><li>空间使用极大依赖于树的形状，在二叉树为完全二叉树时效率最高；最坏情况下数组长度 N 与节点数 n 有 $N = 2^n - 1$ 的关系</li><li>删除、插入等更新操作花费时间为 $O(n)$</li></ul><h3 id="3-3-一般树的链式结构"><a href="#3-3-一般树的链式结构" class="headerlink" title="3.3 一般树的链式结构"></a>3.3 一般树的链式结构</h3><p>对于一般的树结构，<code>parent</code> 父节点唯一，没有变化；<code>element</code> 元素存储也大致相同；唯一不同的是子节点可以是多个，可以通过<strong>存储一个指向指针数组的指针</strong>来实现指向多个子节点。</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743060645944.png" alt="一般树的链式结构"></p><p><strong>算法分析</strong></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1743060700401.png" alt="一般树链式结构的时间复杂度"></p>]]></content>
    
    
    <summary type="html">本章介绍了重要的数据结构：树。并详细讲解了二叉树。包括：树的定义、树的图论性质。并通过 Python 实现了树（基于链表 vs 基于数组），同时分析了时间复杂度。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.iskage.online/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://blog.iskage.online/tags/Python/"/>
    
    <category term="数据结构" scheme="https://blog.iskage.online/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法设计" scheme="https://blog.iskage.online/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="面向对象" scheme="https://blog.iskage.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>统计软件 R 语言学习笔记 (6) 统计图表</title>
    <link href="https://blog.iskage.online/posts/86c8422a.html"/>
    <id>https://blog.iskage.online/posts/86c8422a.html</id>
    <published>2025-03-26T01:44:00.000Z</published>
    <updated>2025-04-17T08:09:49.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计软件-R-语言笔记-6-：统计图表"><a href="#统计软件-R-语言笔记-6-：统计图表" class="headerlink" title="统计软件 R 语言笔记 (6)：统计图表"></a>统计软件 R 语言笔记 (6)：统计图表</h1><p>本章介绍了常见的统计图表和其 R 语言实现方法：频数频率图表、条形/柱状图、列联表、饼图；直方图、箱线图、散点图。同时介绍了 R 语言绘图的范式：高级&amp;低级绘图函数、常见参数设置、子图、保存图片的方法。</p><p>代码和笔记存储在 <a href="https://github.com/iskage/r-notes">GitHub 库</a> <strong>【持续更新中，建议 star！】</strong></p><h2 id="1-定性变量的统计图表"><a href="#1-定性变量的统计图表" class="headerlink" title="1 定性变量的统计图表"></a>1 定性变量的统计图表</h2><h3 id="1-1-频率-频数表（Frequency-Table）"><a href="#1-1-频率-频数表（Frequency-Table）" class="headerlink" title="1.1 频率/频数表（Frequency Table）"></a>1.1 频率/频数表（Frequency Table）</h3><p><strong>定义</strong>：统计各分类出现的次数或比例。</p><p><strong>R实现</strong>  </p><ul><li><p>简单频数表：<code>table()</code> 函数  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 示例：性别频数表</span></span><br><span class="line"><span class="operator">&gt;</span> gender <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;男&quot;</span><span class="punctuation">,</span> <span class="string">&quot;女&quot;</span><span class="punctuation">,</span> <span class="string">&quot;男&quot;</span><span class="punctuation">,</span> <span class="string">&quot;男&quot;</span><span class="punctuation">,</span> <span class="string">&quot;女&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> freq_table <span class="operator">&lt;-</span> table<span class="punctuation">(</span>gender<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>freq_table<span class="punctuation">)</span></span><br><span class="line">gender</span><br><span class="line">男 女 </span><br><span class="line"> <span class="number">3</span>  <span class="number">2</span> </span><br></pre></td></tr></table></figure></li><li><p><strong>频率表（百分比）</strong>：<code>prop.table()</code> 函数</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> prop_table <span class="operator">&lt;-</span> prop.table<span class="punctuation">(</span>freq_table<span class="punctuation">)</span> <span class="operator">*</span> <span class="number">100</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>prop_table<span class="punctuation">)</span></span><br><span class="line">gender</span><br><span class="line">男 女 </span><br><span class="line"><span class="number">60</span> <span class="number">40</span> </span><br></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong>：若数据为数值型但需按分类统计，需先转换为因子：<code>factor(data)</code>。</p><h3 id="1-2-条形图-柱状图（Bar-Chart）"><a href="#1-2-条形图-柱状图（Bar-Chart）" class="headerlink" title="1.2 条形图/柱状图（Bar Chart）"></a>1.2 条形图/柱状图（Bar Chart）</h3><p><strong>用途</strong>：展示分类变量的频数分布，支持横向/纵向排列。</p><p><strong>R实现</strong></p><ul><li><p>基础绘图：<code>barplot()</code>  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">barplot<span class="punctuation">(</span>freq_table<span class="punctuation">,</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;gender bar plot&quot;</span><span class="punctuation">,</span>  <span class="comment"># 标题</span></span><br><span class="line">    xlab <span class="operator">=</span> <span class="string">&quot;gender&quot;</span><span class="punctuation">,</span><span class="comment"># x 轴</span></span><br><span class="line">    ylab <span class="operator">=</span> <span class="string">&quot;freq&quot;</span><span class="punctuation">,</span><span class="comment"># y 轴</span></span><br><span class="line">    col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="comment"># 颜色</span></span><br><span class="line">    horiz <span class="operator">=</span> <span class="literal">TRUE</span><span class="comment"># 是否横向</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li><li><p>堆叠条形图：<code>barplot(height)</code> 当 <code>height</code> 为矩阵时</p></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> <span class="number">30</span><span class="punctuation">,</span> <span class="number">25</span><span class="punctuation">,</span> <span class="number">35</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">,</span> <span class="number">40</span><span class="punctuation">)</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rownames<span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Male&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Female&quot;</span><span class="punctuation">)</span></span><br><span class="line">colnames<span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span><span class="punctuation">,</span> <span class="string">&quot;C&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制堆叠条形图</span></span><br><span class="line">barplot<span class="punctuation">(</span>data<span class="punctuation">,</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;Gender Distribution by Category&quot;</span><span class="punctuation">,</span></span><br><span class="line">    beside <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span>  <span class="comment"># 默认 FALSE ，为 TRUE 则不是堆叠而是并列</span></span><br><span class="line">    xlab <span class="operator">=</span> <span class="string">&quot;Category&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ylab <span class="operator">=</span> <span class="string">&quot;Frequency&quot;</span><span class="punctuation">,</span></span><br><span class="line">    col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    legend.text <span class="operator">=</span> rownames<span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 添加图例</span></span><br><span class="line">    args.legend <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;topright&quot;</span><span class="punctuation">)</span> <span class="comment"># 图例位置</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/stacked_and_grouped_barplot.png" alt="并列和堆叠"></p><ul><li><code>ggplot2</code> 库 <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>data.frame<span class="punctuation">(</span>gender<span class="punctuation">)</span><span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> gender<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_bar<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    labs<span class="punctuation">(</span>title <span class="operator">=</span> <span class="string">&quot;gender bar plot&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;gender&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;freq&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-列联表（Contingency-Table）"><a href="#1-3-列联表（Contingency-Table）" class="headerlink" title="1.3 列联表（Contingency Table）"></a>1.3 列联表（Contingency Table）</h3><p><strong>定义</strong>：分析两个或多个分类变量的交叉分布。</p><p><strong>R实现</strong>  </p><ul><li>基础方法：<code>table(var1, var2)</code> 或 <code>xtabs(~var1 + var2, data)</code>  </li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 示例：性别与血型列联表</span></span><br><span class="line"><span class="operator">&gt;</span> blood_type <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span><span class="punctuation">,</span> <span class="string">&quot;O&quot;</span><span class="punctuation">,</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> cross_table <span class="operator">&lt;-</span> table<span class="punctuation">(</span>gender<span class="punctuation">,</span> blood_type<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>cross_table<span class="punctuation">)</span></span><br><span class="line">      blood_type</span><br><span class="line">gender A B O</span><br><span class="line">    男 <span class="number">2</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">    女 <span class="number">0</span> <span class="number">2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>添加边际和：<code>addmargins()</code>  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> addmargins<span class="punctuation">(</span>cross_table<span class="punctuation">)</span></span><br><span class="line">      blood_type</span><br><span class="line">gender A B O Sum</span><br><span class="line">   男  <span class="number">2</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">   女  <span class="number">0</span> <span class="number">2</span> <span class="number">0</span>   <span class="number">2</span></span><br><span class="line">   Sum <span class="number">2</span> <span class="number">2</span> <span class="number">1</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>比例表：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> prop.table<span class="punctuation">(</span>cross_table<span class="punctuation">,</span> margin <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span>  <span class="comment"># 按行计算比例</span></span><br><span class="line">      blood_type</span><br><span class="line">gender         A         B         O</span><br><span class="line">    男 <span class="number">0.6666667</span> <span class="number">0.0000000</span> <span class="number">0.3333333</span></span><br><span class="line">    女 <span class="number">0.0000000</span> <span class="number">1.0000000</span> <span class="number">0.0000000</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-饼图（Pie-Chart）"><a href="#1-4-饼图（Pie-Chart）" class="headerlink" title="1.4 饼图（Pie Chart）"></a>1.4 饼图（Pie Chart）</h3><p><strong>用途</strong>：展示各类别占比（适用于少量分类）。</p><p><strong>R实现</strong>  </p><ul><li>基础绘图：<code>pie()</code>  <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gender <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Male&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Female&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Male&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Male&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Female&quot;</span><span class="punctuation">)</span></span><br><span class="line">freq_table <span class="operator">&lt;-</span> table<span class="punctuation">(</span>gender<span class="punctuation">)</span></span><br><span class="line">pie<span class="punctuation">(</span>freq_table<span class="punctuation">,</span></span><br><span class="line">    labels <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>freq_table<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 每一块扇形标签 字符型向量</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;Pie of gender&quot;</span><span class="punctuation">,</span> <span class="comment"># 表头</span></span><br><span class="line">    col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">)</span> <span class="comment"># 颜色</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以展示占比</span></span><br><span class="line">prop_table <span class="operator">&lt;-</span> prop.table<span class="punctuation">(</span>freq_table<span class="punctuation">)</span> <span class="operator">*</span> <span class="number">100</span></span><br><span class="line">gender <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Male&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Female&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Male&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Male&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Female&quot;</span><span class="punctuation">)</span></span><br><span class="line">freq_table <span class="operator">&lt;-</span> table<span class="punctuation">(</span>gender<span class="punctuation">)</span></span><br><span class="line">pie<span class="punctuation">(</span>freq_table<span class="punctuation">,</span></span><br><span class="line">    labels <span class="operator">=</span> paste<span class="punctuation">(</span>prop_table<span class="punctuation">,</span> <span class="string">&quot;%&quot;</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 每一块扇形标签 字符型向量</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;Pie of gender&quot;</span><span class="punctuation">,</span> <span class="comment"># 表头</span></span><br><span class="line">    col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">)</span> <span class="comment"># 颜色</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/pie.png" alt=""></p><ul><li><code>ggplot2</code> 库</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data.frame<span class="punctuation">(</span>gender<span class="punctuation">)</span><span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> gender<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_bar<span class="punctuation">(</span>width <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    coord_polar<span class="punctuation">(</span>theta <span class="operator">=</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    labs<span class="punctuation">(</span>title <span class="operator">=</span> <span class="string">&quot;Pie of gender&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    theme_void<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="2-定量变量的统计图表"><a href="#2-定量变量的统计图表" class="headerlink" title="2 定量变量的统计图表"></a>2 定量变量的统计图表</h2><h3 id="2-1-直方图（Histogram）"><a href="#2-1-直方图（Histogram）" class="headerlink" title="2.1 直方图（Histogram）"></a>2.1 直方图（Histogram）</h3><p><strong>用途</strong>：展示连续变量的分布与频数，通过分箱（bin）统计。直方图中，矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，因此其高度与宽度均有意义。</p><p><strong>格式</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hist<span class="punctuation">(</span>x<span class="punctuation">,</span> breaks <span class="operator">=</span> <span class="string">&quot;Sturges&quot;</span><span class="punctuation">,</span></span><br><span class="line">     freq <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> probability <span class="operator">=</span> <span class="operator">!</span>freq<span class="punctuation">,</span></span><br><span class="line">     include.lowest <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> fuzz <span class="operator">=</span> <span class="number">1e-7</span><span class="punctuation">,</span></span><br><span class="line">     density <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> angle <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;lightgray&quot;</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     main <span class="operator">=</span> paste<span class="punctuation">(</span><span class="string">&quot;Histogram of&quot;</span> <span class="punctuation">,</span> xname<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">     xlim <span class="operator">=</span> <span class="built_in">range</span><span class="punctuation">(</span>breaks<span class="punctuation">)</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">     xlab <span class="operator">=</span> xname<span class="punctuation">,</span> ylab<span class="punctuation">,</span></span><br><span class="line">     axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> plot <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">     nclass <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> warn.unused <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>参数</strong></th><th style="text-align:left"><strong>说明</strong></th><th style="text-align:left"><strong>默认值</strong></th></tr></thead><tbody><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">输入数据，通常为数值型向量。</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left"><code>breaks</code></td><td style="text-align:left">定义直方图的区间划分方式。可以是区间数（如 10）、区间向量（如 <code>c(0, 10, 20)</code>）或字符串（如 “Sturges”）。</td><td style="text-align:left"><code>&quot;Sturges&quot;</code></td></tr><tr><td style="text-align:left"><code>freq</code></td><td style="text-align:left">是否显示频数（TRUE）或概率密度（FALSE）。</td><td style="text-align:left"><code>NULL</code></td></tr><tr><td style="text-align:left"><code>probability</code></td><td style="text-align:left">是否绘制概率密度图（TRUE）或频数直方图（FALSE）。</td><td style="text-align:left"><code>!freq</code></td></tr><tr><td style="text-align:left"><code>include.lowest</code></td><td style="text-align:left">是否包含区间的最小值。</td><td style="text-align:left"><code>TRUE</code></td></tr><tr><td style="text-align:left"><code>right</code></td><td style="text-align:left">区间是否右闭合（TRUE）或左闭合（FALSE）。</td><td style="text-align:left"><code>TRUE</code></td></tr><tr><td style="text-align:left"><code>col</code></td><td style="text-align:left">填充颜色。</td><td style="text-align:left"><code>&quot;lightgray&quot;</code></td></tr><tr><td style="text-align:left"><code>main</code></td><td style="text-align:left">图形标题。</td><td style="text-align:left"><code>paste(&quot;Histogram of&quot;, xname)</code></td></tr><tr><td style="text-align:left"><code>xlim</code></td><td style="text-align:left">x轴范围。</td><td style="text-align:left"><code>range(breaks)</code></td></tr><tr><td style="text-align:left"><code>ylim</code></td><td style="text-align:left">y轴范围。</td><td style="text-align:left"><code>NULL</code></td></tr><tr><td style="text-align:left"><code>xlab</code></td><td style="text-align:left">x轴标签。</td><td style="text-align:left"><code>xname</code></td></tr><tr><td style="text-align:left"><code>ylab</code></td><td style="text-align:left">y轴标签。</td><td style="text-align:left">自动生成</td></tr><tr><td style="text-align:left"><code>axes</code></td><td style="text-align:left">是否绘制坐标轴。</td><td style="text-align:left"><code>TRUE</code></td></tr><tr><td style="text-align:left"><code>plot</code></td><td style="text-align:left">是否绘制图形（TRUE）或仅返回计算结果（FALSE）。</td><td style="text-align:left"><code>TRUE</code></td></tr><tr><td style="text-align:left"><code>labels</code></td><td style="text-align:left">是否在条形上方显示标签。</td><td style="text-align:left"><code>FALSE</code></td></tr><tr><td style="text-align:left"><code>nclass</code></td><td style="text-align:left">区间数的替代参数。</td><td style="text-align:left"><code>NULL</code></td></tr></tbody></table></div><p><strong>示例</strong></p><ul><li>基础绘图：<code>hist()</code>  </li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span><span class="number">1000</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> sd <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">hist<span class="punctuation">(</span>data<span class="punctuation">,</span></span><br><span class="line">    breaks <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> <span class="comment"># 分箱数</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;Histogram&quot;</span><span class="punctuation">,</span></span><br><span class="line">    xlab <span class="operator">=</span> <span class="string">&quot;values&quot;</span><span class="punctuation">,</span></span><br><span class="line">    col <span class="operator">=</span> <span class="string">&quot;skyblue&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加趋势线</span></span><br><span class="line">xfit <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="built_in">min</span><span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">max</span><span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">length</span> <span class="operator">=</span> <span class="number">40</span><span class="punctuation">)</span></span><br><span class="line">yfit <span class="operator">&lt;-</span> dnorm<span class="punctuation">(</span>xfit<span class="punctuation">,</span> mean <span class="operator">=</span> mean<span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">,</span> sd <span class="operator">=</span> sd<span class="punctuation">(</span>data<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>xfit<span class="punctuation">,</span> yfit<span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> lwd <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/hist.png" alt="hist" style="zoom:67%;" /></p><h3 id="2-2-箱线图（Boxplot）"><a href="#2-2-箱线图（Boxplot）" class="headerlink" title="2.2 箱线图（Boxplot）"></a>2.2 箱线图（Boxplot）</h3><p><strong>用途</strong>： 展示数据的中位数、四分位数、离群点，支持分组比较。</p><p><strong>格式</strong>  </p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>参数</strong></th><th style="text-align:center"><strong>说明</strong></th><th style="text-align:center"><strong>默认值</strong></th></tr></thead><tbody><tr><td style="text-align:center"><code>x</code></td><td style="text-align:center">输入数据，可以是向量、列表或公式（如 <code>y ~ group</code>）。</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center"><code>...</code></td><td style="text-align:center">其他图形参数（如 <code>main</code>, <code>xlab</code>, <code>ylab</code> 等）。</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center"><code>range</code></td><td style="text-align:center">定义异常值的范围（默认为 1.5 倍的四分位距）。</td><td style="text-align:center"><code>1.5</code></td></tr><tr><td style="text-align:center"><code>width</code></td><td style="text-align:center">箱线图的宽度。</td><td style="text-align:center"><code>NULL</code></td></tr><tr><td style="text-align:center"><code>varwidth</code></td><td style="text-align:center">是否根据样本量调整箱线图宽度。</td><td style="text-align:center"><code>FALSE</code></td></tr><tr><td style="text-align:center"><code>notch</code></td><td style="text-align:center">是否绘制缺口以比较中位数的显著性。</td><td style="text-align:center"><code>FALSE</code></td></tr><tr><td style="text-align:center"><code>outline</code></td><td style="text-align:center">是否显示异常值。</td><td style="text-align:center"><code>TRUE</code></td></tr><tr><td style="text-align:center"><code>names</code></td><td style="text-align:center">箱线图的组别标签。</td><td style="text-align:center">自动生成</td></tr><tr><td style="text-align:center"><code>col</code></td><td style="text-align:center">箱线图的填充颜色。</td><td style="text-align:center"><code>&quot;lightgray&quot;</code></td></tr><tr><td style="text-align:center"><code>log</code></td><td style="text-align:center">是否对坐标轴取对数。</td><td style="text-align:center"><code>&quot;&quot;</code></td></tr><tr><td style="text-align:center"><code>pars</code></td><td style="text-align:center">图形参数的列表（如 <code>boxwex</code>, <code>staplewex</code>, <code>outwex</code>）。</td><td style="text-align:center"><code>list(boxwex = 0.8, staplewex = 0.5, outwex = 0.5)</code></td></tr><tr><td style="text-align:center"><code>ann</code></td><td style="text-align:center">是否绘制坐标轴标签和标题。</td><td style="text-align:center"><code>!add</code></td></tr><tr><td style="text-align:center"><code>horizontal</code></td><td style="text-align:center">是否绘制水平箱线图。</td><td style="text-align:center"><code>FALSE</code></td></tr><tr><td style="text-align:center"><code>add</code></td><td style="text-align:center">是否将箱线图添加到现有图形中。</td><td style="text-align:center"><code>FALSE</code></td></tr><tr><td style="text-align:center"><code>at</code></td><td style="text-align:center">箱线图的位置（用于并排箱线图）。</td><td style="text-align:center"><code>NULL</code></td></tr></tbody></table></div><p><strong>示例</strong></p><ul><li>单组箱线图</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>data<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Boxplot of Normal Data&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;skyblue&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>并排箱线图</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并排箱线图</span></span><br><span class="line">group1 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">group2 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span></span><br><span class="line">    group1<span class="punctuation">,</span></span><br><span class="line">    group2<span class="punctuation">,</span></span><br><span class="line">    <span class="built_in">names</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Group 1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Group 2&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;Side-by-Side Boxplot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ul><li>带缺口的箱线图（只是为了突出中位数）</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">group1 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">group2 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span><span class="number">100</span><span class="punctuation">,</span> mean <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span></span><br><span class="line">    group1<span class="punctuation">,</span></span><br><span class="line">    group2<span class="punctuation">,</span></span><br><span class="line">    notch <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">    <span class="built_in">names</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Group 1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Group 2&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;Notched Boxplot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/boxplots.png" alt="boxplots"></p><ul><li><code>~</code> 分组绘制</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用内置数据集 mtcars</span></span><br><span class="line">boxplot<span class="punctuation">(</span>mpg <span class="operator">~</span> cyl<span class="punctuation">,</span> <span class="comment"># mpg 按照 cyl 分组画出 boxplot</span></span><br><span class="line">    data <span class="operator">=</span> mtcars<span class="punctuation">,</span> <span class="comment"># mpg, cyl 都是数据框 mtcars 的列</span></span><br><span class="line">    main <span class="operator">=</span> <span class="string">&quot;MPG by Cylinder&quot;</span><span class="punctuation">,</span></span><br><span class="line">    xlab <span class="operator">=</span> <span class="string">&quot;Number of Cylinders&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ylab <span class="operator">=</span> <span class="string">&quot;Miles per Gallon&quot;</span><span class="punctuation">,</span></span><br><span class="line">    col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;skyblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pink&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lightgreen&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/grouped_boxplots.png" alt="分组绘制：mpg 按照 cyl 分组画出 boxplot，而 cyl 有三组"></p><h3 id="2-3-散点图（Scatter-Plot）两个定量变量"><a href="#2-3-散点图（Scatter-Plot）两个定量变量" class="headerlink" title="2.3 散点图（Scatter Plot）两个定量变量"></a>2.3 散点图（Scatter Plot）两个定量变量</h3><p><strong>用途</strong>：分析两个定量变量的相关性或分布模式。</p><p><strong>基础使用</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>women<span class="operator">$</span>height<span class="punctuation">,</span> women<span class="operator">$</span>weight<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>下面，借由这个例子，介绍 R 语言绘图的范式。</p><h2 id="3-R-语言绘图"><a href="#3-R-语言绘图" class="headerlink" title="3 R 语言绘图"></a>3 R 语言绘图</h2><h3 id="3-1-高级-amp-低级绘图函数"><a href="#3-1-高级-amp-低级绘图函数" class="headerlink" title="3.1 高级 &amp; 低级绘图函数"></a>3.1 高级 &amp; 低级绘图函数</h3><p>在R中有两种绘图函数：</p><ul><li><strong>高级绘图函数</strong>：创建一个新的图形，如 <code>hist</code> <code>plot</code> 。</li><li><strong>低级绘图函数</strong>：在现有的图形上添加元素，对原有图进行补充，如 <code>lines</code> 。</li></ul><h4 id="3-1-1-高级绘图函数"><a href="#3-1-1-高级绘图函数" class="headerlink" title="3.1.1 高级绘图函数"></a>3.1.1 高级绘图函数</h4><div class="table-container"><table><thead><tr><th><strong>函数名</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td><code>plot(x)</code></td><td>以 x 的元素值为纵坐标、以序号为横坐标绘图</td></tr><tr><td><code>plot(x,y)</code></td><td>x 与 y 的二元作图</td></tr><tr><td><code>pie(x)</code></td><td>饼图</td></tr><tr><td><code>boxplot(x)</code></td><td>盒形图（也称箱线图）</td></tr><tr><td><code>hist(x)</code></td><td>x 的频率直方图</td></tr><tr><td><code>barplot(x)</code></td><td>x 的值的条形图</td></tr><tr><td><code>qqnorm(x)</code></td><td>正态分位数-分位数图</td></tr></tbody></table></div><h4 id="3-1-2-低级绘图函数"><a href="#3-1-2-低级绘图函数" class="headerlink" title="3.1.2 低级绘图函数"></a>3.1.2 低级绘图函数</h4><div class="table-container"><table><thead><tr><th><strong>函数名</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td><code>points(x, y)</code></td><td>添加点</td></tr><tr><td><code>lines(X, Y)</code></td><td>添加线</td></tr><tr><td><code>text(x, y, labels, ...)</code></td><td>加标记，在 (x, y) 处添加用 labels 指定的文字</td></tr><tr><td><code>abline(a, b)</code></td><td>加直线，绘制斜率为 b 和截距为 a 的直线</td></tr><tr><td><code>abline(h = y)</code></td><td>加直线，在纵坐标 y 处画水平线</td></tr><tr><td><code>abline(v = x)</code></td><td>加直线，在横坐标 x 处画垂直线</td></tr><tr><td><code>abline(lm.obj)</code></td><td>加直线，画出 lm.obj 确定的回归线</td></tr><tr><td><code>legend(x, y, legend)</code></td><td>加注释，在点 (x, y) 处，说明内容由 legend 给定</td></tr><tr><td><code>title()</code></td><td>加标题，也可添加一个副标题</td></tr><tr><td><code>axis(side, vect)</code></td><td>加坐标轴</td></tr></tbody></table></div><h3 id="3-2-参数"><a href="#3-2-参数" class="headerlink" title="3.2 参数"></a>3.2 参数</h3><h4 id="3-2-1-共同参数选项"><a href="#3-2-1-共同参数选项" class="headerlink" title="3.2.1 共同参数选项"></a>3.2.1 共同参数选项</h4><div class="table-container"><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>axes=TRUE</code></td><td>如果是 FALSE，不绘制轴与边框</td></tr><tr><td><code>type=&quot;p&quot;</code></td><td>指定图形的类型</td></tr><tr><td><code>xlim=, ylim=</code></td><td>指定轴的显示范围</td></tr><tr><td><code>xlab=, ylab=</code></td><td>坐标轴的标签</td></tr><tr><td><code>main=</code></td><td>主标题</td></tr><tr><td><code>sub=</code></td><td>副标题</td></tr></tbody></table></div><blockquote><p><code>&quot;p&quot;</code>：点</p><p><code>&quot;l&quot;</code>：线</p><p><code>&quot;b&quot;</code>：点连线</p><p><code>&quot;o&quot;</code>：同上，但是线在点上</p><p><code>&quot;h&quot;</code>：垂直线</p><p><code>&quot;s&quot;</code>：阶梯式，垂直线顶端显示数据</p><p><code>&quot;S&quot;</code>：同上，但是垂直线底端显示数据</p></blockquote><p>示例：一些常见参数的用法</p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742892621595.png" alt="共同参数的指代"></p><p>示例：不同的点类型 <code>type</code></p><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742892676179.png" alt="不同点类型，参数 type"></p><h4 id="3-2-2-其他常用绘图参数"><a href="#3-2-2-其他常用绘图参数" class="headerlink" title="3.2.2 其他常用绘图参数"></a>3.2.2 其他常用绘图参数</h4><div class="table-container"><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>adj</code></td><td>控制关于文字对齐方式（0-左对齐，0.5-居中对齐，1-右对齐）</td></tr><tr><td><code>cex</code></td><td>符号和文字大小：<code>cex.axis</code>, <code>cex.main</code>, <code>cex.axis</code>, <code>cex.main</code></td></tr><tr><td><code>col</code></td><td>颜色： <code>col.axis</code>, <code>col.lab</code>, <code>col.main</code>, <code>col.axis</code>, <code>col.lab</code>, <code>col.main</code></td></tr><tr><td><code>font</code></td><td>文字字体（1-正常，2-粗体，3-斜体，4-粗斜体）：<code>font.axis</code>, <code>font.lab</code>, <code>font.main</code>, <code>font.axis</code>, <code>font.lab</code>, <code>font.main</code></td></tr><tr><td><code>lwd</code></td><td>线的宽度</td></tr><tr><td><code>lty</code></td><td>连线的线型（1-实线，2-虚线，3-点线，4-点虚线，5-长虚线，6-双虚线）</td></tr><tr><td><code>pch</code></td><td>绘图符号的类型（1到25的整数）</td></tr><tr><td><code>pty</code></td><td>绘图区域类型</td></tr><tr><td><code>xaxt</code> <code>yaxt</code></td><td>如果 <code>xaxt=&quot;n&quot;</code>，设置 x 轴不显示；如果 <code>yaxt=&quot;n&quot;</code>，设置 y 轴不显示</td></tr><tr><td><code>srt</code></td><td>文字旋转角度</td></tr></tbody></table></div><p><img src="https://blog-iskage.oss-cn-hangzhou.aliyuncs.com/images/QQ_1742893115596.png" alt="pch 不同数字对应的图案" style="zoom:100%;" /></p><p>特别地，<code>pch</code> 可以传入一个字符串向量，当作图案：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pch_type <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;?&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1&quot;</span><span class="punctuation">)</span></span><br><span class="line">X <span class="operator">&lt;-</span> 1<span class="operator">:</span><span class="number">5</span></span><br><span class="line">Y <span class="operator">&lt;-</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">6</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> col <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> pch <span class="operator">=</span> pch_type<span class="punctuation">,</span> cex <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;pch:*aA?1&quot;</span><span class="punctuation">,</span> font.lab <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p><code>pch = pch_type</code> ：图案可以自定义 <code>pch_type</code></p></blockquote><h3 id="3-3-画图面板分割：子图"><a href="#3-3-画图面板分割：子图" class="headerlink" title="3.3 画图面板分割：子图"></a>3.3 画图面板分割：子图</h3><p><code>mfrow</code> 参数：</p><ul><li><p>按<strong>行顺序</strong>填充子面板。</p></li><li><p>语法：<code>par(mfrow = c(nrow, ncol))</code>，其中 <code>nrow</code> 是行数，<code>ncol</code> 是列数。</p></li><li>示例：<code>par(mfrow = c(2, 2))</code> 将绘图窗口分割为 2 行 2 列，共 4 个子面板。</li></ul><p><code>mfcol</code> 参数：</p><ul><li>按<strong>列顺序</strong>填充子面板。</li><li>语法：<code>par(mfcol = c(nrow, ncol))</code>。</li></ul><p>示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置绘图面板为 2 行 2 列</span></span><br><span class="line">op <span class="operator">&lt;-</span> par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">X <span class="operator">&lt;-</span> 1<span class="operator">:</span><span class="number">10</span></span><br><span class="line">Y <span class="operator">&lt;-</span> 1<span class="operator">:</span><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制默认点图</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Default&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制蓝色点图</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Blue Point&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制红色点图</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Red Point&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制绿色点图</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Green Point&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">par<span class="punctuation">(</span>op<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><p>用 <code>op</code> 对象存储 <code>par()</code> 函数的子图设置，再次使用 <code>par(op)</code> 即可重置默认设置。否则，之后的绘图会一直按照 最开始 <code>par()</code> 的设置放置。</p></blockquote><h3 id="3-4-保存图片"><a href="#3-4-保存图片" class="headerlink" title="3.4 保存图片"></a>3.4 保存图片</h3><h4 id="3-4-1-png-保存为-PNG-图片"><a href="#3-4-1-png-保存为-PNG-图片" class="headerlink" title="3.4.1 png() 保存为 PNG 图片"></a>3.4.1 png() 保存为 PNG 图片</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开 PNG 设备，设置文件名和尺寸</span></span><br><span class="line">png<span class="punctuation">(</span><span class="string">&quot;my_plot.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">800</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">600</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;My Plot&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭设备，保存图片</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><code>&quot;my_plot.png&quot;</code>：保存的文件名。  </li><li><code>width</code> 和 <code>height</code>：图片的宽度和高度（单位：像素）。  </li><li><code>dev.off()</code>：关闭图形设备，保存图片。  </li></ul><h4 id="3-4-2-pdf-保存为-PDF-文件"><a href="#3-4-2-pdf-保存为-PDF-文件" class="headerlink" title="3.4.2 pdf() 保存为 PDF 文件"></a>3.4.2 pdf() 保存为 PDF 文件</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开 PDF 设备，设置文件名和尺寸</span></span><br><span class="line">pdf<span class="punctuation">(</span><span class="string">&quot;my_plot.pdf&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;My Plot&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭设备，保存文件</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><code>&quot;my_plot.pdf&quot;</code>：保存的文件名。  </li><li><code>width</code> 和 <code>height</code>：图片的宽度和高度（单位：英寸）。  </li></ul><hr><h4 id="3-4-3-jpeg-保存为-JPEG-图片"><a href="#3-4-3-jpeg-保存为-JPEG-图片" class="headerlink" title="3.4.3 jpeg() 保存为 JPEG 图片"></a>3.4.3 jpeg() 保存为 JPEG 图片</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开 JPEG 设备，设置文件名和尺寸</span></span><br><span class="line">jpeg<span class="punctuation">(</span><span class="string">&quot;my_plot.jpg&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">800</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">600</span><span class="punctuation">,</span> quality <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;My Plot&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭设备，保存图片</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>  </p><ul><li><code>quality</code>：图片质量（0-100），值越大质量越高。  </li></ul><h4 id="3-4-4-dev-copy-保存当前图片"><a href="#3-4-4-dev-copy-保存当前图片" class="headerlink" title="3.4.4 dev.copy() 保存当前图片"></a>3.4.4 dev.copy() 保存当前图片</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;My Plot&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制当前图形并保存为 PNG</span></span><br><span class="line">dev.copy<span class="punctuation">(</span>png<span class="punctuation">,</span> <span class="string">&quot;my_plot.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">800</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">600</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><strong>适用场景</strong>：在已经绘制图形的情况下，直接保存当前图形。  </p><h4 id="3-4-5-保存多子图面板"><a href="#3-4-5-保存多子图面板" class="headerlink" title="3.4.5 保存多子图面板"></a>3.4.5 保存多子图面板</h4><p>如果使用 <code>par(mfrow = c(nrow, ncol))</code> 绘制了多子图面板，可以直接保存整个面板：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开 PNG 设备</span></span><br><span class="line">png<span class="punctuation">(</span><span class="string">&quot;multi_panel_plot.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">1200</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">800</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置面板布局</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制多个子图</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Default&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Blue Point&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Red Point&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;Green Point&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭设备，保存图片</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">本章介绍了常见的统计图表和其 R 语言实现方法：频数频率图表、条形/柱状图、列联表、饼图；直方图、箱线图、散点图。同时介绍了 R 语言绘图的范式：高级&amp;低级绘图函数、常见参数设置、子图、保存图片的方法。</summary>
    
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/categories/R-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/tags/R-%E8%AF%AD%E8%A8%80/"/>
    
    <category term="统计软件" scheme="https://blog.iskage.online/tags/%E7%BB%9F%E8%AE%A1%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="R programming" scheme="https://blog.iskage.online/tags/R-programming/"/>
    
  </entry>
  
  <entry>
    <title>统计软件 R 语言学习笔记 (5) 统计数据类型和日期时间数据</title>
    <link href="https://blog.iskage.online/posts/ccdaeb5f.html"/>
    <id>https://blog.iskage.online/posts/ccdaeb5f.html</id>
    <published>2025-03-25T04:44:00.000Z</published>
    <updated>2025-04-17T08:09:52.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计数据类型和日期时间数据"><a href="#统计数据类型和日期时间数据" class="headerlink" title="统计数据类型和日期时间数据"></a>统计数据类型和日期时间数据</h1><p>本章介绍统计数据的计量尺度（定类、定序、定距、定比），重点介绍了一种特殊的数据类型：时间和日期。并讲解了一些常用时间日期函数：<code>strptime</code> <code>as.Date</code> ，除此之外还介绍了时间 Times 类型的两种类型 <code>POSIXct</code> 和 <code>POSIXlt</code> 。</p><p>代码和笔记存储在 <a href="https://github.com/iskage/r-notes">GitHub 库</a> <strong>【持续更新中，建议 star！】</strong></p><h2 id="1-统计数据的计量尺度"><a href="#1-统计数据的计量尺度" class="headerlink" title="1 统计数据的计量尺度"></a>1 统计数据的计量尺度</h2><p>统计数据的四种计量尺度：</p><ul><li>定类尺度</li><li>定序尺度</li><li>定距尺度</li><li>定比尺度</li></ul><h3 id="1-1-定类尺度"><a href="#1-1-定类尺度" class="headerlink" title="1.1 定类尺度"></a>1.1 定类尺度</h3><p><strong>概念</strong>：又称列名尺度或类别尺度，是按照研究对象的某种属性将其划分为若干组或类的一种测度。</p><p><strong>举例</strong>：性别 、籍贯、民族等</p><p><strong>特征</strong>：</p><ol><li>只能区分事物的类别，无法比较优劣或大小，</li><li>对应变量：名义变量，比如用 X 表示性别</li><li>文字，数值（标签）：不能加减乘除</li></ol><h3 id="1-2-定序尺度"><a href="#1-2-定序尺度" class="headerlink" title="1.2 定序尺度"></a>1.2 定序尺度</h3><p><strong>概念</strong>：又称顺序尺度，它是对事物之间等级或顺序差别的一种测度。</p><p><strong>举例</strong>：成绩 (A, B, C) 、绩点、学历、年级等。</p><p><strong>特征</strong>：</p><ol><li>对事物可以分类、可以比较优劣和大小，</li><li>对应变量：次序变量</li><li>文字，数值（标签）：不能加减乘除</li></ol><h3 id="1-3-定距尺度"><a href="#1-3-定距尺度" class="headerlink" title="1.3 定距尺度"></a>1.3 定距尺度</h3><p><strong>概念</strong>：又称间隔尺度，是对事物类别或次序之间的间隔进行的一种测度。</p><p><strong>举例</strong>：摄氏温度、年份等。</p><p><strong>特征</strong>：</p><ol><li>能分类、比较大小，计量差距</li><li>没有绝对零点，“0”表示“0”水平，不表示“没有”或“不存在”。</li><li>对应变量：定距变量</li><li>数值，可以加减，不能乘除</li></ol><h3 id="1-4-定比尺度"><a href="#1-4-定比尺度" class="headerlink" title="1.4 定比尺度"></a>1.4 定比尺度</h3><p><strong>概念</strong>：也称比率尺度，是对事物之间比值的一种测度。</p><p><strong>举例</strong>：成绩（0-100）、年龄、企业的产值利润等</p><p><strong>特征</strong>：</p><ol><li>分类、排序、比较大小、求出差异、计算两个数值之间的比率。</li><li>具有绝对零点，即数字 0 表示 “没有” 或 “不存在” 。</li><li>对应变量：定比变量</li><li>数值，可以加减乘除</li></ol><h3 id="1-5-四种计量尺度的比较"><a href="#1-5-四种计量尺度的比较" class="headerlink" title="1.5 四种计量尺度的比较"></a>1.5 四种计量尺度的比较</h3><div class="table-container"><table><thead><tr><th style="text-align:left">数字特征</th><th style="text-align:center">定类尺度</th><th style="text-align:center">定序尺度</th><th style="text-align:center">定距尺度</th><th style="text-align:center">定比尺度</th></tr></thead><tbody><tr><td style="text-align:left">分类 <code>==</code> <code>!=</code></td><td style="text-align:center"><code>True</code></td><td style="text-align:center"><code>True</code></td><td style="text-align:center"><code>True</code></td><td style="text-align:center"><code>True</code></td></tr><tr><td style="text-align:left">排序 <code>&gt;</code> <code>&lt;</code></td><td style="text-align:center"></td><td style="text-align:center"><code>True</code></td><td style="text-align:center"><code>True</code></td><td style="text-align:center"><code>True</code></td></tr><tr><td style="text-align:left">间距 <code>+</code> <code>-</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><code>True</code></td><td style="text-align:center"><code>True</code></td></tr><tr><td style="text-align:left">比值 <code>*</code> <code>/</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><code>True</code></td></tr></tbody></table></div><p>四种尺度所包含的信息量是依次递增的，级别由低到高。（ 定类 &lt; 定序 &lt; 定距 &lt; 定比 ）</p><p>根据较高层次的计量尺度可以获得较低层次的计量尺度。</p><p>不同的尺度数据对应着不同数据显示方法和分析方法。</p><h3 id="1-6-统计数据的类型"><a href="#1-6-统计数据的类型" class="headerlink" title="1.6 统计数据的类型"></a>1.6 统计数据的类型</h3><p><strong>定性数据</strong> ( qualitative data ) ：由 <em>定类</em> 和 <em>定序</em> 尺度计量而成，反映事物的品质特征, 又称为属性数据。</p><p><strong>定量数据</strong> ( quantitative data ) ：由 <em>定距</em> 和 <em>定比</em> 尺度计量而成，反映事物的数量特征。</p><blockquote><p>图 举例：</p><ul><li><p>定性数据：条形图、饼图</p></li><li><p>定量数据：直方图，线图，茎叶图    </p></li></ul><p>分析方法 举例</p><ul><li>定性数据：频数，频率表，众数，列联表</li><li>定量数据：均值，方差，相应回归分析</li></ul></blockquote><h2 id="2-特殊的数据类型：时间与日期"><a href="#2-特殊的数据类型：时间与日期" class="headerlink" title="2 特殊的数据类型：时间与日期"></a>2 特殊的数据类型：时间与日期</h2><p>R 语言用了一种特殊的数据类型来表示日期和时间</p><ul><li>日期用Date类来表示</li><li>时间则是由两个不同的类：<code>POS Xct</code> 、 <code>POSIXIt</code></li></ul><p>例如：查看当前日期和时间 <code>date()</code> <code>Sys.Date()</code> <code>Sys.time()</code></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> date<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;Mon Mar 24 21:40:23 2025&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> Sys.Date<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2025-03-24&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2025-03-24 21:40:37 CST&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>CST</code> ：英语全称为 Central Standard Time (USA) 、Central Standard Time (Australia)、China Standard Time 或 Cuba Standard Time 等四个地方。</p></blockquote><h3 id="2-1-日期-Date"><a href="#2-1-日期-Date" class="headerlink" title="2.1 日期 Date"></a>2.1 日期 Date</h3><ul><li>日期不包括时间，只表示“某年某月某日”。</li><li>内部日期是以 1970年1月1日 至今的天数来存储。</li></ul><h4 id="2-1-1-as-Date-函数基本使用"><a href="#2-1-1-as-Date-函数基本使用" class="headerlink" title="2.1.1 as.Date() 函数基本使用"></a>2.1.1 as.Date() 函数基本使用</h4><ul><li>日期作为 Date 类对象来存储，在 R 里的工作方式是输入一个字符串，比如 <code>&#39;1970-01-01&#39;</code> ，然后用 <code>as.Date()</code> 函数转换成日期。</li><li><code>as.Date()</code> 方法默认传入字符串格式为 <code>&#39;年(4位)-月(2位)-日(2位)&#39;</code>；或者 <code>&#39;年(4位)/月(2位)/日(2位)&#39;</code> 。</li></ul><p>例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> date1 <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;2025-03-25&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> mode<span class="punctuation">(</span>date1<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;numeric&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">class</span><span class="punctuation">(</span>date1<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;Date&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> date2 <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;2025/03/25&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> mode<span class="punctuation">(</span>date2<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;numeric&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">class</span><span class="punctuation">(</span>date2<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;Date&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-unclass-Date-计算日期差"><a href="#2-1-2-unclass-Date-计算日期差" class="headerlink" title="2.1.2 unclass(Date) 计算日期差"></a>2.1.2 unclass(Date) 计算日期差</h4><p>因为 R 语言采用距离 1970年1月1日 的天数来存储日期，所以使用 <code>unclass()</code> 可以检查距离 <code>1970/01/01/</code> 相差的日期数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="built_in">unclass</span><span class="punctuation">(</span>as.Date<span class="punctuation">(</span><span class="string">&quot;2025/03/25&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">20172</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">unclass</span><span class="punctuation">(</span>as.Date<span class="punctuation">(</span><span class="string">&quot;1970/01/01&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment"># 距离 0 天</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">unclass</span><span class="punctuation">(</span>as.Date<span class="punctuation">(</span><span class="string">&quot;1969/12/31&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment"># 相差 -1 天</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">-</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-1-3-as-Date-日期格式"><a href="#2-1-3-as-Date-日期格式" class="headerlink" title="2.1.3 as.Date() 日期格式"></a>2.1.3 as.Date() 日期格式</h4><p><strong>默认格式</strong>：<code>as.Date</code> 函数的默认日期格式为 <code>&#39;年(4位)-月(2位)-日(2位)&#39;</code> 例如<code>&quot;2008-10-24&quot;</code></p><p><strong>自定义格式</strong>：</p><p><code>as.Date</code> 函数支持通过 <code>format</code> 参数指定自定义日期格式。</p><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>%d</code></td><td>数字表示的日期</td><td>01~31</td></tr><tr><td><code>%a</code></td><td>缩写的星期名</td><td>Mon</td></tr><tr><td><code>%A</code></td><td>非缩写星期名</td><td>Monday</td></tr><tr><td><code>%m</code></td><td>月份（00-12）</td><td>00~12</td></tr><tr><td><code>%b</code></td><td>缩写的月份</td><td>Jan</td></tr><tr><td><code>%B</code></td><td>非缩写月份</td><td>January</td></tr><tr><td><code>%y</code></td><td>两位数的年份</td><td>07</td></tr><tr><td><code>%Y</code></td><td>四位数的年份</td><td>2007</td></tr></tbody></table></div><p><strong>示例</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as.Date<span class="punctuation">(</span><span class="string">&quot;10/24/08&quot;</span><span class="punctuation">,</span> format<span class="operator">=</span><span class="string">&quot;%m/%d/%y&quot;</span><span class="punctuation">)</span></span><br><span class="line">as.Date<span class="punctuation">(</span><span class="string">&quot;October-24-2008&quot;</span><span class="punctuation">,</span> format<span class="operator">=</span><span class="string">&quot;%B-%d-%Y&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h4 id="2-1-4-日期计算"><a href="#2-1-4-日期计算" class="headerlink" title="2.1.4 日期计算"></a>2.1.4 日期计算</h4><p>R 语言支持直接计算两个日期之间的差异，结果为 <code>difftime</code> 类型。</p><p><strong>示例</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1 <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;October-24-2008&quot;</span><span class="punctuation">,</span> format<span class="operator">=</span><span class="string">&quot;%B-%d-%Y&quot;</span><span class="punctuation">)</span></span><br><span class="line">T2 <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;October-28-2008&quot;</span><span class="punctuation">,</span> format<span class="operator">=</span><span class="string">&quot;%B-%d-%Y&quot;</span><span class="punctuation">)</span></span><br><span class="line">time_diff <span class="operator">&lt;-</span> T2 <span class="operator">-</span> T1</span><br><span class="line">print<span class="punctuation">(</span>time_diff<span class="punctuation">)</span>  <span class="comment"># Time difference of 4 days</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>time_diff<span class="punctuation">)</span>  <span class="comment"># &quot;difftime&quot;</span></span><br><span class="line">mode<span class="punctuation">(</span>time_diff<span class="punctuation">)</span>   <span class="comment"># &quot;numeric&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong></p><ul><li>如果日期字符串格式与 <code>format</code> 参数不匹配，<code>as.Date</code> 函数会返回 <code>NA</code>。</li><li>确保日期格式化符号与日期字符串中的分隔符一致。</li></ul></blockquote><h3 id="2-2-时间-Times"><a href="#2-2-时间-Times" class="headerlink" title="2.2 时间 Times"></a>2.2 时间 Times</h3><h4 id="2-2-1-strptime-函数"><a href="#2-2-1-strptime-函数" class="headerlink" title="2.2.1 strptime() 函数"></a>2.2.1 strptime() 函数</h4><p><code>strptime()</code> 函数用于将字符串解析为时间对象。其语法如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strptime<span class="punctuation">(</span>x<span class="punctuation">,</span> format<span class="punctuation">,</span> tz <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><code>x</code>: 表示时间的字符串。<br>例如：<code>&quot;October-7-2015 10:40:30&quot;</code>，<code>&quot;December 9, 2011 9:10&quot;</code>。</li><li><code>format</code>: 转换格式，需与字符串格式对应。<br>例如：<code>%B-%d-%Y %H:%M:%S</code>，<code>%B %d, %Y %H:%M</code>。</li><li><code>tz</code>: 表示时区，默认为当前时区。<br>例如：<code>CST</code>（北京时区），<code>GMT</code>（格林威治时间），<code>UTC</code>（世界协调时间）。</li></ul><p><strong>格式化符号</strong></p><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>%B</code></td><td>英文全拼月份</td><td>October</td></tr><tr><td><code>%d</code></td><td>第几天（01-31）</td><td>07</td></tr><tr><td><code>%Y</code></td><td>带世纪的年份</td><td>2015</td></tr><tr><td><code>%H</code></td><td>小时（00-24）</td><td>10</td></tr><tr><td><code>%M</code></td><td>分钟（00-59）</td><td>40</td></tr><tr><td><code>%S</code></td><td>秒（00-61）</td><td>30</td></tr></tbody></table></div><p><strong>示例代码</strong></p><p>解析时间字符串</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> datestring <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;10 7, 2015 10:40&quot;</span><span class="punctuation">,</span> <span class="string">&quot;10 9, 2011 9:10&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> x <span class="operator">&lt;-</span> strptime<span class="punctuation">(</span>datestring<span class="punctuation">,</span> <span class="string">&quot;%m %d, %Y %H:%M&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2015-10-07 10:40:00 CST&quot;</span> <span class="string">&quot;2011-10-09 09:10:00 CST&quot;</span></span><br></pre></td></tr></table></figure><p>查看对象类型</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="built_in">class</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;POSIXlt&quot;</span> <span class="string">&quot;POSIXt&quot;</span> </span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li>格式匹配：确保 <code>format</code> 参数与时间字符串的格式完全一致，否则会返回 <code>NA</code>。</li><li>时区设置：如果未指定 <code>tz</code> 参数，默认使用当前时区。</li><li>大小写敏感：格式化符号（如 <code>%B</code>）区分大小写，需确保正确使用。</li></ol><h4 id="2-2-2-POSIXct-和-POSIXlt"><a href="#2-2-2-POSIXct-和-POSIXlt" class="headerlink" title="2.2.2 POSIXct 和 POSIXlt"></a>2.2.2 POSIXct 和 POSIXlt</h4><p>R 语言中，时间用两种类型表示：<code>POSIXct</code> 和 <code>POSIXlt</code>。</p><h5 id="1-POSIXct"><a href="#1-POSIXct" class="headerlink" title="1. POSIXct"></a>1. POSIXct</h5><p><strong>定义</strong>：时间用大整数表示，即从 1970 年 1 月 1 日至今的秒数。  </p><p><strong>特点</strong>：</p><ul><li>适合存储在数据框中，因为它本质上是一个很大的整数向量。  </li><li>适用于时间戳计算和存储。  </li></ul><p><strong>示例</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> time_ct <span class="operator">&lt;-</span> as.POSIXct<span class="punctuation">(</span><span class="string">&quot;2023-10-05 14:30:00&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_ct<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2023-10-05 14:30:00 CST&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-POSIXlt"><a href="#2-POSIXlt" class="headerlink" title="2. POSIXlt"></a>2. POSIXlt</h5><p><strong>定义</strong>：时间以列表形式存储，包含更多与时间相关的信息。  </p><p><strong>特点</strong>：</p><ul><li>包含星期几、一年中的第几天、月份、日期等详细信息。  </li><li>适合需要提取具体时间信息的场景。  </li></ul><p><strong>示例</strong>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> time_lt <span class="operator">&lt;-</span> as.POSIXlt<span class="punctuation">(</span><span class="string">&quot;2023-10-05 14:30:00&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_lt<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2023-10-05 14:30:00 CST&quot;</span></span><br></pre></td></tr></table></figure><p>提取具体信息：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_lt<span class="operator">$</span>wday<span class="punctuation">)</span> <span class="comment"># 星期几（0=周日，1=周一，...）</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">4</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_lt<span class="operator">$</span>yday<span class="punctuation">)</span> <span class="comment"># 一年中的第几天（0-365）</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">277</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_lt<span class="operator">$</span>mon<span class="punctuation">)</span> <span class="comment"># 月份（0-11，0=1月，1=2月，...）</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">9</span></span><br></pre></td></tr></table></figure></p><h4 id="2-2-3-类型转换"><a href="#2-2-3-类型转换" class="headerlink" title="2.2.3 类型转换"></a>2.2.3 类型转换</h4><p>使用 <code>as.POSIXct()</code> 和 <code>as.POSIXlt()</code> 函数可以在 <code>POSIXct</code> 和 <code>POSIXlt</code> 之间进行转换。</p><p><strong>示例</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 从 POSIXct 转换为 POSIXlt</span></span><br><span class="line"><span class="operator">&gt;</span> time_lt <span class="operator">&lt;-</span> as.POSIXlt<span class="punctuation">(</span>time_ct<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_lt<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2023-10-05 14:30:00 CST&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 从 POSIXlt 转换为 POSIXct</span></span><br><span class="line"><span class="operator">&gt;</span> time_ct <span class="operator">&lt;-</span> as.POSIXct<span class="punctuation">(</span>time_lt<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_ct<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2023-10-05 14:30:00 CST&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>时区问题：默认情况下，R 使用当前时区（如 <code>CST</code>）。可以通过 <code>tz</code> 参数指定时区，例如：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> as.POSIXct<span class="punctuation">(</span><span class="string">&quot;2023-10-05 14:30:00&quot;</span><span class="punctuation">,</span> tz <span class="operator">=</span> <span class="string">&quot;UTC&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2023-10-05 14:30:00 UTC&quot;</span></span><br></pre></td></tr></table></figure><p>时间格式：确保时间字符串与 <code>as.POSIXct()</code> 或 <code>as.POSIXlt()</code> 的默认格式（<code>%Y-%m-%d %H:%M:%S</code>）一致，否则需要指定 <code>format</code> 参数。</p><h4 id="2-2-4-时间处理注意事项"><a href="#2-2-4-时间处理注意事项" class="headerlink" title="2.2.4 时间处理注意事项"></a>2.2.4 时间处理注意事项</h4><p><code>as.POSIXlt()</code> 函数用于将时间转换为 <code>POSIXlt</code> 类，该类以列表形式存储时间信息，便于提取具体的时间元素（如秒、分钟、小时等）。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 获取当前时间</span></span><br><span class="line"><span class="operator">&gt;</span> x <span class="operator">&lt;-</span> Sys.time<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="comment"># 输出当前时间</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2025-03-25 12:33:14 CST&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 查看时间类型</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">class</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;POSIXct&quot;</span> <span class="string">&quot;POSIXt&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 转换为 POSIXlt 类</span></span><br><span class="line"><span class="operator">&gt;</span> tempx <span class="operator">&lt;-</span> as.POSIXlt<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>tempx<span class="punctuation">)</span> <span class="comment"># 输出转换后的时间</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;2025-03-25 12:33:14 CST&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 解构 POSIXlt 对象</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">unclass</span><span class="punctuation">(</span>tempx<span class="punctuation">)</span> <span class="comment"># 查看内部结构</span></span><br><span class="line"><span class="comment"># 包含许多属性，例如：$sec [1] 14.19524 、 $min [1] 33 等</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 提取秒数 （POSIXlt 类 才可以提取秒数）</span></span><br><span class="line"><span class="operator">&gt;</span> seconds <span class="operator">&lt;-</span> tempx<span class="operator">$</span>sec</span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>seconds<span class="punctuation">)</span> <span class="comment"># 输出秒数（可能包含小数部分）</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">14.19524</span></span><br></pre></td></tr></table></figure><p>计算日期差</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 定义两个日期</span></span><br><span class="line"><span class="operator">&gt;</span> x <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;2012-03-01&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> y <span class="operator">&lt;-</span> as.Date<span class="punctuation">(</span><span class="string">&quot;2012-02-28&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 计算日期差</span></span><br><span class="line"><span class="operator">&gt;</span> time_diff <span class="operator">&lt;-</span> x <span class="operator">-</span> y</span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>time_diff<span class="punctuation">)</span> <span class="comment"># 输出: Time difference of 2 days</span></span><br><span class="line">Time difference of <span class="number">2</span> days</span><br></pre></td></tr></table></figure><p>比较日期大小</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="comment"># 比较日期</span></span><br><span class="line"><span class="operator">&gt;</span> is_later <span class="operator">&lt;-</span> x <span class="operator">&gt;</span> y</span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>is_later<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><blockquote><p>只有同一类型的时间才可以比较计算等。</p></blockquote>]]></content>
    
    
    <summary type="html">本章介绍统计数据的计量尺度（定类、定序、定距、定比），重点介绍了一种特殊的数据类型：时间和日期。并讲解了一些常用时间日期函数：`strptime` `as.Date` ，除此之外还介绍了时间 Times 类型的两种类型 `POSIXct` 和 `POSIXlt` 。</summary>
    
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/categories/R-%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="R 语言" scheme="https://blog.iskage.online/tags/R-%E8%AF%AD%E8%A8%80/"/>
    
    <category term="统计软件" scheme="https://blog.iskage.online/tags/%E7%BB%9F%E8%AE%A1%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="R programming" scheme="https://blog.iskage.online/tags/R-programming/"/>
    
  </entry>
  
</feed>
